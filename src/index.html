<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GATEKEEPER - WRONG PLANET</title>
    <!-- Cache bust: 2025-10-19-1659 -->
    
    <!-- Open Graph Meta Tags for Social Media Sharing -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="GATEKEEPER - WRONG PLANET">
    <meta property="og:description" content="Interactive multimedia experience featuring dynamic audio-visual elements and immersive starfield backgrounds.">
    <meta property="og:image" content="https://res.cloudinary.com/dtwix3ubl/image/upload/v1757010129/gkHourglass8_np2lyy.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:alt" content="GATEKEEPER - WRONG PLANET Cover Image">
    <meta property="og:url" content="https://gatekeepermusic.com">
    <meta property="og:site_name" content="GATEKEEPER">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="GATEKEEPER - WRONG PLANET">
    <meta name="twitter:description" content="Interactive multimedia experience featuring dynamic audio-visual elements and immersive starfield backgrounds.">
    <meta name="twitter:image" content="https://res.cloudinary.com/dtwix3ubl/image/upload/v1757010129/gkHourglass8_np2lyy.jpg">
    <meta name="twitter:image:alt" content="GATEKEEPER - WRONG PLANET Cover Image">
    
    <!-- Additional Meta Tags -->
    <meta name="description" content="Interactive multimedia experience featuring dynamic audio-visual elements and immersive starfield backgrounds.">
    <meta name="keywords" content="GATEKEEPER, WRONG PLANET, interactive media, audio-visual, experimental music">
    <meta name="author" content="GATEKEEPER">
    <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><path d='M50 10 L30 50 L50 40 L70 50 Z' fill='%23FFA500'/><path d='M40 50 L50 30 L60 50 L50 70 Z' fill='%23FF8C00'/></svg>">
    <link rel="stylesheet" type="text/css" href="./webamp.css">
    <style>
        :root {
            --webamp-zoom: 1.1;
            /* Deity message font - italic bold Times New Roman with tight kerning */
            --deity-font: 'Times New Roman', serif;
            --deity-font-style: italic;
            --deity-font-weight: bold;
            --deity-letter-spacing: -0.02em;
            /* -20 kerning approximation */

            /* Starfield configuration - easy to modify */
            --starfield-speed: 1.5;
            /* Base speed multiplier */
            --starfield-density: 800;
            /* Number of stars */
            --starfield-brightness: 0.9;
            /* Star brightness (0-1) */
        }

        /* Starfield Canvas - positioned behind everything except unlock overlay */
        #starfield-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 999;
            /* Behind unlock overlay (1000) but above body background */
            pointer-events: none;
            background: #000;
        }



        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
            font-family: Arial, sans-serif;
            cursor: auto !important;
            /* Prevent scrolling */
            position: fixed;
            background-color: #000;
            /* Ensure body background is black */
        }



        #webamp-container {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 10;
            opacity: 0;
            /* No transition - instant appearance after unlock */
            /* Keep visible for Webamp init but transparent */
        }



        #webamp {
            zoom: var(--webamp-zoom) !important;
            -moz-transform: scale(var(--webamp-zoom));
            -moz-transform-origin: top left;
        }

        

        /* Remove any position constraints from windows */
        /* Base styles for all windows */
        #webamp .window {
            position: absolute !important;
            /* Override any other positioning */
            will-change: transform;
            z-index: 2;
            cursor: move !important;
        }
        
        #webamp .window {
            animation: float-main 36s ease-in-out infinite;
        }

        /* Specific animations for each window type */
        #webamp #main-window {
            animation: float-main 36s ease-in-out infinite;
        }

        #webamp #equalizer-window {
            animation: float-eq 36s ease-in-out infinite;
        }

        #webamp #playlist-window {
            animation: float-playlist 36s ease-in-out infinite;
        }



        /* Additional glow effect for windows */
        #webamp .window::after {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            pointer-events: none;
            z-index: -1;
        }

        /* Remove loading text styles */
        #loading {
            display: none;
        }

        /* Override cursor styles except for buttons */
        * {
            cursor: auto !important;
        }

        /* Allow pointer cursor on buttons */
        button,
        .webamp-region button,
        #webamp button,
        [role="button"] {
            cursor: pointer !important;
        }

        /* Dunes background - separate from lock overlay */
        #dunes-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('./assets/images/Dunes.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            z-index: 1000;
            pointer-events: none;
        }

        #dunes-background.slide-out {
            animation: dunesSlideOut 2s ease-in-out forwards;
        }

        /* Key unlocking system overlay */
        #unlock-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: transparent;
            z-index: 1001;
            transition: opacity 2s ease-out;
        }

        #unlock-overlay.tv-turn-off {
            animation: tvTurnOff 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        @keyframes dunesSlideOut {
            0% {
                transform: translateY(0);
            }
            100% {
                transform: translateY(100vh);
            }
        }

        #lock {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 180px;
            height: 180px;
            cursor: default;
            transition: transform 0.3s ease;
        }

        #lock img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        #lock.spinning {
            animation: spin 2s linear infinite;
        }
        
        #lock.glowing {
            animation: yellowOrangeGlow 3s ease-in-out infinite alternate;
        }
        
        #lock.spinning.glowing {
            animation: spin 2s linear infinite, yellowOrangeGlow 3s ease-in-out infinite alternate;
        }

        #key {
            position: absolute;
            width: 302px;  /* 377px * 0.8 = 302px (20% smaller) */
            height: 302px; /* 377px * 0.8 = 302px (20% smaller) */
            cursor: grab;
            transition: none;
            z-index: 1001;
            animation: yellowOrangeGlow 3s ease-in-out infinite alternate;
        }

        #key:active {
            cursor: grabbing;
        }

        #key img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        @keyframes spin {
            0% {
                transform: translate(-50%, -50%) rotate(0deg);
            }
            100% {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }
        
        @keyframes yellowOrangeGlow {
            0% {
                filter: drop-shadow(0 0 15px rgba(255, 165, 0, 0.9)) 
                        drop-shadow(0 0 30px rgba(255, 140, 0, 0.6));
            }
            50% {
                filter: drop-shadow(0 0 25px rgba(255, 165, 0, 1.0)) 
                        drop-shadow(0 0 50px rgba(255, 140, 0, 0.8))
                        drop-shadow(0 0 75px rgba(255, 69, 0, 0.5));
            }
            100% {
                filter: drop-shadow(0 0 20px rgba(255, 165, 0, 0.8)) 
                        drop-shadow(0 0 40px rgba(255, 140, 0, 0.7));
            }
        }

        /* Mobile responsive sizing */
        @media (max-width: 768px) {
            #lock {
                width: 150px;
                height: 150px;
            }
            
            #key {
                width: 185px; /* 264px * 0.7 = 185px (30% smaller) */
                height: 185px; /* 264px * 0.7 = 185px (30% smaller) */
            }
        }

        @media (max-width: 480px) {
            #lock {
                width: 120px;
                height: 120px;
            }
            
            #key {
                width: 158px; /* 226px * 0.7 = 158px (30% smaller) */
                height: 158px; /* 226px * 0.7 = 158px (30% smaller) */
            }
        }

        /* Add styles for viewer videos */
        .viewer-video {
            position: absolute;
            inset: 0;
            margin: auto;
            width: 100%;
            height: 100%;
            opacity: 0;
            object-fit: cover;
            object-position: center;
            will-change: opacity;
        }

        .viewer-video.active {
            opacity: 1;
            /* Full opacity in viewer */
        }

        /* Fullscreen background video styles */
        #fullscreen-background-video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
            z-index: 6;
            /* Above starfield (-1), above cover window (5), below webamp (10) */
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
        }

        #fullscreen-background-video.active {
            opacity: 1;
            pointer-events: auto;
        }

        /* Hide viewer window when in fullscreen mode */
        #viewer-window.fullscreen-mode {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* Hide Legendarium logo behind fullscreen video */
        #legendarium-logo-link.hidden-behind-fullscreen {
            z-index: 0 !important;
            /* Behind fullscreen video (z-index: 1) */
        }

        /* TV off animation for viewer window */
        /* Using the exact same tvTurnOff animation as deity messages */

        /* Adjust positioning for scaled elements */
        @keyframes rotatingShadow {
            0% {
                /* filter: 
                    drop-shadow(-4px 2px 4px rgba(0, 0, 0, 0.95))
                    drop-shadow(-6px 4px 8px rgba(0, 0, 0, 0.85))
                    drop-shadow(-8px 8px 15px rgba(0, 0, 0, 0.75))
                    drop-shadow(-10px 12px 25px rgba(0, 0, 0, 0.65)); */
            }

            25% {
                /* filter: 
                    drop-shadow(0px 4px 4px rgba(0, 0, 0, 0.95))
                    drop-shadow(0px 6px 8px rgba(0, 0, 0, 0.85))
                    drop-shadow(0px 8px 15px rgba(0, 0, 0, 0.75))
                    drop-shadow(0px 12px 25px rgba(0, 0, 0, 0.65)); */
            }

            50% {
                /* filter: 
                    drop-shadow(4px 2px 4px rgba(0, 0, 0, 0.95))
                    drop-shadow(6px 4px 8px rgba(0, 0, 0, 0.85))
                    drop-shadow(8px 8px 15px rgba(0, 0, 0, 0.75))
                    drop-shadow(10px 12px 25px rgba(0, 0, 0, 0.65)); */
            }

            75% {
                /* filter: 
                    drop-shadow(0px -2px 4px rgba(0, 0, 0, 0.95))
                    drop-shadow(0px -4px 8px rgba(0, 0, 0, 0.85))
                    drop-shadow(0px -6px 15px rgba(0, 0, 0, 0.75))
                    drop-shadow(0px -8px 25px rgba(0, 0, 0, 0.65)); */
            }

            100% {
                /* filter: 
                    drop-shadow(-4px 2px 4px rgba(0, 0, 0, 0.95))
                    drop-shadow(-6px 4px 8px rgba(0, 0, 0, 0.85))
                    drop-shadow(-8px 8px 15px rgba(0, 0, 0, 0.75))
                    drop-shadow(-10px 12px 25px rgba(0, 0, 0, 0.65)); */
            }
        }

        /* Add dynamic shadow class that will be controlled by JS */
        #webamp .window.dynamic-shadow {
            transition: filter 0.1s ease-out;
        }

        /* Remove animation toggle button styles */

        /* Deity Message Windows */
        .deity-message-window {
            position: fixed;
            width: 315px;
            /* Scaled down 10% from 350px */
            min-height: 120px;
            background: #000000;
            border: none;
            border-radius: 0;
            font-family: var(--deity-font);
            font-style: var(--deity-font-style);
            font-weight: var(--deity-font-weight);
            letter-spacing: var(--deity-letter-spacing);
            font-size: 16px;
            color: #ffffff;
            z-index: 1001;
            cursor: move;


            filter:
                drop-shadow(-4px 2px 4px rgba(0, 0, 0, 0.95)) drop-shadow(-6px 4px 8px rgba(0, 0, 0, 0.85)) drop-shadow(-8px 8px 15px rgba(0, 0, 0, 0.75)) drop-shadow(-10px 12px 25px rgba(0, 0, 0, 0.65));
            will-change: filter, transform;
            animation: float 8s ease-in-out infinite;
            opacity: 0;
            transform: scale(0.1);
            transition: none;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            backdrop-filter: blur(1px);
        }


        /* Add floating animation to viewer and cover windows */
        /* Viewer animation now handled by .appearing class */

        #cover-window {
            will-change: transform;
            animation: floatCover 8.7s ease-in-out infinite;
        }


        .deity-message-window.appearing {
            animation: tvTurnOn 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards, float 8s ease-in-out infinite 1.2s;
        }

        .deity-message-window.disappearing {
            animation: tvTurnOff 0.8s cubic-bezier(0.55, 0.055, 0.675, 0.19) forwards;
        }

        .deity-message-top {
            width: 100%;
            height: 25px;
            background-image: url('./assets/skins/messagetop.png');
            background-repeat: no-repeat;
            background-size: 100% 100%;
            background-position: center;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            cursor: pointer;
            position: relative;
        }

        .deity-message-top:hover {
            filter: brightness(1.1);
        }

        .deity-close-button {
            position: absolute;
            top: 0;
            right: 0;
            width: 25px;
            height: 25px;
            cursor: pointer;
            z-index: 10;
            /* Invisible but clickable area over the X */
            background: transparent;
        }

        .deity-close-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .deity-message-content {
            background: #000000;
            border-left: 2px dotted rgba(255, 255, 255, 0.8);
            border-right: 2px dotted rgba(255, 255, 255, 0.8);
            padding: 20px 25px;
            line-height: 1.5;
            text-align: center;
            position: relative;
            overflow: hidden;
            min-height: 50px;
            max-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .deity-message-bottom {
            width: 100%;
            height: 2px;
            border-bottom: 2px dotted rgba(255, 255, 255, 0.8);
            background: transparent;
            position: relative;
        }

        .deity-message-bottom::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 0;
            right: 0;
            height: 2px;
            border-bottom: 2px dotted rgba(255, 255, 255, 0.8);
        }

        /* Create double dotted line effect for deity message side borders - matching bottom style */
        .deity-message-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 2px;
            right: 2px;
            bottom: 0;
            border-left: 2px dotted rgba(255, 255, 255, 0.8);
            border-right: 2px dotted rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 1;
        }

        .deity-message-content .scanlines::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                repeating-linear-gradient(0deg,
                    transparent,
                    transparent 3px,
                    rgba(0, 0, 0, 0.05) 4px);
            pointer-events: none;
            z-index: 2;
        }

        .deity-message-content .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .deity-message-content::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background:
                radial-gradient(circle, rgba(255, 255, 255, 0.08) 0%, transparent 70%);
            animation: etherealPulse 12s ease-in-out infinite;
            pointer-events: none;
        }

        .deity-message-text {
            position: relative;
            z-index: 2;
            text-shadow:
                0 0 10px rgba(255, 255, 255, 0.8),
                0 0 20px rgba(255, 255, 255, 0.4),
                0 0 30px rgba(255, 255, 255, 0.2);
            font-style: italic;
            letter-spacing: 0.5px;
            width: 100%;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow: hidden;
            opacity: 0;
            line-height: 1.4;
            display: inline-block;
            text-align: center;
            /* Pixelated/broken text effects */
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            font-variant-ligatures: none;
            text-rendering: geometricPrecision;
            /* Subtle broken/distant feeling */
            filter: contrast(1.1) brightness(0.95);
            /* Slightly irregular character spacing for broken feel */
            word-spacing: 0.1em;
            /* Add subtle pixelated text shadow for depth */
            text-shadow:
                0 0 2px rgba(255, 255, 255, 0.9),
                1px 0 0px rgba(255, 255, 255, 0.7),
                0 1px 0px rgba(255, 255, 255, 0.7),
                0 0 10px rgba(255, 255, 255, 0.6),
                0 0 20px rgba(255, 255, 255, 0.3);
        }

        .deity-message-text.typing {
            opacity: 1;
            animation: textGlow 6s ease-in-out infinite alternate var(--typing-duration), subtleFlicker 3s ease-in-out infinite var(--typing-duration);
        }

        .deity-message-text::after {
            content: '';
            opacity: 0;
        }

        .typing-ellipses {
            position: relative;
            display: inline-block;
            width: 30px;
            height: 1em;
            vertical-align: baseline;
            opacity: 0;
            white-space: nowrap;
            flex-shrink: 0;
        }

        /* Prevent ellipses from being alone on a line */
        .typed-text {
            display: inline;
        }

        /* Keep ellipses with last word using non-breaking space */

        .typing-ellipses.show {
            opacity: 1;
        }

        .typing-ellipses::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            animation: none;
        }

        .typing-ellipses.show::before {
            animation: typingEllipsesFlow 0.8s infinite;
        }

        @keyframes typingEllipsesFlow {

            0%,
            16.66% {
                content: '.';
            }

            33.33%,
            49.99% {
                content: '..';
            }

            66.66%,
            83.32% {
                content: '...';
            }

            100% {
                content: '';
            }
        }

        .deity-message-text::after {
            content: '';
            opacity: 0;
        }

        .deity-message-text.typing::after {
            content: '';
            opacity: 0;
        }

        .typing-ellipses::after {
            content: '';
        }

        .deity-message-window.disappearing .deity-message-content {
            background: radial-gradient(circle at center, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.7), rgba(0, 0, 0, 0.1));
            animation: whiteFlashFill 0.8s cubic-bezier(0.55, 0.055, 0.675, 0.19) forwards;
        }

        @keyframes whiteFlashFill {
            0% {
                background: #000000;
            }

            30% {
                background: radial-gradient(circle at center, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1), rgba(0, 0, 0, 0.8));
            }

            70% {
                background: radial-gradient(circle at center, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.6), rgba(255, 255, 255, 0.2));
            }

            100% {
                background: rgba(255, 255, 255, 0.95);
            }
        }



        /* Static noise effect for TV transitions */
        @keyframes staticNoise {

            0%,
            100% {
                background-position: 0% 0%;
                opacity: 0.1;
            }

            25% {
                background-position: 10% 20%;
                opacity: 0.15;
            }

            50% {
                background-position: -5% 10%;
                opacity: 0.08;
            }

            75% {
                background-position: 15% -10%;
                opacity: 0.12;
            }
        }

        @keyframes tvTurnOn {
            0% {
                opacity: 0;
                transform: scaleY(0.01) scaleX(0.8);
                filter: brightness(15) contrast(8) saturate(0);
            }

            15% {
                opacity: 0.8;
                transform: scaleY(0.01) scaleX(0.8);
                filter: brightness(10) contrast(5) saturate(0.3);
            }

            30% {
                transform: scaleY(0.3) scaleX(0.9);
                filter: brightness(6) contrast(3) saturate(0.7);
            }

            50% {
                transform: scaleY(0.9) scaleX(1.02);
                filter: brightness(2) contrast(2) saturate(1.1);
            }

            70% {
                transform: scaleY(1.05) scaleX(1.01);
                filter: brightness(1.3) contrast(1.3) saturate(1.2);
            }

            85% {
                transform: scaleY(0.98) scaleX(1.005);
                filter: brightness(1.1) contrast(1.1) saturate(1.05);
            }

            100% {
                opacity: 1;
                transform: scaleY(1) scaleX(1);
                filter: brightness(1) contrast(1) saturate(1);
            }
        }

        @keyframes tvTurnOff {
            0% {
                opacity: 1;
                transform: scaleY(1) scaleX(1);
                filter: brightness(1) contrast(1) saturate(1);
            }

            15% {
                transform: scaleY(1.02) scaleX(1.01);
                filter: brightness(1.5) contrast(1.5) saturate(0.9);
            }

            35% {
                transform: scaleY(0.9) scaleX(0.95);
                filter: brightness(3) contrast(3) saturate(0.5);
            }

            55% {
                transform: scaleY(0.3) scaleX(0.85);
                filter: brightness(8) contrast(8) saturate(0.1);
            }

            75% {
                transform: scaleY(0.05) scaleX(0.7);
                filter: brightness(15) contrast(15) saturate(0);
            }

            90% {
                opacity: 0.3;
                transform: scaleY(0.01) scaleX(0.5);
                filter: brightness(20) contrast(20) saturate(0);
            }

            100% {
                opacity: 0;
                transform: scaleY(0) scaleX(0);
                filter: brightness(0) contrast(0) saturate(0);
            }
        }

        @keyframes float-main {

            0%,
            100% {
                transform: translate(0, 0) rotate(0deg);
            }

            20% {
                transform: translate(3px, -4px) rotate(0.8deg);
            }

            40% {
                transform: translate(-2px, -6px) rotate(0.2deg);
            }

            60% {
                transform: translate(-4px, 2px) rotate(-0.5deg);
            }

            80% {
                transform: translate(1px, 4px) rotate(-0.2deg);
            }
        }

        @keyframes float-eq {

            0%,
            100% {
                transform: translate(-2px, 2px) rotate(-0.3deg);
            }

            20% {
                transform: translate(-4px, -2px) rotate(0.5deg);
            }

            40% {
                transform: translate(3px, -4px) rotate(-0.2deg);
            }

            60% {
                transform: translate(2px, 3px) rotate(0.4deg);
            }

            80% {
                transform: translate(-3px, 1px) rotate(-0.6deg);
            }
        }

        @keyframes float-playlist {

            0%,
            100% {
                transform: translate(2px, -3px) rotate(0.4deg);
            }

            20% {
                transform: translate(-3px, -1px) rotate(-0.3deg);
            }

            40% {
                transform: translate(1px, 4px) rotate(0.6deg);
            }

            60% {
                transform: translate(-2px, -4px) rotate(-0.2deg);
            }

            80% {
                transform: translate(3px, 2px) rotate(0.5deg);
            }
        }

        @keyframes floatViewer {

            0%,
            100% {
                transform: translate(0, 0) rotate(0deg);
            }

            25% {
                transform: translate(-3px, -2px) rotate(-0.3deg);
            }

            50% {
                transform: translate(2px, -5px) rotate(0.5deg);
            }

            75% {
                transform: translate(4px, 3px) rotate(-0.2deg);
            }
        }

        /* Mobile version that combines centering with haunted movement */
        @keyframes floatViewerMobile {

            0%,
            100% {
                transform: translate(-50%, -50%) translate(0, 0) rotate(0deg);
            }

            25% {
                transform: translate(-50%, -50%) translate(-3px, -2px) rotate(-0.3deg);
            }

            50% {
                transform: translate(-50%, -50%) translate(2px, -5px) rotate(0.5deg);
            }

            75% {
                transform: translate(-50%, -50%) translate(4px, 3px) rotate(-0.2deg);
            }
        }

        @keyframes floatCover {

            0%,
            100% {
                transform: translate(0, 0) rotate(0deg);
            }

            20% {
                transform: translate(4px, 2px) rotate(0.4deg);
            }

            45% {
                transform: translate(-3px, -3px) rotate(-0.6deg);
            }

            65% {
                transform: translate(-2px, 4px) rotate(0.3deg);
            }

            85% {
                transform: translate(3px, -2px) rotate(-0.2deg);
            }
        }

        @keyframes float {

            0%,
            100% {
                transform: translate(0, 0) rotate(0deg);
            }

            25% {
                transform: translate(2px, -3px) rotate(0.3deg);
            }

            50% {
                transform: translate(-1px, -2px) rotate(-0.2deg);
            }

            75% {
                transform: translate(-2px, 1px) rotate(0.1deg);
            }
        }

        @keyframes textGlow {
            0% {
                text-shadow:
                    0 0 10px rgba(255, 255, 255, 0.8),
                    0 0 20px rgba(255, 255, 255, 0.4),
                    0 0 30px rgba(255, 255, 255, 0.2);
            }

            100% {
                text-shadow:
                    0 0 15px rgba(255, 255, 255, 1),
                    0 0 30px rgba(255, 255, 255, 0.6),
                    0 0 45px rgba(255, 255, 255, 0.3),
                    0 0 60px rgba(255, 255, 255, 0.1);
            }
        }

        @keyframes subtleFlicker {

            0%,
            90%,
            100% {
                opacity: 1;
            }

            93%,
            97% {
                opacity: 0.92;
            }

            95% {
                opacity: 0.98;
            }
        }

        @keyframes etherealPulse {

            0%,
            100% {
                transform: scale(1) rotate(0deg);
                opacity: 0.03;
            }

            33% {
                transform: scale(1.1) rotate(120deg);
                opacity: 0.08;
            }

            66% {
                transform: scale(0.9) rotate(240deg);
                opacity: 0.05;
            }
        }




        #legendarium-logo-link {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
            display: block;
            width: 180px;
            max-width: 180px;
            min-width: 80px;
            height: auto;
            cursor: pointer;
            opacity: 0;
            /* Smooth fade transition for easter egg reveal */
            transition: opacity 2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #legendarium-logo-link.visible {
            opacity: 0.92;
        }

        #legendarium-logo-link:hover {
            opacity: 1;
        }

        #legendarium-logo {
            width: 100%;
            height: auto;
            display: block;
            pointer-events: none;
            will-change: transform;
            filter: drop-shadow(0 2px 8px #000a);
            image-rendering: auto;
            transition: transform 0.3s ease-out;
            /* Add smooth transition */
        }

        /* Add hover state for the link */
        #legendarium-logo-link:hover #legendarium-logo {
            transform: scale(1.15) rotateY(0deg) !important;
            /* Scale up and face forward */
        }

        /* Viewer Window Styles */
        #viewer-window {
            position: fixed;
            top: 10%;
            left: 35%;
            transform: none;
            aspect-ratio: 1/1;
            background: #000000;
            border: none;
            border-radius: 0;
            z-index: 5;
            cursor: move;
            filter: none;
            will-change: transform;
            user-select: none;
            display: flex;
            flex-direction: column;
            max-height: none;
            max-width: none;
            width: 828px;
            height: 828px;
            opacity: 0;
            /* No transition - instant appearance after unlock */
            resize: both;
            overflow: hidden;
        }

        #viewer-window.visible {
            opacity: 1;
            animation: floatViewer 9.5s ease-in-out infinite;
        }

        /* TV animations for viewer window - ONLY for fullscreen transitions */
        #viewer-window.tv-appearing {
            animation: tvTurnOn 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        #viewer-window.tv-disappearing {
            animation: tvTurnOff 0.8s cubic-bezier(0.55, 0.055, 0.675, 0.19) forwards;
        }

        /* TV effects for fullscreen background video during transitions */
        #fullscreen-background-video.tv-appearing {
            animation: tvTurnOn 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        #fullscreen-background-video.tv-disappearing {
            animation: tvTurnOff 0.8s cubic-bezier(0.55, 0.055, 0.675, 0.19) forwards;
        }

        /* Add white flash effect for viewer content during TV off (like deity messages) */
        #viewer-window.tv-disappearing .viewer-content {
            background: radial-gradient(circle at center, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.7), rgba(0, 0, 0, 0.1));
            animation: whiteFlashFill 0.8s cubic-bezier(0.55, 0.055, 0.675, 0.19) forwards;
        }


        /* Add resize handle */
        .viewer-resize-handle {
            position: absolute;
            right: 0;
            bottom: 0;
            width: 15px;
            height: 15px;
            cursor: nwse-resize;
            z-index: 7;
            background: transparent;
        }



        .viewer-resize-handle::after {
            content: "◢";
            position: absolute;
            right: 3px;
            bottom: 1px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 10px;
        }

        .viewer-header {
            width: 100%;
            height: 25px;
            background-image: url('./assets/skins/viewerHeader.png');
            background-repeat: no-repeat;
            background-size: 100% 100%;
            background-position: center;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            cursor: move;
            position: relative;
            flex-shrink: 0;
        }

        .viewer-close-button,
        .viewer-fullscreen-button {
            position: absolute;
            top: 0;
            width: 25px;
            height: 25px;
            cursor: pointer;
            z-index: 10;
            background: transparent;
        }

        .viewer-close-button {
            right: 0;
            /* Position at the right edge */
        }

        .viewer-close-button::after {
            content: "×";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 16px;
        }

        .viewer-fullscreen-button {
            right: 0;
        }

        .viewer-fullscreen-button::after {
            content: "▣";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
        }

        .viewer-close-button:hover,
        .viewer-fullscreen-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .viewer-content {
            flex: 1;
            background: #000000;
            border-left: 2px dotted rgba(255, 255, 255, 0.8);
            border-right: 2px dotted rgba(255, 255, 255, 0.8);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .viewer-loop-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        .viewer-loop {
            position: absolute;
            inset: 0;
            margin: auto;
            width: 100%;
            height: 100%;
            opacity: 0;
            object-fit: cover;
            /* Cover instead of contain to avoid black bars */
            object-position: center;
            will-change: opacity;
            transition: opacity 0.5s ease-in-out;
        }



        .viewer-loop.active {
            opacity: 1;
        }

        .viewer-bottom {
            width: 100%;
            height: 2px;
            border-bottom: 2px dotted rgba(255, 255, 255, 0.8);
            background: transparent;
            position: relative;
            flex-shrink: 0;
        }

        .viewer-bottom::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 0;
            right: 0;
            height: 2px;
            border-bottom: 2px dotted rgba(255, 255, 255, 0.8);
        }

        /* Create double dotted line effect for viewer side borders - matching bottom style */
        .viewer-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 2px;
            right: 2px;
            bottom: 0;
            border-left: 2px dotted rgba(255, 255, 255, 0.8);
            border-right: 2px dotted rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 1;
        }

        .hidden {
            display: none !important;
        }

        /* Cover Window Styles - Keep completely hidden until unlock */
        #cover-window {
            position: fixed;
            transform: none;
            background: #000000;
            border: none;
            border-radius: 0;
            z-index: 5;
            cursor: move;
            filter: none;
            will-change: transform;
            user-select: none;
            flex-direction: column;
            width: 300px;
            height: 333px;
            opacity: 0;
            /* No transition - instant appearance after unlock */
            resize: both;
            overflow: hidden;
            /* Force hidden until unlock sequence */
            display: none !important;
        }

        /* Redundant rule removed - display controlled by unlock sequence */

        #cover-window.visible {
            opacity: 1;
            animation: floatCover 8.7s ease-in-out infinite;
        }

        /* Desktop cover icon - minimized state */
        #cover-window.minimized {
            position: fixed !important;
            top: 20px !important;
            left: 20px !important;
            width: 80px !important;
            height: 80px !important;
            cursor: pointer !important;
            animation: none !important;
            z-index: 3 !important;
            transition: all 0.3s ease-in-out !important;
            /* Don't set opacity here - let unlock sequence control visibility */
        }

        /* Only show opacity when both minimized AND visible */
        #cover-window.minimized.visible {
            opacity: 0.8 !important;
        }

        #cover-window.minimized.visible:hover {
            opacity: 1 !important;
            transform: scale(1.05) !important;
        }

        /* Hide header and bottom when minimized */
        #cover-window.minimized .cover-header,
        #cover-window.minimized .cover-bottom,
        #cover-window.minimized .cover-resize-handle {
            display: none !important;
        }

        /* Only show content when minimized */
        #cover-window.minimized .cover-content {
            flex: 1 !important;
            border: 2px solid rgba(255, 255, 255, 0.6) !important;
            border-radius: 4px !important;
        }

        /* Hide dotted borders when minimized */
        #cover-window.minimized::before {
            display: none !important;
        }

        #cover-window.minimized .cover-content::before {
            display: none !important;
        }

        /* Cover window positioning when not minimized */
        #cover-window:not(.minimized) {
            position: fixed;
            top: 15%;
            right: 5%;
            width: 300px;
            height: 333px;
        }

        .cover-header {
            width: 100%;
            height: 25px;
            background-image: url('./assets/skins/coverHeader.png');
            background-repeat: no-repeat;
            background-size: 100% 100%;
            background-position: center;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            cursor: move;
            position: relative;
            flex-shrink: 0;
        }

        .cover-close-button {
            position: absolute;
            top: 0;
            right: 0;
            width: 25px;
            height: 25px;
            cursor: pointer;
            z-index: 10;
            background: transparent;
        }

        .cover-close-button::after {
            content: "×";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 16px;
        }

        .cover-close-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .cover-content {
            flex: 1;
            background: #000000;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        #cover-window::before {
            content: '';
            position: absolute;
            top: 0;
            left: 2px;
            right: 2px;
            bottom: 0;
            border-left: 2px dotted rgba(255, 255, 255, 0.8);
            border-right: 2px dotted rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 1;
        }

        .cover-image-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #cover-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
            image-rendering: auto;
        }

        .cover-bottom {
            width: 100%;
            height: 2px;
            border-bottom: 2px dotted rgba(255, 255, 255, 0.8);
            background: transparent;
            position: relative;
            flex-shrink: 0;
        }

        .cover-bottom::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 0;
            right: 0;
            height: 2px;
            border-bottom: 2px dotted rgba(255, 255, 255, 0.8);
        }

        .cover-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 2px;
            right: 2px;
            bottom: 0;
            border-left: 2px dotted rgba(255, 255, 255, 0.8);
            border-right: 2px dotted rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 1;
        }


        .cover-resize-handle::after {
            content: "◢";
            position: absolute;
            right: 3px;
            bottom: 1px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 10px;
        }

        /* Album Cover Icon Styles */
        #album-cover-icon {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            cursor: pointer;
            z-index: 100;
            opacity: 0.8;
            transition: opacity 0.3s ease, transform 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 4px;
            overflow: hidden;
            background: #000;
        }

        #album-cover-icon:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        #album-cover-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }


        /* Simplified DVD Screensaver Cover Window Styles */
        #dvd-cover-window {
            position: fixed;
            background: #000000;
            border: none;
            border-radius: 0;
            z-index: 1001;
            filter: none;
            will-change: transform;
            user-select: none;
            display: none; /* Hidden by default */
            flex-direction: column;
            width: 300px;
            height: 318px;
            opacity: 1; /* TV effects handle visibility */
            overflow: hidden;
            pointer-events: auto;
        }

        /* DVD window header */
        #dvd-cover-window .cover-header {
            height: 18px; /* Shorter header */
            border-top: 2px dotted rgba(255, 255, 255, 0.8);
            border-left: 2px dotted rgba(255, 255, 255, 0.8);
            border-right: 2px dotted rgba(255, 255, 255, 0.8);
            border-bottom: 2px dotted rgba(255, 255, 255, 0.8);
        }

        /* DVD window content with proper image scaling */
        #dvd-cover-window .cover-content {
            flex: 1;
            background: #000000;
            border-left: 2px dotted rgba(255, 255, 255, 0.8);
            border-right: 2px dotted rgba(255, 255, 255, 0.8);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        #dvd-cover-window .cover-image-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #dvd-cover-window #dvd-cover-image {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Fill frame completely, crop as needed */
            object-position: center;
            image-rendering: auto;
        }

        /* DVD window bottom border */
        #dvd-cover-window .cover-bottom {
            width: 100%;
            height: 2px;
            border-bottom: 2px dotted rgba(255, 255, 255, 0.8);
            background: transparent;
            position: relative;
            flex-shrink: 0;
        }

        #dvd-cover-window .cover-bottom::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 0;
            right: 0;
            height: 2px;
            border-bottom: 2px dotted rgba(255, 255, 255, 0.8);
        }

        /* Create double dotted line effect for DVD window side borders - matching viewer style */
        #dvd-cover-window::before {
            content: '';
            position: absolute;
            top: 0;
            left: 2px;
            right: 2px;
            bottom: 0;
            border-left: 2px dotted rgba(255, 255, 255, 0.8);
            border-right: 2px dotted rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 1;
        }

        #dvd-cover-window .cover-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 2px;
            right: 2px;
            bottom: 0;
            border-left: 2px dotted rgba(255, 255, 255, 0.8);
            border-right: 2px dotted rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 1;
        }

        #dvd-cover-window.visible {
            /* Visible state - TV effects handle actual visibility */
        }

        /* TV animations for DVD window - higher specificity to override other animations */
        #dvd-cover-window.tv-appearing {
            animation: tvTurnOn 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards !important;
        }

        #dvd-cover-window.tv-disappearing {
            animation: tvTurnOff 0.8s cubic-bezier(0.55, 0.055, 0.675, 0.19) forwards !important;
        }

        /* Add white flash effect for DVD window content during TV off */
        #dvd-cover-window.tv-disappearing .cover-content {
            background: radial-gradient(circle at center, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.7), rgba(0, 0, 0, 0.1));
            animation: whiteFlashFill 0.8s cubic-bezier(0.55, 0.055, 0.675, 0.19) forwards;
        }

        /* Simplified DVD cover window animation */
        #dvd-cover-window.visible {
            animation: floatCoverSubtle 8.7s ease-in-out infinite;
        }

        /* Subtle float animation for DVD window */
        @keyframes floatCoverSubtle {
            0%, 100% {
                filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.1));
            }
            20% {
                filter: drop-shadow(2px 1px 8px rgba(255, 255, 255, 0.15));
            }
            45% {
                filter: drop-shadow(-1px -2px 8px rgba(255, 255, 255, 0.12));
            }
            65% {
                filter: drop-shadow(-1px 2px 8px rgba(255, 255, 255, 0.14));
            }
            85% {
                filter: drop-shadow(2px -1px 8px rgba(255, 255, 255, 0.13));
            }
        }

        /* Mobile-specific deity message styling */
        @media (max-width: 768px) {
            .deity-message-window {
                /* Scale down by 20% from original 315px width */
                width: 252px;
                min-height: 96px; /* Also scale down height proportionally */
                /* Use transform to maintain compatibility with TV effects */
                transform-origin: center center;
                /* Position will be overridden by JavaScript for mobile centering */
            }
            
            .deity-message-content {
                padding: 16px 20px; /* Scale down padding from 20px 25px */
                min-height: 40px;
                max-height: 96px; /* Scale down from 120px */
            }
            
            /* Mobile viewer window scaling - same approach as deity messages */
            #viewer-window {
                /* Scale down to match webamp width, 10% bigger than before */
                width: 302px !important; /* 275px + 10% = 302.5px */
                height: 302px !important;
                /* Keep original transform and animation intact */
                transform-origin: center center;
            }
            
            /* Adjust viewer header for mobile */
            .viewer-header {
                height: 20px; /* Slightly smaller header */
            }
            
        }

        /* Mobile touch optimizations */
        #webamp {
            touch-action: manipulation;
        }

        /* Ensure Webamp controls are touch-friendly */
        #webamp button,
        #webamp .webamp-region button,
        #webamp .window,
        #webamp .title-bar {
            touch-action: manipulation;
        }

        /* Prevent text selection on touch devices for better UX */
        #webamp {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Allow text selection in input fields */
        #webamp input,
        #webamp textarea {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

    </style>
</head>

<body>
    <!-- Starfield Background Canvas -->
    <canvas id="starfield-canvas"></canvas>

    <!-- Fullscreen background video -->
    <video id="fullscreen-background-video" muted loop playsInline autoplay></video>

    <!-- Viewer window for loops -->
    <div id="viewer-window" class="window-draggable">
        <div class="viewer-header">
            <div class="viewer-close-button"></div>
        </div>
        <div class="viewer-content">
            <div class="viewer-loop-container"></div>
        </div>
        <div class="viewer-bottom"></div>
        <div class="viewer-resize-handle"></div>
    </div>

    <!-- Cover window for album art -->
    <div id="cover-window" class="window-draggable">
        <div class="cover-header">
            <div class="cover-close-button"></div>
        </div>
        <div class="cover-content">
            <div class="cover-image-container">
                <img id="cover-image"
                    src="https://res.cloudinary.com/dtwix3ubl/image/upload/v1751300090/gkHourglass8_np2lyy.jpg"
                    alt="Album Cover">
            </div>
        </div>
        <div class="cover-bottom"></div>
        <div class="cover-resize-handle"></div>
    </div>

    <!-- Tiny album cover icon in bottom-left corner -->
    <div id="album-cover-icon">
        <img src="https://res.cloudinary.com/dtwix3ubl/image/upload/v1751300090/gkHourglass8_np2lyy.jpg" alt="Album Cover">
    </div>

    <!-- DVD Screensaver Cover Window -->
    <div id="dvd-cover-window">
        <div class="cover-header">
            <div class="cover-close-button"></div>
        </div>
        <div class="cover-content">
            <div class="cover-image-container">
                <img id="dvd-cover-image"
                    src="https://res.cloudinary.com/dtwix3ubl/image/upload/v1751300090/gkHourglass8_np2lyy.jpg"
                    alt="Album Cover">
            </div>
        </div>
        <div class="cover-bottom"></div>
    </div>

    <!-- Dunes background -->
    <div id="dunes-background"></div>

    <!-- Key unlocking system overlay -->
    <div id="unlock-overlay">
        <div id="lock">
            <img src="./assets/images/Lock.png" alt="Lock" draggable="false">
        </div>
        <div id="key">
            <img src="./assets/images/Key.png" alt="Key" draggable="false">
        </div>
    </div>



    <div id="webamp-container"></div>

    <!-- Load Webamp from CDN -->
    <script src="https://unpkg.com/webamp@1.4.2/built/webamp.bundle.min.js"></script>

    <script>
        // Webamp scaling handled automatically

        // Starfield System
        class StarField {
            constructor() {
                this.canvas = document.getElementById('starfield-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.stars = [];
                this.time = 0;
                this.twinkleSpeedMultiplier = 1.0; // Adjustable twinkle speed
                this.resize();
                this.createStars(800); // 800 stars
                window.addEventListener('resize', () => this.resize());
                requestAnimationFrame((t) => this.animate(t));
            }

            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.centerX = this.width / 2;
                this.centerY = this.height / 2;
            }

            createStars(count) {
                const maxDist = Math.sqrt(Math.pow(this.width / 2, 2) + Math.pow(this.height / 2, 2));

                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const initialDistance = Math.random() * maxDist; // Distribute across screen

                    this.stars.push({
                        angle: angle,
                        size: (Math.random() * 1.5 + 0.375), // 75% of original size
                        speed: Math.random() * 0.5 + 0.1,
                        brightness: Math.random() * 1.8 + 0.6, // Brighter base brightness
                        twinkleSpeed: Math.random() * 2.1 + 0.02, // Individual twinkle speed
                        twinklePhase: Math.random() * Math.PI * 2, // Random starting phase
                        glowPhase: Math.random() < 0.3 ? Math.random() * Math.PI * 2 : undefined, // 30% of stars get random glow
                        x: this.centerX + Math.cos(angle) * initialDistance,
                        y: this.centerY + Math.sin(angle) * initialDistance
                    });
                }
            }

            animate(timestamp) {
                this.time = timestamp * 0.001; // Convert to seconds
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(0, 0, this.width, this.height);

                this.stars.forEach(star => {
                    // Move star
                    star.x += Math.cos(star.angle) * star.speed;
                    star.y += Math.sin(star.angle) * star.speed;

                    // Reset if off screen
                    if (star.x < 0 || star.x > this.width ||
                        star.y < 0 || star.y > this.height) {
                        star.x = this.centerX;
                        star.y = this.centerY;
                        star.angle = Math.random() * Math.PI * 2;
                    }

                    // Draw star
                    let distance = Math.sqrt(
                        Math.pow(star.x - this.centerX, 2) +
                        Math.pow(star.y - this.centerY, 2)
                    );
                    let maxDistance = Math.sqrt(
                        Math.pow(this.width / 2, 2) +
                        Math.pow(this.height / 2, 2)
                    );
                    // Base opacity increases from center to edge
                    let opacity = distance / maxDistance * 1.5; // Increased overall brightness by 50%

                    // Enhanced sparkle effect with much longer dark periods
                    let twinkleBase = Math.sin(this.time * star.twinkleSpeed * this.twinkleSpeedMultiplier * 2 + star.twinklePhase);
                    // Create sparkle effect - stars are mostly dark (0.05) with occasional bright sparkles
                    let twinkle = Math.pow(Math.max(0, twinkleBase * 0.5 + 0.5), 4.5) * 0.95 + 0.05;

                    // Random glow enhancement for some stars
                    let randomGlow = 1.0;
                    if (star.glowPhase !== undefined) {
                        let glowCycle = Math.sin(this.time * 0.3 + star.glowPhase);
                        randomGlow = glowCycle > 0.7 ? 1.0 + (glowCycle - 0.7) * 2.0 : 1.0;
                    }

                    // Combine base opacity with twinkle, brightness, and random glow
                    opacity = Math.min(opacity * star.brightness * twinkle * randomGlow, 1);

                    if (opacity > 0) {
                        // Draw main star with enhanced glow
                        this.ctx.fillStyle = `rgba(255,255,255,${opacity})`;
                        this.ctx.beginPath();
                        this.ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                        this.ctx.fill();

                        // Enhanced glow system with multiple layers
                        if (opacity > 0.3) {
                            // Inner glow
                            this.ctx.globalAlpha = opacity * 0.4;
                            this.ctx.shadowColor = 'rgba(255,255,255,0.8)';
                            this.ctx.shadowBlur = star.size * 3;
                            this.ctx.beginPath();
                            this.ctx.arc(star.x, star.y, star.size * 1.2, 0, Math.PI * 2);
                            this.ctx.fill();

                            // Outer glow for brighter stars
                            if (opacity > 0.6) {
                                this.ctx.globalAlpha = opacity * 0.2;
                                this.ctx.shadowBlur = star.size * 6;
                                this.ctx.beginPath();
                                this.ctx.arc(star.x, star.y, star.size * 2, 0, Math.PI * 2);
                                this.ctx.fill();
                            }

                            // Extra sparkle for very bright stars
                            if (opacity > 0.8 && randomGlow > 1.2) {
                                this.ctx.globalAlpha = (opacity - 0.8) * 0.3;
                                this.ctx.shadowBlur = star.size * 10;
                                this.ctx.shadowColor = 'rgba(200,220,255,0.6)';
                                this.ctx.beginPath();
                                this.ctx.arc(star.x, star.y, star.size * 3, 0, Math.PI * 2);
                                this.ctx.fill();
                            }

                            this.ctx.globalAlpha = 1;
                            this.ctx.shadowBlur = 0;
                        }
                    }
                });

                requestAnimationFrame((t) => this.animate(t));
            }

            destroy() {
                window.removeEventListener('resize', () => this.resize());
            }
        }

        // Initialize starfield
        let starField = null;

        // Global variables
        let webampInstance = null;
        let usesCustomSkin = true;
        let animationId = null;
        let eqIntervalId = null;
        let passwordUnlocked = false;
        let lastKnownPositions = null;

        // Deity Messages System
        let deityMessageSystem = {
            // Song-specific messages based on track names
            songMessages: {
                "Gross Excelations": [
                    "Welcome",
                    "It's been a while"
                ],
                "Two Travelers": [
                    "The journey continues"
                ]
                // Add more tracks and their messages here as needed:
                // "Hibernal Torment": [
                //     "Another message"
                // ],
                // "Rats": [
                //     "Message 1",
                //     "Message 2",
                //     "Message 3"
                // ]
            },
            currentSongName: null,
            currentSongMessages: [],
            currentMessageIndex: 0,
            activeWindows: new Set(),
            nextMessageTimeout: null,
            scheduledTimeouts: [],
            windowCounter: 0,
            trackStartTime: null,
            currentTrackDuration: null,
            messageCount: 0,
            usedMessages: new Set(), // Track used messages to prevent repeats

            init() {
                // Reset used messages on init
                this.usedMessages.clear();
                console.log('Deity message system initialized');
            },

            // Method to reset used messages (useful for new album playthroughs)
            resetUsedMessages() {
                this.usedMessages.clear();
                console.log('Used messages reset - all messages can be shown again');
            },

            onTrackChange(trackDuration, songName) {
                // Reset for new track
                this.trackStartTime = Date.now();
                this.currentTrackDuration = trackDuration || 180; // Default to 3 minutes if unknown
                this.messageCount = 0;
                this.currentMessageIndex = 0;
                this.scheduledTimeouts = []; // Track all scheduled timeouts
                
                // Set current song and get its messages
                this.currentSongName = songName;
                this.currentSongMessages = this.songMessages[songName] || [];
                
                console.log(`Track changed to: ${songName}, Messages available: ${this.currentSongMessages.length}`);

                // Clear existing timeouts
                this.clearAllTimeouts();

                // Only schedule messages if this track has specific messages assigned
                if (this.currentSongMessages && this.currentSongMessages.length > 0) {
                    // Filter out already used messages
                    const availableMessages = this.currentSongMessages.filter(msg => !this.usedMessages.has(msg));
                    
                    if (availableMessages.length > 0) {
                        this.scheduleTrackMessages(availableMessages);
                    } else {
                        console.log(`All messages for "${songName}" have been used - no messages will be shown`);
                    }
                } else {
                    console.log(`No messages defined for song: "${songName}" - no messages will be shown`);
                }
            },

            clearAllTimeouts() {
                // Clear the old single timeout
                if (this.nextMessageTimeout) {
                    clearTimeout(this.nextMessageTimeout);
                    this.nextMessageTimeout = null;
                }
                
                // Clear all scheduled timeouts
                if (this.scheduledTimeouts) {
                    this.scheduledTimeouts.forEach(timeout => clearTimeout(timeout));
                    this.scheduledTimeouts = [];
                }
            },

            scheduleTrackMessages(availableMessages) {
                const totalMessages = availableMessages.length;
                const songDurationMs = this.currentTrackDuration * 1000;
                
                console.log(`Scheduling ${totalMessages} messages over ${Math.round(songDurationMs/1000)}s for "${this.currentSongName}"`);
                
                if (totalMessages === 1) {
                    // Single message - show in middle of track
                    const delay = songDurationMs * 0.4; // 40% into the track
                    const message = availableMessages[0];
                    const timeout = setTimeout(() => {
                        this.showTrackMessage(message);
                    }, delay);
                    this.scheduledTimeouts.push(timeout);
                    console.log(`Single message scheduled for ${Math.round(delay/1000)}s: "${message}"`);
                    return;
                }
                
                // Multiple messages - spread evenly throughout the track
                // Reserve 10% at start and 15% at end of track
                const startReserveMs = songDurationMs * 0.10; // 10% buffer at start
                const endReserveMs = songDurationMs * 0.15;   // 15% buffer at end
                const availableTimeMs = songDurationMs - startReserveMs - endReserveMs;
                
                // Calculate interval between messages
                const interval = availableTimeMs / (totalMessages - 1);
                
                // Schedule each message at evenly spaced intervals
                for (let i = 0; i < totalMessages; i++) {
                    const message = availableMessages[i];
                    
                    // Calculate base delay time
                    const baseDelay = startReserveMs + (interval * i);
                    
                    // Add small random variation (±10% of interval) to feel natural
                    const maxVariation = interval * 0.1;
                    const randomVariation = (Math.random() - 0.5) * maxVariation;
                    const delay = Math.max(startReserveMs, baseDelay + randomVariation);
                    
                    // Schedule the message
                    const timeout = setTimeout(() => {
                        this.showTrackMessage(message);
                    }, delay);
                    
                    this.scheduledTimeouts.push(timeout);
                    console.log(`Message ${i + 1}/${totalMessages} scheduled for ${Math.round(delay/1000)}s: "${message}"`);
                }
            },

            showTrackMessage(message) {
                // Validate that we have a message and it's for the current track
                if (!message || !this.currentSongMessages.includes(message)) {
                    console.log('Invalid message for current track');
                    return;
                }
                
                // Check if message has already been used
                if (this.usedMessages.has(message)) {
                    console.log(`Message "${message}" already used - skipping`);
                    return;
                }

                console.log(`Showing track message: "${message}" for "${this.currentSongName}"`);
                
                // Mark message as used to prevent repeats
                this.usedMessages.add(message);
                
                // Find message index for display purposes
                const messageIndex = this.currentSongMessages.indexOf(message);
                this.displayMessage(message, messageIndex + 1, this.currentSongMessages.length);
            },

            displayMessage(message, messageNumber, totalMessages) {
                // Allow more concurrent messages since we're now controlling timing precisely
                if (this.activeWindows.size >= 3) {
                    console.log('Too many active windows, skipping message');
                    return;
                }

                const messageWindow = this.createMessageWindow(message);
                document.body.appendChild(messageWindow);

                // Position randomly on screen
                this.positionRandomly(messageWindow);

                // Add to active windows
                this.activeWindows.add(messageWindow);

                // Show with TV turn-on effect
                requestAnimationFrame(() => {
                    messageWindow.classList.add('appearing');
                });

                // Start typing animation after TV turn-on effect
                setTimeout(() => {
                    this.startTypingAnimation(messageWindow, message);
                }, 1200);
            },

            createMessageWindow(message) {
                const window = document.createElement('div');
                window.className = 'deity-message-window';
                window.id = `deity-message-${++this.windowCounter}`;

                window.innerHTML = `
                    <div class="deity-message-top">
                        <div class="deity-close-button"></div>
                    </div>
                    <div class="deity-message-content">
                        <div class="scanlines"></div>
                        <div class="deity-message-text"><span class="typing-ellipses"></span></div>
                    </div>
                    <div class="deity-message-bottom"></div>
                `;

                // Make draggable
                this.makeDraggable(window);

                // Add click handler to close button (X area only)
                const closeButton = window.querySelector('.deity-close-button');
                closeButton.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent drag from triggering
                    this.dismissMessage(window);
                });

                return window;
            },

            calculateTypingDuration(message) {
                // Calculate realistic typing duration with variations
                const baseSpeed = 80; // Base milliseconds per character
                const speedVariation = 40; // Variation in speed
                const pauseChance = 0.15; // 15% chance of pause per character
                const avgPauseDuration = 200; // Average pause duration

                let totalDuration = 0;
                for (let i = 0; i < message.length; i++) {
                    // Random typing speed per character
                    const charSpeed = baseSpeed + (Math.random() * speedVariation - speedVariation / 2);
                    totalDuration += charSpeed;

                    // Random pauses (like real typing)
                    if (Math.random() < pauseChance) {
                        totalDuration += avgPauseDuration + (Math.random() * 300);
                    }

                    // Longer pauses after punctuation
                    if (message[i] === ',' || message[i] === ':') {
                        totalDuration += 150 + (Math.random() * 200);
                    }
                }

                return Math.max(2000, totalDuration); // Minimum 2 seconds
            },

            startTypingAnimation(messageWindow, message) {
                const textElement = messageWindow.querySelector('.deity-message-text');
                const ellipsesElement = messageWindow.querySelector('.typing-ellipses');

                // Clear any existing content and set up the structure
                textElement.innerHTML = '<span class="typed-text"></span>&nbsp;<span class="typing-ellipses show"></span>';
                const typedTextSpan = textElement.querySelector('.typed-text');
                const ellipses = textElement.querySelector('.typing-ellipses');

                // Start typing animation
                textElement.classList.add('typing');

                let currentIndex = 0;
                const characters = message.split('');

                const typeNextCharacter = () => {
                    if (currentIndex < characters.length) {
                        const char = characters[currentIndex];

                        // Create individual character span with subtle variations for broken feel
                        const charSpan = document.createElement('span');
                        charSpan.textContent = char;

                        // Add subtle random variations to make text feel more broken/distant
                        const variation = Math.random();
                        if (variation < 0.05) { // 5% chance for slight character variations
                            charSpan.style.opacity = '0.85';
                        } else if (variation < 0.1) { // Another 5% for slight position shift
                            charSpan.style.transform = `translateY(${Math.random() * 0.5 - 0.25}px)`;
                        } else if (variation < 0.15) { // Another 5% for slight scaling
                            charSpan.style.transform = `scale(${0.95 + Math.random() * 0.1})`;
                        }

                        typedTextSpan.appendChild(charSpan);
                        currentIndex++;

                        // Calculate delay for next character
                        let delay = 60 + Math.random() * 40; // Base delay with variation

                        // Random pauses for more broken/stuttering effect
                        if (Math.random() < 0.18) { // Slightly more frequent pauses
                            delay += 200 + Math.random() * 400; // Longer pauses occasionally
                        }

                        // Longer pauses after punctuation
                        if (characters[currentIndex - 1] === ',' || characters[currentIndex - 1] === ':') {
                            delay += 150 + Math.random() * 200;
                        }

                        setTimeout(typeNextCharacter, delay);
                    } else {
                        // Typing completed - schedule dismissal between 0.25-2 seconds from now
                        const readingTime = 250 + Math.random() * 1750; // 0.25-2 seconds after typing completes
                        setTimeout(() => {
                            this.dismissMessage(messageWindow);
                        }, readingTime);

                        // Store reference to ellipses for cleanup in dismissMessage
                        messageWindow.ellipsesElement = ellipses;
                    }
                };

                // Add a longer, randomized pause before typing begins
                // Base delay of 1.2s (current TV turn-on effect) + random delay between 0.8s and 3.2s
                const initialDelay = 1200 + Math.random() * 2400;
                setTimeout(typeNextCharacter, initialDelay);
            },

            positionRandomly(element) {
                const margin = 50;
                const isMobile = window.innerWidth <= 768;
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;

                if (isMobile) {
                    // Mobile: Center horizontally and vertically with slight random offset
                    const elementWidth = 252; // Mobile scaled width
                    const elementHeight = 96; // Mobile scaled height
                    
                    // Base center position
                    const centerX = (screenWidth - elementWidth) / 2;
                    const centerY = (screenHeight - elementHeight) / 2;
                    
                    // Add small random offset (±30px) to avoid overlapping messages
                    const offsetX = (Math.random() - 0.5) * 60; // ±30px
                    const offsetY = (Math.random() - 0.5) * 60; // ±30px
                    
                    const x = Math.max(margin, Math.min(screenWidth - elementWidth - margin, centerX + offsetX));
                    const y = Math.max(margin, Math.min(screenHeight - elementHeight - margin, centerY + offsetY));
                    
                    element.style.left = x + 'px';
                    element.style.top = y + 'px';
                } else {
                    // Desktop: Original right-third positioning
                    const elementWidth = 315;
                    const elementHeight = 120;
                    
                    // Calculate the right third of the screen
                    const rightThirdStart = screenWidth * (2 / 3);
                    const rightThirdWidth = screenWidth * (1 / 3);
                    
                    // Calculate the middle third of the right column (vertically)
                    const middleThirdStart = screenHeight * (1 / 3);
                    const middleThirdHeight = screenHeight * (1 / 3);
                    
                    // Calculate available area within the restricted zone
                    const availableWidth = rightThirdWidth - elementWidth - margin;
                    const availableHeight = middleThirdHeight - elementHeight - margin;
                    
                    // Ensure we have enough space
                    if (availableWidth < 0 || availableHeight < 0) {
                        // Fallback to center of the restricted area if element is too large
                        const x = rightThirdStart + (rightThirdWidth - elementWidth) / 2;
                        const y = middleThirdStart + (middleThirdHeight - elementHeight) / 2;
                        element.style.left = x + 'px';
                        element.style.top = y + 'px';
                    } else {
                        // Random position within the restricted zone
                        const x = rightThirdStart + margin + Math.random() * availableWidth;
                        const y = middleThirdStart + margin + Math.random() * availableHeight;
                        
                        element.style.left = x + 'px';
                        element.style.top = y + 'px';
                    }
                }
            },

            makeDraggable(element) {
                let isDragging = false;
                let startX = 0;
                let startY = 0;
                let startLeft = 0;
                let startTop = 0;

                // Mouse events
                element.addEventListener('mousedown', dragStart, { passive: false });
                document.addEventListener('mousemove', drag, { passive: false });
                document.addEventListener('mouseup', dragEnd, { passive: false });
                
                // Touch events for mobile
                element.addEventListener('touchstart', touchDragStart, { passive: false });
                document.addEventListener('touchmove', touchDrag, { passive: false });
                document.addEventListener('touchend', touchDragEnd, { passive: false });

                function getEventCoords(e) {
                    if (e.touches && e.touches.length > 0) {
                        return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    }
                    return { x: e.clientX, y: e.clientY };
                }

                function dragStart(e) {
                    // Ignore if clicking on close button
                    if (e.target.closest('.deity-close-button')) {
                        return;
                    }

                    e.preventDefault();
                    e.stopPropagation();

                    isDragging = true;
                    const coords = getEventCoords(e);
                    startX = coords.x;
                    startY = coords.y;

                    // Get current position
                    const rect = element.getBoundingClientRect();
                    startLeft = rect.left;
                    startTop = rect.top;

                    element.style.cursor = 'grabbing';
                    element.style.zIndex = '1002'; // Bring to front while dragging
                }

                function touchDragStart(e) {
                    // Ignore if touching close button
                    if (e.target.closest('.deity-close-button')) {
                        return;
                    }

                    // Only handle single touch
                    if (e.touches.length !== 1) return;

                    e.preventDefault();
                    e.stopPropagation();

                    isDragging = true;
                    const coords = getEventCoords(e);
                    startX = coords.x;
                    startY = coords.y;

                    // Get current position
                    const rect = element.getBoundingClientRect();
                    startLeft = rect.left;
                    startTop = rect.top;

                    element.style.zIndex = '1002'; // Bring to front while dragging
                }

                function drag(e) {
                    if (!isDragging) return;

                    e.preventDefault();
                    e.stopPropagation();

                    const coords = getEventCoords(e);
                    const deltaX = coords.x - startX;
                    const deltaY = coords.y - startY;

                    // Allow unrestricted movement
                    const newLeft = startLeft + deltaX;
                    const newTop = startTop + deltaY;

                    element.style.left = newLeft + 'px';
                    element.style.top = newTop + 'px';
                }

                function touchDrag(e) {
                    if (!isDragging) return;

                    // Only handle single touch
                    if (e.touches.length !== 1) return;

                    e.preventDefault();
                    e.stopPropagation();

                    const coords = getEventCoords(e);
                    const deltaX = coords.x - startX;
                    const deltaY = coords.y - startY;

                    // Allow unrestricted movement
                    const newLeft = startLeft + deltaX;
                    const newTop = startTop + deltaY;

                    element.style.left = newLeft + 'px';
                    element.style.top = newTop + 'px';
                }

                function dragEnd(e) {
                    if (!isDragging) return;

                    isDragging = false;
                    element.style.cursor = 'move';
                    element.style.zIndex = '1001'; // Reset z-index
                }

                function touchDragEnd(e) {
                    if (!isDragging) return;

                    isDragging = false;
                    element.style.zIndex = '1001'; // Reset z-index
                }

                // Prevent text selection during drag
                element.addEventListener('selectstart', (e) => {
                    if (isDragging) e.preventDefault();
                });
            },

            dismissMessage(messageWindow) {
                if (!this.activeWindows.has(messageWindow)) return;

                // Stop ellipses animation if it's running
                const ellipses = messageWindow.querySelector('.typing-ellipses');
                if (ellipses) {
                    ellipses.classList.remove('show');
                }

                // Remove from active set
                this.activeWindows.delete(messageWindow);

                // Add disappearing animation
                messageWindow.classList.remove('appearing');
                messageWindow.classList.add('disappearing');

                // Remove from DOM after animation
                setTimeout(() => {
                    if (messageWindow.parentNode) {
                        messageWindow.parentNode.removeChild(messageWindow);
                    }
                }, 800); // Match tvTurnOff animation duration
            },

            cleanup() {
                // Clear any pending timeouts
                if (this.nextMessageTimeout) {
                    clearTimeout(this.nextMessageTimeout);
                    this.nextMessageTimeout = null;
                }
                
                // Clear all scheduled timeouts
                this.clearAllTimeouts();

                // Remove all active windows
                this.activeWindows.forEach(window => {
                    if (window.parentNode) {
                        window.parentNode.removeChild(window);
                    }
                });
                this.activeWindows.clear();

                // Reset song-specific properties
                this.currentSongName = null;
                this.currentSongMessages = [];
                this.currentMessageIndex = 0;
                this.messageCount = 0;
                
                // Reset used messages to allow them to be shown again in a new session
                this.usedMessages.clear();
                
                console.log('Deity message system cleaned up');
            }
        };

        // Remove animation toggle state since it's always on
        const MAIN_WINDOW_HEIGHT = 116;
        const EQ_WINDOW_HEIGHT = 116;

        // Function to convert binary data to base64
        async function fetchAndConvertToBase64(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Failed to fetch ${url}: ${response.status} ${response.statusText}`);
                }
                const blob = await response.blob();
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                console.error('Error fetching skin:', error);
                return null;
            }
        }

        // Function to preload an audio file and get its blob URL
        async function preloadAudioFile(url) {
            try {
                console.log('Preloading audio file:', url);
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout

                const response = await fetch(url, {
                    signal: controller.signal,
                    mode: 'cors'
                });
                clearTimeout(timeoutId);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const blob = await response.blob();
                const blobUrl = URL.createObjectURL(blob);
                console.log('Audio file preloaded successfully');
                return blobUrl;
            } catch (error) {
                console.error('Error preloading audio:', error);
                return url; // Fallback to original URL if fetch fails
            }
        }

        // Function to preload only the first track and video for initial load
        async function preloadFirstTrackOnly() {
            console.log('Preloading first track only...');

            // Clear any existing preloaded tracks to prevent blob URL corruption
            if (window.preloadedTracks) {
                console.log('Clearing existing preloaded tracks to prevent corruption');
                window.preloadedTracks.forEach(track => {
                    if (track.url && track.url.startsWith('blob:')) {
                        URL.revokeObjectURL(track.url);
                    }
                });
                delete window.preloadedTracks;
            }

            try {
                // Preload first audio track
                const firstTrack = tracksData[0];
                let firstTrackBlobUrl;

                try {
                    firstTrackBlobUrl = await preloadAudioFile(firstTrack.url);
                } catch (error) {
                    console.error('Error preloading first audio track:', error);
                    firstTrackBlobUrl = firstTrack.url; // Fallback to original URL
                }

                // Preload first video
                if (trackBackgrounds[0] && !trackBackgrounds[0].preloadedVideo) {
                    try {
                        await preloadVideoOnDemand(0);
                    } catch (error) {
                        console.error('Error preloading first video:', error);
                        // Continue without video
                    }
                }

                // Create tracks array with first track preloaded, others as placeholders
                const tracks = tracksData.map((track, index) => {
                    if (index === 0) {
                        return {
                            ...track,
                            url: firstTrackBlobUrl,
                            blob: firstTrackBlobUrl !== firstTrack.url
                        };
                    } else {
                        return { ...track }; // Keep original URL for now
                    }
                });

                window.preloadedTracks = tracks;
                console.log('First track preloaded successfully');
                return tracks;
            } catch (error) {
                console.error('Error in preloadFirstTrackOnly:', error);
                // Fallback: return tracks with original URLs
                const tracks = tracksData.map(track => ({ ...track }));
                window.preloadedTracks = tracks;
                return tracks;
            }
        }

        // Function to preload remaining tracks in background after password validation
        async function preloadRemainingTracks() {
            console.log('Preloading remaining tracks in background...');

            if (!window.preloadedTracks) return;

            // Preload remaining audio tracks one by one to avoid overwhelming the browser
            const preloadTrack = async (index) => {
                try {
                    const blobUrl = await preloadAudioFile(tracksData[index].url);
                    window.preloadedTracks[index] = {
                        ...tracksData[index],
                        url: blobUrl,
                        blob: true
                    };
                    console.log(`Track ${index + 1} preloaded and ready`);
                } catch (error) {
                    console.error(`Error preloading track ${index + 1}:`, error);
                }
            };

            // Preload tracks in small batches to avoid blocking
            for (let i = 1; i < tracksData.length; i++) {
                setTimeout(() => preloadTrack(i), (i - 1) * 1000); // Stagger by 1 second each
            }

            // Preload remaining videos in batches
            setTimeout(() => {
                console.log('Starting background video preloading...');
                for (let i = 1; i <= 4; i++) {
                    if (trackBackgrounds[i] && !trackBackgrounds[i].preloadedVideo) {
                        preloadVideoOnDemand(i);
                    }
                }
            }, 3000); // Start after 3 seconds

            setTimeout(() => {
                for (let i = 5; i < Object.keys(trackBackgrounds).length; i++) {
                    if (trackBackgrounds[i] && !trackBackgrounds[i].preloadedVideo) {
                        preloadVideoOnDemand(i);
                    }
                }
            }, 8000); // Start after 8 seconds

            console.log('Background preloading initiated');
        }

        // Define the music files with their metadata - exact file names from the directory
        const tracksData = [
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753891932/01_Gross_Excalations_v3.mp3",
                defaultName: "Gross Excelations",
                duration: 68.784,
                metaData: {
                    title: "Gross Excelations"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753891952/02_Two_Travelers_v3.mp3",
                defaultName: "Two Travelers",
                duration: 208.152,
                metaData: {
                    title: "Two Travelers"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753891962/03_Chambers_of_the_Starwatcher_v3.mp3",
                defaultName: "Chambers of the Starwatcher",
                duration: 218.5665,
                metaData: {
                    title: "Chambers of the Starwatcher"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753891972/04_Hibernal_Torment_v3.mp3",
                defaultName: "Hibernal Torment",
                duration: 216,
                metaData: {
                    title: "Hibernal Torment"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753892009/05_Rats_v3.mp3",
                defaultName: "Rats",
                duration: 233.64,
                metaData: {
                    title: "Rats"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753892029/06_Entrusted_to_Fools_v3.mp3",
                defaultName: "Entrusted to Fools",
                duration: 196.008,
                metaData: {
                    title: "Entrusted to Fools"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753892049/07_Heavy_Load_v3.mp3",
                defaultName: "Crusted Aucklet",
                duration: 192,
                metaData: {
                    title: "Crusted Aucklet"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753893189/08_Crusted_Aucklet_v3.mp3",
                defaultName: "Astral Crumb",
                duration: 71.016,
                metaData: {
                    title: "Astral Crumb"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753893209/09_Ill_Wind_v3.mp3",
                defaultName: "Ill Wind",
                duration: 216,
                metaData: {
                    title: "Ill Wind"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753893229/10_Breadmaker_v3.mp3",
                defaultName: "Breadmaker",
                duration: 193.824,
                metaData: {
                    title: "Breadmaker"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753893249/11_Doom_Fruit_v3.mp3",
                defaultName: "Sepulchral Flute",
                duration: 210,
                metaData: {
                    title: "Sepulchral Flute"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753894796/12_Taste_of_my_Chime_v3.mp3",
                defaultName: "Taste of my Chime",
                duration: 138,
                metaData: {
                    title: "Taste of my Chime"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753894816/13_Bone_Window_v3.mp3",
                defaultName: "Bone Window",
                duration: 141.648,
                metaData: {
                    title: "Bone Window"
                }
            }
        ];

        // Background configuration for each track - videos for both background and viewer
        const trackBackgrounds = {
            0: {  // Track 1 - Gross Excelations
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1749153489/01Loop.mp4",
                preloadedVideo: null,
                fadeIn: 10,    // 2 seconds fade in
                fadeOut: 0     // no fade out
            },
            1: {  // Track 2 - Two Travelers
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1749153493/02Loop.mp4",
                preloadedVideo: null,
                fadeIn: 0,   // 1.5 seconds fade in
                fadeOut: 0   // no fade out
            },
            2: {  // Track 3 - Chambers of the Starwatcher
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753886697/social_newagehardcore_The_camera_orbits_spinning_fast_and_smooth_to__3de233b4-aab7-4e61-8365-310146edce3c_1_ejgjy2.mp4",
                preloadedVideo: null,
                fadeIn: 2,     // 2 seconds fade in
                fadeOut: 0   // no fade out
            },
            3: {  // Track 4 - Hibernal Torment
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1757004490/StairsUpdate_ei1iud.mp4",
                preloadedVideo: null,
                fadeIn: 0,     // 1 second fade in
                fadeOut: 0   // no fade out
            },
            4: {  // Track 5 - Rats
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1757004481/HandUpdate_xhowck.mp4",
                preloadedVideo: null,
                fadeIn: 1,     // 1 second fade in
                fadeOut: 0     // no fade out
            },
            5: {  // Track 6 - Entrusted to Fools
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1752626056/05Loop_afjott.mp4",
                preloadedVideo: null,
                fadeIn: 4,     // 2 seconds fade in
                fadeOut: 0     // no fade out
            },
            6: {  // Track 7 - Crusted Aucklet
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1749153521/07Loop.mp4",
                preloadedVideo: null,
                fadeIn: 1.5,     // 1.5 seconds fade in
                fadeOut: 0     // no fade out
            },
            7: {  // Track 8 - Astral Crumb
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1751073675/08Loop_nmgkgh.mp4",
                preloadedVideo: null,
                fadeIn: 4,     // 4 seconds fade in
                fadeOut: 4     // 4 seconds fade out
            },
            8: {  // Track 9 - Ill Wind
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1749153526/09Loop.mp4",
                preloadedVideo: null,
                fadeIn: .5,     // 1.5 seconds fade in
                fadeOut: 0     // no fade out
            },
            9: {  // Track 10 - Breadmaker
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1749267106/10Loop_jcbrof.mp4",
                preloadedVideo: null,
                fadeIn: 4,     // 1 second fade in
                fadeOut: 0     // no fade out
            },
            10: {  // Track 11 - Sepulchral Flute
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1751074687/12Loop_twje5h.mp4",
                preloadedVideo: null,
                fadeIn: 1.5,     // 1.5 seconds fade in
                fadeOut: 0     // no fade out
            },
            11: {  // Track 12 - Taste of my Chime
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1755467433/Fireflies_pzdsfx.mp4",
                preloadedVideo: null,
                fadeIn: 2,     // 2 seconds fade in
                fadeOut: 0     // no fade out
            },
            12: {  // Track 13 - Bone Window
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1752626043/13Loop_jdubb9.mp4",
                preloadedVideo: null,
                fadeIn: 2,     // 2 seconds fade in
                fadeOut: 0     // no fade out
            }
        };

        // Function to set transition duration for an element
        function setTransitionDuration(element, duration) {
            // Remove transitions for instant changes
            element.style.transition = 'none';
        }

        // Function to initialize viewer system
        function initBackgroundSystem() {
            console.log('Initializing viewer system');

            // Make the viewer window draggable
            makeViewerDraggable();

            // Set up viewer buttons
            setupViewerControls();


            // Make the cover window draggable
            makeCoverDraggable();

            // Set up cover window controls
            setupCoverControls();
        }


        // Function to position viewer window for mobile (similar to deity message positioning)
        function positionViewerForMobile(viewerWindow) {
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const elementWidth = 302; // Mobile viewer width (updated to match new size)
            const elementHeight = 302; // Mobile viewer height (updated to match new size)
            
            // Position 35% down from top, centered horizontally
            const x = (screenWidth - elementWidth) / 2;
            const y = screenHeight * 0.35; // 35% down from top
            
            // Set pixel-based positioning (like deity messages)
            viewerWindow.style.left = x + 'px';
            viewerWindow.style.top = y + 'px';
            
            console.log(`Mobile viewer positioned at: ${x}px, ${y}px`);
        }

        // Function to make the viewer window draggable
        function makeViewerDraggable() {
            const viewerWindow = document.getElementById('viewer-window');

            if (!viewerWindow) return;

            let isDragging = false;
            let startX = 0;
            let startY = 0;
            let startLeft = 0;
            let startTop = 0;

            // Use the header as the drag handle
            const dragHandle = viewerWindow.querySelector('.viewer-header');

            if (dragHandle) {
                // Mouse events
                dragHandle.addEventListener('mousedown', dragStart, { passive: false });
                document.addEventListener('mousemove', drag, { passive: false });
                document.addEventListener('mouseup', dragEnd, { passive: false });
                
                // Touch events for mobile
                dragHandle.addEventListener('touchstart', touchDragStart, { passive: false });
                document.addEventListener('touchmove', touchDrag, { passive: false });
                document.addEventListener('touchend', touchDragEnd, { passive: false });
            }

            function getEventCoords(e) {
                if (e.touches && e.touches.length > 0) {
                    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
                return { x: e.clientX, y: e.clientY };
            }

            function dragStart(e) {
                // Ignore if clicking on buttons
                if (e.target.closest('.viewer-close-button')) {
                    return;
                }

                e.preventDefault();
                e.stopPropagation();

                isDragging = true;
                const coords = getEventCoords(e);
                startX = coords.x;
                startY = coords.y;

                // Get current position
                const rect = viewerWindow.getBoundingClientRect();
                startLeft = rect.left;
                startTop = rect.top;

                // Make sure transform is none for proper dragging
                if (viewerWindow.style.transform === 'translate(-50%, -50%)') {
                    viewerWindow.style.transform = 'none';

                    // Center it if first drag after initialization
                    const rect = viewerWindow.getBoundingClientRect();
                    viewerWindow.style.top = `${(window.innerHeight - rect.height) / 2}px`;
                    viewerWindow.style.left = `${(window.innerWidth - rect.width) / 2}px`;
                }

                dragHandle.style.cursor = 'grabbing';
                viewerWindow.style.zIndex = '6'; // Bring to front while dragging
            }

            function touchDragStart(e) {
                // Ignore if touching buttons
                if (e.target.closest('.viewer-close-button')) {
                    return;
                }

                // Only handle single touch
                if (e.touches.length !== 1) return;

                e.preventDefault();
                e.stopPropagation();

                isDragging = true;
                const coords = getEventCoords(e);
                startX = coords.x;
                startY = coords.y;

                // Get current position
                const rect = viewerWindow.getBoundingClientRect();
                startLeft = rect.left;
                startTop = rect.top;

                // Make sure transform is none for proper dragging
                if (viewerWindow.style.transform === 'translate(-50%, -50%)') {
                    viewerWindow.style.transform = 'none';

                    // Center it if first drag after initialization
                    const rect = viewerWindow.getBoundingClientRect();
                    viewerWindow.style.top = `${(window.innerHeight - rect.height) / 2}px`;
                    viewerWindow.style.left = `${(window.innerWidth - rect.width) / 2}px`;
                }

                viewerWindow.style.zIndex = '6'; // Bring to front while dragging
            }

            function drag(e) {
                if (!isDragging) return;

                e.preventDefault();
                e.stopPropagation();

                const coords = getEventCoords(e);
                const deltaX = coords.x - startX;
                const deltaY = coords.y - startY;

                let newLeft = startLeft + deltaX;
                let newTop = startTop + deltaY;

                // Constrain to screen bounds with some flexibility
                const rect = viewerWindow.getBoundingClientRect();
                const elementWidth = rect.width;
                const elementHeight = rect.height;

                // Allow more flexibility - only constrain when completely off-screen
                newLeft = Math.max(-elementWidth + 100, Math.min(window.innerWidth - 50, newLeft));
                newTop = Math.max(-50, Math.min(window.innerHeight - 50, newTop));

                viewerWindow.style.left = newLeft + 'px';
                viewerWindow.style.top = newTop + 'px';
            }

            function touchDrag(e) {
                if (!isDragging) return;

                // Only handle single touch
                if (e.touches.length !== 1) return;

                e.preventDefault();
                e.stopPropagation();

                const coords = getEventCoords(e);
                const deltaX = coords.x - startX;
                const deltaY = coords.y - startY;

                let newLeft = startLeft + deltaX;
                let newTop = startTop + deltaY;

                // Constrain to screen bounds with some flexibility
                const rect = viewerWindow.getBoundingClientRect();
                const elementWidth = rect.width;
                const elementHeight = rect.height;

                // Allow more flexibility - only constrain when completely off-screen
                newLeft = Math.max(-elementWidth + 100, Math.min(window.innerWidth - 50, newLeft));
                newTop = Math.max(-50, Math.min(window.innerHeight - 50, newTop));

                viewerWindow.style.left = newLeft + 'px';
                viewerWindow.style.top = newTop + 'px';
            }

            function dragEnd(e) {
                if (!isDragging) return;

                isDragging = false;
                dragHandle.style.cursor = 'move';
                viewerWindow.style.zIndex = '5'; // Reset z-index
            }

            function touchDragEnd(e) {
                if (!isDragging) return;

                isDragging = false;
                viewerWindow.style.zIndex = '5'; // Reset z-index
            }

            // Prevent text selection during drag
            viewerWindow.addEventListener('selectstart', (e) => {
                if (isDragging) e.preventDefault();
            });
        }

        // Optimized lazy loading function - only preload first video initially
        function preloadBackgroundsLazy() {
            const preloadProgress = {
                total: Object.keys(trackBackgrounds).length,
                loaded: 0,
                failed: 0
            };

            const preloadManager = {
                onProgress: null,
                onComplete: null
            };


            // Load only the first video immediately on desktop, others on demand
            async function preloadFirstVideo() {
                try {
                    const firstBackground = trackBackgrounds[0];
                    if (firstBackground) {
                        const video = document.createElement('video');
                        video.src = firstBackground.url;
                        video.muted = true;
                        video.playsInline = true;
                        video.loop = true;
                        video.preload = 'auto';

                        video.onloadeddata = () => {
                            firstBackground.preloadedVideo = video;
                            preloadProgress.loaded++;
                            console.log('First video preloaded successfully');

                            if (preloadManager.onComplete) {
                                preloadManager.onComplete({
                                    successCount: 1,
                                    total: 1,
                                    failed: 0
                                });
                            }
                        };

                        video.onerror = () => {
                            preloadProgress.failed++;
                            console.error('Error preloading first video');

                            if (preloadManager.onComplete) {
                                preloadManager.onComplete({
                                    successCount: 0,
                                    total: 1,
                                    failed: 1
                                });
                            }
                        };

                        video.load();
                    }
                } catch (error) {
                    console.error('Failed to preload first video:', error);
                }
            }

            // Start loading first video
            preloadFirstVideo();

            return preloadManager;
        }

        // Function to preload a specific video on demand
        function preloadVideoOnDemand(trackIndex) {
            const background = trackBackgrounds[trackIndex];
            if (!background || background.preloadedVideo) {
                return Promise.resolve(background?.preloadedVideo || null);
            }


            return new Promise((resolve) => {
                const video = document.createElement('video');
                video.src = background.url;
                video.muted = true;
                video.playsInline = true;
                video.loop = true;
                video.preload = 'metadata'; // Use metadata instead of auto for faster loading

                const timeout = setTimeout(() => {
                    console.log(`Video preload timeout for track ${trackIndex}`);
                    resolve(null);
                }, 8000); // 8 second timeout

                video.onloadeddata = () => {
                    clearTimeout(timeout);
                    background.preloadedVideo = video;
                    console.log(`On-demand video preloaded: ${trackIndex}`);
                    resolve(video);
                };

                video.onerror = () => {
                    clearTimeout(timeout);
                    console.error(`Error preloading video ${trackIndex}`);
                    resolve(null);
                };

                video.load();
            });
        }

        // Function to preload all background videos (original function for fallback)
        function preloadBackgrounds() {
            const preloadProgress = {
                total: Object.keys(trackBackgrounds).length,
                loaded: 0,
                failed: 0
            };

            // Create a preload manager
            const preloadManager = {
                onProgress: null,
                onComplete: null,
                onError: null
            };

            // Sequential preloading with delay
            async function preloadSequentially() {
                const entries = Object.entries(trackBackgrounds);

                for (const [index, background] of entries) {
                    try {
                        await new Promise((resolve, reject) => {
                            const video = document.createElement('video');
                            video.muted = true;
                            video.playsInline = true;
                            video.loop = true;
                            video.preload = 'auto';

                            // Track loading progress
                            video.addEventListener('progress', () => {
                                if (video.buffered.length > 0) {
                                    const bufferedEnd = video.buffered.end(video.buffered.length - 1);
                                    const duration = video.duration;
                                    if (duration > 0) {
                                        const progress = (bufferedEnd / duration) * 100;
                                        console.log(`Preloading video ${index}: ${progress.toFixed(1)}%`);
                                    }
                                }
                            });

                            video.onloadeddata = () => {
                                background.preloadedVideo = video;
                                preloadProgress.loaded++;
                                console.log(`Successfully preloaded video ${index}: ${background.url}`);

                                if (preloadManager.onProgress) {
                                    preloadManager.onProgress(preloadProgress);
                                }

                                resolve(video);
                            };

                            video.onerror = (error) => {
                                preloadProgress.failed++;
                                console.error(`Error preloading background ${index}:`, error);
                                console.log('Attempted to load:', background.url);

                                if (preloadManager.onProgress) {
                                    preloadManager.onProgress(preloadProgress);
                                }

                                reject(error);
                            };

                            video.src = background.url;
                        });

                        // Add a delay between video loads (1 second)
                        await new Promise(resolve => setTimeout(resolve, 1000));

                    } catch (error) {
                        console.error(`Failed to preload video ${index}:`, error);
                        // Continue with next video even if this one failed
                    }
                }

                // All videos processed
                const successCount = preloadProgress.loaded;
                console.log(`Preload complete. Successfully loaded ${successCount} of ${preloadProgress.total} videos`);

                if (preloadManager.onComplete) {
                    preloadManager.onComplete({
                        successCount,
                        total: preloadProgress.total,
                        failed: preloadProgress.failed
                    });
                }
            }

            // Start sequential preloading
            preloadSequentially();

            return preloadManager;
        }

        // Progressive background loading - load more videos in background (desktop only)
        function startProgressiveLoading() {

            // Load videos 2-5 after a short delay
            setTimeout(() => {
                for (let i = 1; i <= 4; i++) {
                    if (trackBackgrounds[i] && !trackBackgrounds[i].preloadedVideo) {
                        preloadVideoOnDemand(i);
                    }
                }
            }, 2000);

            // Load remaining videos after longer delay
            setTimeout(() => {
                for (let i = 5; i < Object.keys(trackBackgrounds).length; i++) {
                    if (trackBackgrounds[i] && !trackBackgrounds[i].preloadedVideo) {
                        preloadVideoOnDemand(i);
                    }
                }
            }, 5000);
        }

        // Remove duplicate DOMContentLoaded listener - handled in main initialization



        // Modified track change handler with detailed logging
        function handleTrackChange(trackInfo) {
            // Immediately handle track change
            requestAnimationFrame(() => {
                if (!trackInfo) return;

                // Update media session metadata for background playback
                if (window.updateMediaSessionMetadata) {
                    window.updateMediaSessionMetadata(trackInfo);
                }

                // Find the track index by matching the title
                let trackIndex = -1;

                // First try to match by URL if available
                if (trackInfo.url) {
                    trackIndex = tracksData.findIndex(track =>
                        track.url === trackInfo.url ||
                        track.url.endsWith(trackInfo.url)
                    );
                }

                // If URL matching failed, try title matching
                if (trackIndex === -1) {
                    trackIndex = tracksData.findIndex(track => {
                        // Try to match by title from metadata
                        if (trackInfo.metaData?.title && track.metaData?.title === trackInfo.metaData.title) {
                            return true;
                        }

                        // Try to match by defaultName
                        if (trackInfo.defaultName && track.defaultName === trackInfo.defaultName) {
                            return true;
                        }

                        // Try to match by filename
                        const trackFileName = track.url.split('/').pop();
                        const incomingFileName = (trackInfo.url || '').split('/').pop();
                        if (trackFileName === incomingFileName) {
                            return true;
                        }

                        return false;
                    });
                }

                // Get track duration and notify deity message system
                if (trackIndex !== -1) {
                    const trackData = tracksData[trackIndex];
                    const trackDuration = trackData?.duration || 180;
                    const songName = trackData?.metaData?.title || trackData?.defaultName || "Unknown";
                    
                    console.log(`Track change detected: ${songName} (index: ${trackIndex}, duration: ${trackDuration}s)`);
                    deityMessageSystem.onTrackChange(trackDuration, songName);
                    
                    // Notify automatic switching system
                    if (automaticSwitchingSystem) {
                        automaticSwitchingSystem.onTrackChange(trackIndex, trackDuration);
                    }

                    // Check if audio track needs to be loaded on demand
                    if (window.preloadedTracks && window.preloadedTracks[trackIndex] && !window.preloadedTracks[trackIndex].blob) {
                        console.log(`Loading audio for track ${trackIndex + 1} on demand...`);
                        preloadAudioFile(tracksData[trackIndex].url).then(blobUrl => {
                            window.preloadedTracks[trackIndex] = {
                                ...tracksData[trackIndex],
                                url: blobUrl,
                                blob: true
                            };
                            console.log(`Track ${trackIndex + 1} audio loaded on demand`);
                        }).catch(error => {
                            console.error(`Error loading track ${trackIndex + 1} on demand:`, error);
                        });
                    }

                    // Preload video on demand if not already loaded
                    if (trackBackgrounds[trackIndex] && !trackBackgrounds[trackIndex].preloadedVideo) {
                        preloadVideoOnDemand(trackIndex).then(() => {
                            console.log(`Video for track ${trackIndex} loaded on demand`);
                        });
                    }

                    if (trackBackgrounds[trackIndex]) {
                        switchBackground(trackIndex);
                    }
                }
            });
        }

        // Automatic fullscreen switching system (desktop only)
        let automaticSwitchingSystem = {
            isEnabled: false,
            scheduledTimeouts: [],
            currentTrackIndex: -1,
            isUserInteracting: false,
            lastUserInteractionTime: 0,
            
            init() {
                this.isEnabled = true;
                console.log('Automatic viewer switching system initialized');
            },
            
            onTrackChange(trackIndex, trackDuration) {
                if (!this.isEnabled) return;
                
                this.currentTrackIndex = trackIndex;
                this.clearScheduledSwitches();
                
                console.log(`Setting up simple automatic switching for track ${trackIndex} (${Math.round(trackDuration)}s)`);
                
                if (trackIndex === 0) {
                    // First track: dramatic switch at 5 seconds, then every 10-20 seconds starting at 20 seconds
                    console.log('First track: switch at 5s, then every 10-20s starting at 20s');
                    this.scheduleSingleSwitch(5000); // 5 seconds
                    this.scheduleRegularSwitches(20, trackDuration); // Start at 20 seconds
                } else {
                    // Other tracks: just switch every 10-20 seconds starting at 10 seconds
                    this.scheduleRegularSwitches(10, trackDuration); // Start at 10 seconds
                }
            },
            
            scheduleRegularSwitches(startTime, trackDuration) {
                // Simple: switch every 10-20 seconds until track ends
                let currentTime = startTime;
                
                while (currentTime < trackDuration - 5) { // Stop 5 seconds before track ends
                    const interval = 10 + Math.random() * 10; // Random 10-20 seconds
                    currentTime += interval;
                    
                    if (currentTime < trackDuration - 5) {
                        console.log(`Scheduling switch at ${Math.round(currentTime)}s`);
                        this.scheduleSingleSwitch(currentTime * 1000);
                    }
                }
            },
            
            scheduleSingleSwitch(delayMs) {
                const timeout = setTimeout(() => {
                    // Check if user has interacted recently (within last 2 seconds - reduced for more frequent switching)
                    const timeSinceInteraction = Date.now() - this.lastUserInteractionTime;
                    if (timeSinceInteraction < 2000) {
                        console.log('Skipping automatic switch - user recently interacted');
                        return;
                    }
                    
                    // Trigger the automatic switch
                    console.log('Triggering automatic viewer switch');
                    this.triggerAutomaticSwitch();
                }, delayMs);
                
                this.scheduledTimeouts.push(timeout);
            },
            
            triggerAutomaticSwitch() {
                // Use the existing toggleFullscreenMode function
                if (window.toggleFullscreenMode && typeof window.toggleFullscreenMode === 'function') {
                    window.toggleFullscreenMode();
                } else {
                    console.warn('toggleFullscreenMode not available for automatic switching');
                }
            },
            
            onUserInteraction() {
                this.lastUserInteractionTime = Date.now();
            },
            
            clearScheduledSwitches() {
                this.scheduledTimeouts.forEach(timeout => clearTimeout(timeout));
                this.scheduledTimeouts = [];
            },
            
            cleanup() {
                this.clearScheduledSwitches();
                this.isEnabled = false;
            }
        };

        // Set up viewer controls
        function setupViewerControls() {
            const viewerWindow = document.getElementById('viewer-window');
            const closeButton = viewerWindow.querySelector('.viewer-close-button');
            const fullscreenBackgroundVideo = document.getElementById('fullscreen-background-video');

            // Initialize automatic switching system
            automaticSwitchingSystem.init();

            // Close button - hides the viewer normally
            if (closeButton) {
                closeButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    viewerWindow.classList.remove('visible');
                });
            }

            // Double-click functionality for fullscreen toggle
            let isFullscreenMode = false;
            let clickTimeout = null;
            let clickCount = 0;

            function handleViewerDoubleClick(e) {
                // Don't trigger if clicking on buttons or resize handle
                if (e.target.closest('.viewer-close-button') || e.target.closest('.viewer-resize-handle')) {
                    return;
                }

                // Track user interaction for automatic switching system
                automaticSwitchingSystem.onUserInteraction();

                clickCount++;
                
                if (clickCount === 1) {
                    // Start timeout for double-click detection
                    clickTimeout = setTimeout(() => {
                        clickCount = 0;
                    }, 300); // 300ms window for double-click
                } else if (clickCount === 2) {
                    // Double-click detected
                    clearTimeout(clickTimeout);
                    clickCount = 0;
                    
                    toggleFullscreenMode();
                }
            }

            // Make toggleFullscreenMode globally accessible for automatic switching
            window.toggleFullscreenMode = function() {
                if (!isFullscreenMode) {
                    // Enter fullscreen mode
                    enterFullscreenMode();
                } else {
                    // Exit fullscreen mode
                    exitFullscreenMode();
                }
                isFullscreenMode = !isFullscreenMode;
            };
            
            // Local reference for convenience
            const toggleFullscreenMode = window.toggleFullscreenMode;

            function enterFullscreenMode() {
                console.log('Entering fullscreen mode');
                
                // Get current video from viewer window
                const viewerVideo = viewerWindow.querySelector('.viewer-video');
                if (viewerVideo && viewerVideo.src) {
                    // Clone the video source to fullscreen background
                    fullscreenBackgroundVideo.src = viewerVideo.src;
                    fullscreenBackgroundVideo.currentTime = viewerVideo.currentTime;
                    
                    // Activate fullscreen background video with TV turn-on effect
                    fullscreenBackgroundVideo.classList.add('active', 'tv-appearing');
                    fullscreenBackgroundVideo.play().catch(err => {
                        console.error('Fullscreen video play failed:', err);
                    });
                    
                    // Remove TV effect after animation completes
                    setTimeout(() => {
                        fullscreenBackgroundVideo.classList.remove('tv-appearing');
                    }, 1200); // Match tvTurnOn duration
                }
                
                // Hide viewer window with TV turn-off effect
                viewerWindow.classList.add('tv-disappearing');
                
                // After TV turn-off completes, hide it completely
                setTimeout(() => {
                    viewerWindow.classList.add('fullscreen-mode');
                    viewerWindow.classList.remove('tv-disappearing');
                }, 800); // Match tvTurnOff duration
                
                
                // Hide Legendarium logo behind fullscreen video
                const legendariumLogo = document.getElementById('legendarium-logo-link');
                if (legendariumLogo) {
                    legendariumLogo.classList.add('hidden-behind-fullscreen');
                }
            }

            function exitFullscreenMode() {
                console.log('Exiting fullscreen mode');
                
                // Add TV turn-off effect to fullscreen background video
                fullscreenBackgroundVideo.classList.add('tv-disappearing');
                
                // After TV turn-off completes, hide fullscreen background video
                setTimeout(() => {
                    fullscreenBackgroundVideo.classList.remove('active', 'tv-disappearing');
                    fullscreenBackgroundVideo.pause();
                    fullscreenBackgroundVideo.src = '';
                }, 800); // Match tvTurnOff duration
                
                // Show viewer window with TV turn-on effect
                viewerWindow.classList.remove('fullscreen-mode');
                viewerWindow.classList.add('tv-appearing');
                
                // After TV turn-on completes, remove the animation class
                setTimeout(() => {
                    viewerWindow.classList.remove('tv-appearing');
                }, 1200); // Match tvTurnOn duration
                
                
                // Show Legendarium logo again
                const legendariumLogo = document.getElementById('legendarium-logo-link');
                if (legendariumLogo) {
                    legendariumLogo.classList.remove('hidden-behind-fullscreen');
                }
            }

            // Add double-click event listener to viewer window
            viewerWindow.addEventListener('click', handleViewerDoubleClick);
            
            // Add double-click event listener to fullscreen background video for exit
            fullscreenBackgroundVideo.addEventListener('click', handleViewerDoubleClick);


            // Position the viewer window
            requestAnimationFrame(() => {
                // Fixed pixel size and position
                viewerWindow.style.transform = 'none';
                viewerWindow.style.width = '828px';
                viewerWindow.style.height = '828px';
                viewerWindow.style.top = '10%';
                viewerWindow.style.left = '35%';
            });

            // Make the viewer resizable manually in addition to native resize
            const resizeHandle = viewerWindow.querySelector('.viewer-resize-handle');
            if (resizeHandle) {
                let isResizing = false;
                let startX, startY;
                let startWidth, startHeight;

                function getEventCoords(e) {
                    if (e.touches && e.touches.length > 0) {
                        return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    }
                    return { x: e.clientX, y: e.clientY };
                }

                // Mouse events
                resizeHandle.addEventListener('mousedown', resizeStart, { passive: false });
                document.addEventListener('mousemove', handleResize, { passive: false });
                document.addEventListener('mouseup', stopResize, { passive: false });
                
                // Touch events
                resizeHandle.addEventListener('touchstart', touchResizeStart, { passive: false });
                document.addEventListener('touchmove', touchHandleResize, { passive: false });
                document.addEventListener('touchend', touchStopResize, { passive: false });

                function resizeStart(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    isResizing = true;
                    const coords = getEventCoords(e);
                    startX = coords.x;
                    startY = coords.y;

                    // Get the current dimensions
                    const rect = viewerWindow.getBoundingClientRect();
                    startWidth = rect.width;
                    startHeight = rect.height;

                    // When user starts resizing, remove the aspect-ratio constraint
                    viewerWindow.style.aspectRatio = 'unset';
                }

                function touchResizeStart(e) {
                    // Only handle single touch
                    if (e.touches.length !== 1) return;
                    
                    e.preventDefault();
                    e.stopPropagation();

                    isResizing = true;
                    const coords = getEventCoords(e);
                    startX = coords.x;
                    startY = coords.y;

                    // Get the current dimensions
                    const rect = viewerWindow.getBoundingClientRect();
                    startWidth = rect.width;
                    startHeight = rect.height;

                    // When user starts resizing, remove the aspect-ratio constraint
                    viewerWindow.style.aspectRatio = 'unset';
                }

                function handleResize(e) {
                    if (!isResizing) return;

                    const coords = getEventCoords(e);
                    // Calculate new dimensions
                    const newWidth = startWidth + (coords.x - startX);
                    const newHeight = startHeight + (coords.y - startY);

                    // Allow any size, but maintain aspect ratio
                    const size = Math.max(newWidth, newHeight);

                    // Apply new dimensions
                    viewerWindow.style.width = `${size}px`;
                    viewerWindow.style.height = `${size}px`;
                }

                function touchHandleResize(e) {
                    if (!isResizing) return;

                    // Only handle single touch
                    if (e.touches.length !== 1) return;
                    
                    e.preventDefault();
                    e.stopPropagation();

                    const coords = getEventCoords(e);
                    // Calculate new dimensions
                    const newWidth = startWidth + (coords.x - startX);
                    const newHeight = startHeight + (coords.y - startY);

                    // Allow any size, but maintain aspect ratio
                    const size = Math.max(newWidth, newHeight);

                    // Apply new dimensions
                    viewerWindow.style.width = `${size}px`;
                    viewerWindow.style.height = `${size}px`;
                }

                function stopResize() {
                    isResizing = false;
                }

                function touchStopResize() {
                    isResizing = false;
                }
            }
        }

        // Function to make the cover window draggable
        function makeCoverDraggable() {
            const coverWindow = document.getElementById('cover-window');

            if (!coverWindow) return;

            let isDragging = false;
            let startX = 0;
            let startY = 0;
            let startLeft = 0;
            let startTop = 0;

            // Use the header as the drag handle
            const dragHandle = coverWindow.querySelector('.cover-header');

            if (dragHandle) {
                dragHandle.addEventListener('mousedown', dragStart, { passive: false });
                document.addEventListener('mousemove', drag, { passive: false });
                document.addEventListener('mouseup', dragEnd, { passive: false });
            }

            function dragStart(e) {
                // Ignore if clicking on buttons or if minimized
                if (e.target.closest('.cover-close-button') || 
                    coverWindow.classList.contains('minimized')) {
                    return;
                }

                e.preventDefault();
                e.stopPropagation();

                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;

                // Get current position
                const rect = coverWindow.getBoundingClientRect();
                startLeft = rect.left;
                startTop = rect.top;

                dragHandle.style.cursor = 'grabbing';
                coverWindow.style.zIndex = '6'; // Bring to front while dragging
            }

            function drag(e) {
                if (!isDragging) return;

                e.preventDefault();
                e.stopPropagation();

                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;

                let newLeft = startLeft + deltaX;
                let newTop = startTop + deltaY;

                // Constrain to screen bounds with some flexibility
                const rect = coverWindow.getBoundingClientRect();
                const elementWidth = rect.width;
                const elementHeight = rect.height;

                // Allow more flexibility - only constrain when completely off-screen
                newLeft = Math.max(-elementWidth + 100, Math.min(window.innerWidth - 50, newLeft));
                newTop = Math.max(-50, Math.min(window.innerHeight - 50, newTop));

                coverWindow.style.left = newLeft + 'px';
                coverWindow.style.top = newTop + 'px';
            }

            function dragEnd(e) {
                if (!isDragging) return;

                isDragging = false;
                dragHandle.style.cursor = 'move';
                coverWindow.style.zIndex = '5'; // Reset z-index
            }


            // Prevent text selection during drag
            coverWindow.addEventListener('selectstart', (e) => {
                if (isDragging) e.preventDefault();
            });
        }



        // Set up cover window controls
        function setupCoverControls() {
            const coverWindow = document.getElementById('cover-window');
            const closeButton = coverWindow.querySelector('.cover-close-button');
            
            // Initialize cover window state
            // Start as minimized icon but keep hidden until unlock sequence
            coverWindow.classList.add('minimized');
            // Don't add 'visible' class yet - wait for unlock sequence
            
            // Close button functionality
            if (closeButton) {
                closeButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    // Minimize back to icon
                    minimizeCoverWindow();
                });
            }
            
            // Click handler for expanding from minimized state
            coverWindow.addEventListener('click', (e) => {
                // Only respond to clicks when minimized
                if (coverWindow.classList.contains('minimized')) {
                    // Don't expand if clicking close button
                    if (e.target.closest('.cover-close-button')) {
                        return;
                    }
                    expandCoverWindow();
                }
            });
            
            // Desktop minimize/maximize functions
            function minimizeCoverWindow() {
                coverWindow.classList.add('minimized');
                coverWindow.classList.remove('floating');
            }
            
            function expandCoverWindow() {
                coverWindow.classList.remove('minimized');
                coverWindow.classList.add('floating');
                
                // Reset any inline positioning styles that might interfere
                coverWindow.style.removeProperty('left');
                coverWindow.style.removeProperty('right');
                coverWindow.style.removeProperty('bottom');
            }
            
            // Position the cover window
            requestAnimationFrame(() => {
                // Starts minimized, positioning handled by CSS classes
                // No need to set inline styles here
            });
            
            // Make the cover window resizable (when not minimized)
            const resizeHandle = coverWindow.querySelector('.cover-resize-handle');
            if (resizeHandle) {
                let isResizing = false;
                let startX, startY;
                let startWidth, startHeight;
                
                resizeHandle.addEventListener('mousedown', (e) => {
                    // Don't allow resizing when minimized
                    if (coverWindow.classList.contains('minimized')) {
                        return;
                    }
                    
                    e.preventDefault();
                    e.stopPropagation();
                    
                    isResizing = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    
                    // Get the current dimensions
                    const rect = coverWindow.getBoundingClientRect();
                    startWidth = rect.width;
                    startHeight = rect.height;
                    
                    // When user starts resizing, remove the aspect-ratio constraint
                    coverWindow.style.aspectRatio = 'unset';
                    
                    // Add event listeners
                    document.addEventListener('mousemove', handleResize);
                    document.addEventListener('mouseup', stopResize);
                });
                
                function handleResize(e) {
                    if (!isResizing) return;
                    
                    // Calculate new dimensions
                    const newWidth = startWidth + (e.clientX - startX);
                    const newHeight = startHeight + (e.clientY - startY);
                    
                    // Maintain rectangular aspect ratio for cover window (width + 33px = height)
                    // Use the larger dimension to determine the size
                    const size = Math.max(newWidth, newHeight - 33);
                    
                    // Apply minimum size constraints
                    const finalWidth = Math.max(150, size);
                    const finalHeight = finalWidth + 33; // Keep rectangular ratio
                    
                    // Apply new dimensions
                    coverWindow.style.width = `${finalWidth}px`;
                    coverWindow.style.height = `${finalHeight}px`;
                }
                
                function stopResize() {
                    isResizing = false;
                    document.removeEventListener('mousemove', handleResize);
                    document.removeEventListener('mouseup', stopResize);
                }
            }
        }

        // Simplified DVD Screensaver System for Album Cover
        let dvdScreensaverSystem = {
            window: null,
            isActive: false,
            position: { x: 100, y: 100 },
            velocity: { x: 2, y: 1.5 },
            animationId: null,
            
            init() {
                this.window = document.getElementById('dvd-cover-window');
                this.setupAlbumIcon();
                this.setupDVDWindow();
            },
            
            setupAlbumIcon() {
                const albumIcon = document.getElementById('album-cover-icon');
                if (albumIcon) {
                    albumIcon.addEventListener('click', () => {
                        if (this.isActive) {
                            this.hideDVDWindow();
                        } else {
                            this.showDVDWindow();
                        }
                    });
                }
            },
            
            setupDVDWindow() {
                if (!this.window) return;
                
                // Set up close button
                const closeButton = this.window.querySelector('.cover-close-button');
                if (closeButton) {
                    closeButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.hideDVDWindow();
                    });
                }
            },
            
            showDVDWindow() {
                if (!this.window) return;
                
                // Scale for mobile - 40% smaller total (25% + 15% more)
                const isMobile = window.innerWidth <= 768;
                let windowWidth = 300;
                let windowHeight = 318;
                
                if (isMobile) {
                    windowWidth = Math.floor(windowWidth * 0.60); // 40% smaller total
                    windowHeight = Math.floor(windowHeight * 0.60); // 40% smaller total
                    
                    this.window.style.width = windowWidth + 'px';
                    this.window.style.height = windowHeight + 'px';
                }
                
                // Set initial random position within safe boundaries
                const margin = 20;
                this.position.x = margin + Math.random() * (window.innerWidth - windowWidth - margin * 2);
                this.position.y = margin + Math.random() * (window.innerHeight - windowHeight - margin * 2);
                
                // Apply position immediately
                this.window.style.left = this.position.x + 'px';
                this.window.style.top = this.position.y + 'px';
                
                // Show window and start TV turn-on effect
                this.window.style.display = 'flex';
                
                // Clear all animations and classes
                this.window.style.animation = 'none';
                this.window.classList.remove('tv-disappearing', 'visible', 'tv-appearing');
                
                // Force reflow
                void this.window.offsetHeight;
                
                // Apply TV turn-on effect
                this.window.classList.add('tv-appearing');
                
                console.log('Starting DVD screensaver with TV turn-on effect');
                
                // Set consistent velocity - much slower for a relaxed bounce
                this.velocity.x = (Math.random() > 0.5 ? 1 : -1) * 0.5;
                this.velocity.y = (Math.random() > 0.5 ? 1 : -1) * 0.4;
                
                // After TV turn-on effect completes, start bouncing
                setTimeout(() => {
                    console.log('TV turn-on complete, starting bounce animation');
                    this.window.classList.remove('tv-appearing');
                    this.window.classList.add('visible');
                    
                    this.isActive = true;
                    this.startBounceAnimation();
                }, 1200); // Match tvTurnOn duration
            },
            
            hideDVDWindow() {
                if (!this.window) return;
                
                this.isActive = false;
                this.stopBounceAnimation();
                
                // Stop all animations and start TV turn-off effect
                this.window.style.animation = 'none';
                this.window.classList.remove('visible', 'tv-appearing', 'tv-disappearing');
                
                // Force reflow
                void this.window.offsetHeight;
                
                // Apply TV turn-off effect
                this.window.classList.add('tv-disappearing');
                
                console.log('Starting TV turn-off effect');
                
                // After TV turn-off effect completes, hide window
                setTimeout(() => {
                    this.window.classList.remove('tv-disappearing');
                    this.window.style.display = 'none';
                    
                    // Reset size for next time
                    this.window.style.width = '';
                    this.window.style.height = '';
                }, 800); // Match tvTurnOff duration
            },
            
            startBounceAnimation() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                
                const animate = () => {
                    if (!this.isActive) {
                        return; // Stop animation if not active
                    }
                    
                    // Get current window dimensions
                    const rect = this.window.getBoundingClientRect();
                    const windowWidth = rect.width;
                    const windowHeight = rect.height;
                    
                    // Get screen boundaries
                    const screenWidth = window.innerWidth;
                    const screenHeight = window.innerHeight;
                    
                    // Update position
                    this.position.x += this.velocity.x;
                    this.position.y += this.velocity.y;
                    
                    // Bounce off edges - simple and reliable collision detection
                    if (this.position.x <= 0) {
                        this.position.x = 0;
                        this.velocity.x = Math.abs(this.velocity.x); // Always positive after hitting left edge
                    } else if (this.position.x >= screenWidth - windowWidth) {
                        this.position.x = screenWidth - windowWidth;
                        this.velocity.x = -Math.abs(this.velocity.x); // Always negative after hitting right edge
                    }
                    
                    if (this.position.y <= 0) {
                        this.position.y = 0;
                        this.velocity.y = Math.abs(this.velocity.y); // Always positive after hitting top edge
                    } else if (this.position.y >= screenHeight - windowHeight) {
                        this.position.y = screenHeight - windowHeight;
                        this.velocity.y = -Math.abs(this.velocity.y); // Always negative after hitting bottom edge
                    }
                    
                    // Apply position
                    this.window.style.left = Math.round(this.position.x) + 'px';
                    this.window.style.top = Math.round(this.position.y) + 'px';
                    
                    // Continue animation
                    this.animationId = requestAnimationFrame(animate);
                };
                
                // Start the animation
                animate();
            },
            
            stopBounceAnimation() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            },
            
            cleanup() {
                this.isActive = false;
                this.stopBounceAnimation();
            }
        };

        // Function to handle background transitions (now only handles viewer window videos)
        function switchBackground(trackIndex) {
            const viewerContainer = document.querySelector('.viewer-loop-container');
            const backgroundConfig = trackBackgrounds[trackIndex];

            if (!backgroundConfig) {
                console.warn('No background configuration for track index:', trackIndex);
                return;
            }

            console.log(`Switching viewer video for track ${trackIndex}: ${backgroundConfig.url}`);

            // Clear any existing content and timeouts
            if (window.bgTransitionTimeout) {
                clearTimeout(window.bgTransitionTimeout);
            }

            // Handle viewer video (clear version in viewer window)
            if (viewerContainer) {
                // Create new video or use preloaded one
                const newViewerVideo = backgroundConfig.preloadedVideo ?
                    backgroundConfig.preloadedVideo.cloneNode(true) :
                    document.createElement('video');

                if (!backgroundConfig.preloadedVideo) {
                    newViewerVideo.loop = true;
                    newViewerVideo.muted = true;
                    newViewerVideo.playsInline = true;
                    newViewerVideo.autoplay = true;
                    newViewerVideo.src = backgroundConfig.url;
                } else {
                    // Ensure loop property is set even for preloaded videos
                    newViewerVideo.loop = true;
                }

                newViewerVideo.className = 'viewer-video';
                newViewerVideo.style.objectFit = 'cover'; // Ensure cover is applied

                // Set initial state
                newViewerVideo.style.transition = 'none';
                newViewerVideo.style.opacity = '0';

                // Add error handling for video playback
                newViewerVideo.addEventListener('error', (e) => {
                    console.error('Viewer video playback error:', e);
                });

                const handleViewerVideoReady = () => {
                    // Replace viewer content first
                    viewerContainer.innerHTML = '';
                    viewerContainer.appendChild(newViewerVideo);

                    // Force reflow
                    void newViewerVideo.offsetHeight;

                    // Start playing after the video is in the DOM
                    requestAnimationFrame(() => {
                        newViewerVideo.play().catch(err => console.error("Viewer video play failed:", err));

                        // Fade in viewer video
                        newViewerVideo.style.transition = `opacity ${backgroundConfig.fadeIn}s ease-in`;
                        newViewerVideo.style.opacity = '1';

                        // Sync with fullscreen background video if active
                        const fullscreenBackgroundVideo = document.getElementById('fullscreen-background-video');
                        if (fullscreenBackgroundVideo && fullscreenBackgroundVideo.classList.contains('active')) {
                            console.log('Syncing fullscreen background video with new track');
                            fullscreenBackgroundVideo.src = backgroundConfig.url;
                            fullscreenBackgroundVideo.currentTime = newViewerVideo.currentTime;
                            fullscreenBackgroundVideo.play().catch(err => {
                                console.error('Fullscreen background video sync failed:', err);
                            });
                        }
                    });
                };

                // Handle video loading
                if (backgroundConfig.preloadedVideo) {
                    // If we have a preloaded video, use it immediately
                    handleViewerVideoReady();
                } else {
                    // Otherwise wait for the video to load
                    newViewerVideo.onloadeddata = handleViewerVideoReady;
                    newViewerVideo.onerror = (error) => {
                        console.error('Error loading viewer video:', error);
                        console.log('Attempted to load:', backgroundConfig.url);
                    };
                }
            }
        }

        // Function to center windows
        function centerWindows() {
            if (!webampInstance || !webampInstance.store) return;

            const zoomFactor = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--webamp-zoom'));
            // Position windows
            let posX, posY, eqY, playlistY;

            // Stack windows on the left side
            posX = Math.floor((window.innerWidth * 0.08) / zoomFactor); // 8% from left edge
            posY = Math.floor((window.innerHeight * 0.12) / zoomFactor); // 12% from top
            eqY = posY + 116; // EQ window starts right after main window
            playlistY = eqY + 116; // Playlist starts right after EQ window

            // Store these positions for animation reference
            window.lastKnownPositions = {
                main: { x: posX, y: posY },
                equalizer: { x: posX, y: eqY },
                playlist: { x: posX, y: playlistY }
            };

            // Update window positions
            webampInstance.store.dispatch({
                type: 'UPDATE_WINDOW_POSITIONS',
                positions: window.lastKnownPositions,
                absolute: true
            });
        }

        // Function to center Webamp for mobile
        function centerWebampForMobile() {
            if (!webampInstance || !webampInstance.store) return;

            const zoomFactor = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--webamp-zoom'));
            
            // Center the main window horizontally, position near top
            const mainWindowWidth = 275;
            const posX = Math.floor((window.innerWidth - mainWindowWidth * zoomFactor) / 2 / zoomFactor);
            const posY = Math.floor((window.innerHeight * 0.1) / zoomFactor); // 10% from top

            // Only position main window on mobile (EQ and playlist are hidden)
            const mobilePositions = {
                main: { x: posX, y: posY }
            };

            // Update window positions
            webampInstance.store.dispatch({
                type: 'UPDATE_WINDOW_POSITIONS',
                positions: mobilePositions,
                absolute: true
            });
        }

        // Function to get current window positions
        function getCurrentWindowPositions() {
            const state = webampInstance.store.getState();
            const genWindows = state?.windows?.genWindows;

            if (!genWindows) return null;

            // Extract positions from the nested position objects
            const positions = {};
            Object.entries(genWindows).forEach(([windowId, window]) => {
                if (window?.position?.x != null && window?.position?.y != null) {
                    positions[windowId] = {
                        x: Math.round(window.position.x),
                        y: Math.round(window.position.y)
                    };
                }
            });

            return positions;
        }

        // Modified animation function to handle mouse interactions
        function startHauntedAnimation() {

            // Clean up any existing animation
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            // Get initial positions
            const currentPositions = getCurrentWindowPositions();

            if (!currentPositions || Object.keys(currentPositions).length === 0) {
                console.error('Could not get window positions for animation');
                return;
            }

            // Use current positions as base positions
            let basePositions = { ...currentPositions };

            let time = 0;
            // Increase frame rate by increasing animation speed
            const ANIMATION_SPEED = 0.8;  // Slightly faster for more noticeable motion
            // Base radius that will be modified by audio
            const BASE_RADIUS = 4;    // Increased base radius for more noticeable movement
            const MAX_RADIUS = 60;    // Larger maximum radius for more dramatic swirls
            // Adjust the movement speed
            const OSCILLATION_FREQUENCY_MODIFIER = 0.001;  // Slightly faster oscillation

            // Add noise parameters for unpredictability
            const NOISE_AMPLITUDE = 0.15;  // Increased noise for more organic movement
            const NOISE_FREQUENCY = 0.002;  // Much slower noise for smoother transitions

            // Volume response curve parameters
            const VOLUME_THRESHOLD = 0.02;  // Lower threshold to be more responsive
            const VOLUME_POWER = 1.8;      // Gentler power curve for smoother response

            // Add secondary motion parameters
            const SECONDARY_FREQUENCY = 0.0012; // Secondary motion frequency
            const TERTIARY_FREQUENCY = 0.0015;  // Tertiary motion frequency

            // Track mouse interaction state
            let isInteracting = false;
            let lastVolume = 0;
            let volumeSmoothing = 0;
            const SMOOTHING_FACTOR = 0.03; // Even smoother transitions
            const VOLUME_SMOOTHING_FACTOR = 0.08; // Smoother volume changes

            // Add transition tracking
            let currentVolumeLevel = 0;
            let targetVolumeLevel = 0;
            let transitionStartPositions = null;
            let transitionStartTime = 0;
            let lastAnimationOffsets = { x: 0, y: 0 };
            const TRANSITION_DURATION = 800;

            function updateBasePositions() {
                const currentPositions = getCurrentWindowPositions();
                if (currentPositions) {
                    // Subtract current animation offsets to get true base positions
                    Object.entries(currentPositions).forEach(([windowId, pos]) => {
                        if (!basePositions[windowId]) basePositions[windowId] = { x: 0, y: 0 };
                        basePositions[windowId] = {
                            x: pos.x - lastAnimationOffsets.x,
                            y: pos.y - lastAnimationOffsets.y
                        };
                    });
                }
            }

            // Add mouse interaction handlers specifically for Webamp windows
            function setupMouseHandlers() {
                const webampElement = document.getElementById('webamp');
                if (!webampElement) return;

                // Function to check if the event target is a Webamp window or control
                const isWebampWindow = (element) => {
                    if (!element) return false;
                    return element.closest('.window') ||
                        element.closest('.title-bar') ||
                        element.closest('.dragger') ||
                        element.closest('.handle');
                };

                // Handle mousedown only on Webamp windows
                webampElement.addEventListener('mousedown', (e) => {
                    if (isWebampWindow(e.target)) {
                        isInteracting = true;
                        transitionStartPositions = null;
                        updateBasePositions();
                    }
                });

                // Handle mouseup globally to ensure we catch the release
                document.addEventListener('mouseup', () => {
                    if (isInteracting) {
                        isInteracting = false;
                        transitionStartPositions = getCurrentWindowPositions();
                        transitionStartTime = Date.now();
                        updateBasePositions();
                    }
                });

                // Handle mouseleave on the document
                document.addEventListener('mouseleave', () => {
                    if (isInteracting) {
                        isInteracting = false;
                        transitionStartPositions = getCurrentWindowPositions();
                        transitionStartTime = Date.now();
                        updateBasePositions();
                    }
                });
            }

            // Call setup after Webamp is initialized
            setupMouseHandlers();

            function getAudioLevel() {
                // Get the current state from Webamp
                const state = webampInstance.store.getState();
                const media = state?.media;

                if (!media) return 0;

                // Check if we're actually playing
                const isPlaying = media.status === "PLAYING" && !media.waiting;
                if (!isPlaying) {
                    targetVolumeLevel = 0;
                } else {
                    // Get the volume from the state and normalize it
                    const volume = state.media.volume || 0;
                    const normalizedVolume = volume / 100;

                    // Smoothly transition the target volume
                    targetVolumeLevel = normalizedVolume;
                }

                // Smoothly interpolate current volume towards target
                currentVolumeLevel += (targetVolumeLevel - currentVolumeLevel) * VOLUME_SMOOTHING_FACTOR;

                // Apply volume threshold
                let scaledVolume = 0;
                if (currentVolumeLevel > VOLUME_THRESHOLD) {
                    // Scale the volume to the range above threshold, with smooth interpolation
                    const volumeAboveThreshold = (currentVolumeLevel - VOLUME_THRESHOLD) / (1 - VOLUME_THRESHOLD);
                    // Apply gentler power curve with smoothing
                    scaledVolume = Math.pow(volumeAboveThreshold, 2); // Use a gentler power curve
                }

                // Apply very gentle cosine modulation for organic movement
                const baseMovement = Math.abs(Math.cos(time * 0.05)); // Slowed down cosine
                const targetVolume = Math.max(0.1, scaledVolume * (0.8 + 0.2 * baseMovement)); // Ensure minimum movement

                // Apply final smoothing
                volumeSmoothing = volumeSmoothing + (targetVolume - volumeSmoothing) * SMOOTHING_FACTOR;

                // Log values periodically
                if (Math.random() < 0.01) {
                    const baseMovement = Math.abs(Math.cos(time * 0.05)); // Slowed down cosine
                    const targetVolume = Math.max(0.1, scaledVolume * (0.8 + 0.2 * baseMovement)); // Ensure minimum movement

                    // Apply final smoothing
                    volumeSmoothing = volumeSmoothing + (targetVolume - volumeSmoothing) * SMOOTHING_FACTOR;
                }

                return Math.max(0.1, volumeSmoothing); // Ensure minimum return value for base movement
            }

            // Easing function for smooth transitions
            function easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }

            // Function to update shadow based on volume
            function updateShadowEffect(audioLevel) {
                if (!webampInstance) return;

                const windows = document.querySelectorAll('#webamp .window');
                if (!windows.length) return;

                // Remove shadow from Webamp windows
                windows.forEach(window => {
                    window.classList.add('dynamic-shadow');
                    window.style.filter = 'none'; // Remove shadow filter
                });

                // Keep shadow only for deity message windows
                const deityWindows = document.querySelectorAll('.deity-message-window');
                deityWindows.forEach(window => {
                    // Calculate dynamic values for deity windows only
                    const time = Date.now() * 0.001;
                    const rotationSpeed = 0.5 + (audioLevel * 2);
                    const angle = time * rotationSpeed;

                    const baseOffset = 4;
                    const baseBlur = 4;
                    const baseSpread = 8;

                    const intensityMultiplier = 1 + (audioLevel * 3);
                    const spreadMultiplier = 1 + (audioLevel * 4);

                    const xOffset = Math.cos(angle) * baseOffset * intensityMultiplier;
                    const yOffset = Math.sin(angle) * baseOffset * intensityMultiplier;

                    const blur1 = baseBlur * (1 + audioLevel);
                    const blur2 = baseBlur * 2 * (1 + audioLevel);
                    const spread1 = baseSpread * (1 + audioLevel * 2);
                    const spread2 = baseSpread * 2 * (1 + audioLevel * 2);

                    const pulseIntensity = audioLevel * 0.3;
                    const pulse = 1 + Math.sin(time * 4) * pulseIntensity;

                    const shadowFilter = `
                        drop-shadow(${xOffset * pulse}px ${yOffset * pulse}px ${blur1}px rgba(0, 0, 0, 0.95))
                        drop-shadow(${xOffset * 1.5 * pulse}px ${yOffset * 1.5 * pulse}px ${blur2}px rgba(0, 0, 0, 0.85))
                        drop-shadow(${xOffset * 2 * pulse}px ${yOffset * 2 * pulse}px ${spread1}px rgba(0, 0, 0, 0.75))
                        drop-shadow(${xOffset * 2.5 * pulse}px ${yOffset * 2.5 * pulse}px ${spread2}px rgba(0, 0, 0, 0.65))
                    `;

                    window.style.filter = shadowFilter;
                });
            }

            function animate() {

                if (!webampInstance?.store) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                    return;
                }

                // Handle animation and transitions
                if (!isInteracting) {
                    time += ANIMATION_SPEED;

                    // Get current audio level and calculate radius with smooth interpolation
                    const audioLevel = getAudioLevel();

                    // Update the shadow effect
                    updateShadowEffect(audioLevel);

                    // Get current audio level and calculate radius with smooth interpolation
                    const targetRadius = BASE_RADIUS + (audioLevel * MAX_RADIUS);

                    // Create multiple layers of motion
                    const primaryMotion = {
                        x: Math.sin(time * OSCILLATION_FREQUENCY_MODIFIER),
                        y: Math.cos(time * OSCILLATION_FREQUENCY_MODIFIER * 0.9)
                    };

                    const secondaryMotion = {
                        x: Math.sin(time * SECONDARY_FREQUENCY * 1.1) * 0.3,
                        y: Math.cos(time * SECONDARY_FREQUENCY * 0.8) * 0.3
                    };

                    const tertiaryMotion = {
                        x: Math.sin(time * TERTIARY_FREQUENCY * 1.2) * 0.2,
                        y: Math.cos(time * TERTIARY_FREQUENCY * 1.3) * 0.2
                    };

                    // Combine motions with different weights based on audio level
                    const combinedMotion = {
                        x: primaryMotion.x + (secondaryMotion.x + tertiaryMotion.x) * (1 + audioLevel),
                        y: primaryMotion.y + (secondaryMotion.y + tertiaryMotion.y) * (1 + audioLevel)
                    };

                    // Add smooth noise variation
                    const timeScale = 1 + (audioLevel * 0.5);
                    const noiseX = Math.sin(time * NOISE_FREQUENCY * 1.1) * NOISE_AMPLITUDE * (1 + audioLevel * 2);
                    const noiseY = Math.cos(time * NOISE_FREQUENCY * 0.9) * NOISE_AMPLITUDE * (1 + audioLevel * 2);

                    // Calculate final position with smooth easing
                    const easeInOut = (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                    const ease = easeInOut(Math.abs(Math.sin(time * 0.0005)));

                    // Calculate animation offsets
                    const xOffset = (combinedMotion.x * targetRadius * ease + noiseX) * timeScale;
                    const yOffset = (combinedMotion.y * targetRadius * ease + noiseY) * timeScale;

                    // Store last animation offsets
                    lastAnimationOffsets = { x: xOffset, y: yOffset };

                    // Handle transition if we just released the window
                    let transitionProgress = 1;
                    if (transitionStartPositions && Date.now() - transitionStartTime < TRANSITION_DURATION) {
                        transitionProgress = easeOutCubic((Date.now() - transitionStartTime) / TRANSITION_DURATION);
                    } else {
                        transitionStartPositions = null;
                    }

                    // Create new positions object with transition handling
                    const newPositions = {};
                    Object.entries(basePositions).forEach(([windowId, basePos]) => {
                        if (transitionStartPositions && transitionStartPositions[windowId]) {
                            // Interpolate between release position and animated position
                            const startPos = transitionStartPositions[windowId];
                            const animatedPos = {
                                x: basePos.x + xOffset,
                                y: basePos.y + yOffset
                            };
                            newPositions[windowId] = {
                                x: startPos.x + (animatedPos.x - startPos.x) * transitionProgress,
                                y: startPos.y + (animatedPos.y - startPos.y) * transitionProgress
                            };
                        } else {
                            newPositions[windowId] = {
                                x: basePos.x + xOffset,
                                y: basePos.y + yOffset
                            };
                        }
                    });

                    // Update all windows at once
                    webampInstance.store.dispatch({
                        type: 'UPDATE_WINDOW_POSITIONS',
                        positions: newPositions,
                        absolute: true
                    });
                }

                animationId = requestAnimationFrame(animate);
            }

            animationId = requestAnimationFrame(animate);
        }

        // Main function to initialize Webamp
        async function initWebamp() {
            try {
                console.log('Starting Webamp initialization...');

                // Clean up any previous instances
                cleanup();

                // Remove animation toggle button initialization
                window.basePositions = null;

                // Add transition styles
                const styleSheet = document.createElement('style');
                styleSheet.textContent = `
                    #webamp-container {
                        opacity: 0;
                        transition: opacity 1s ease-in-out;
                    }
                    #webamp {
                        zoom: var(--webamp-zoom) !important;
                        -moz-transform: scale(var(--webamp-zoom));
                        -moz-transform-origin: top left;
                    }
                    .webamp-region {
                        transition: all 0.3s ease-out;
                    }
                `;
                document.head.appendChild(styleSheet);

                // Get the custom skin if needed
                let skinOption = undefined;

                if (usesCustomSkin) {
                    try {
                        const skinUrl = "./assets/skins/GKSkin.wsz";
                        const skinBase64 = await fetchAndConvertToBase64(skinUrl);

                        if (skinBase64) {
                            skinOption = {
                                url: `data:application/zip;base64,${skinBase64}`
                            };
                        }
                    } catch (error) {
                        console.error('Error loading custom skin:', error);
                        // Continue without custom skin
                    }
                }

                // Use preloaded tracks if available, otherwise create placeholder tracks
                let tracks;
                if (window.preloadedTracks && window.preloadedTracks.length > 0) {
                    tracks = window.preloadedTracks;
                    console.log('Using preloaded tracks:', tracks.length);
                } else {
                    // Fallback: create tracks with original URLs
                    tracks = tracksData.map(track => ({ ...track }));
                    console.log('Using fallback tracks (preloaded tracks not available or empty)');
                    console.log('window.preloadedTracks:', window.preloadedTracks);
                }

                console.log('Tracks prepared:', tracks.length);



                // Set consistent playlist size
                const initialPlaylistSize = 4.4; // Show 12 tracks

                // Set initial position (can be dragged anywhere later)
                const zoomFactor = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--webamp-zoom'));

                // Window dimensions
                const mainWindowWidth = 275;
                const mainWindowHeight = 116;
                const equalizerHeight = 116;
                const playlistHeaderHeight = 30;
                const trackHeight = 14;
                const playlistHeight = playlistHeaderHeight + (initialPlaylistSize * trackHeight);

                // Position windows on desktop
                let leftPosX, mainPosY, eqPosY, playlistPosY;

                // Stack windows on the left side
                leftPosX = Math.floor((window.innerWidth * 0.08) / zoomFactor);
                mainPosY = Math.floor((window.innerHeight * 0.12) / zoomFactor);
                eqPosY = mainPosY + mainWindowHeight;
                playlistPosY = eqPosY + equalizerHeight;

                // Initialize Webamp with preloaded tracks (matching webamp.org config)
                const webampOptions = {
                    initialTracks: tracks,
                    initialSkin: skinOption,
                    zIndex: 100,
                    enableHotkeys: true,
                    enableMediaSession: true,
                    __initialWindowLayout: {
                        main: { position: { x: leftPosX, y: mainPosY } },
                        equalizer: { position: { x: leftPosX, y: eqPosY } },
                        playlist: {
                            position: { x: leftPosX, y: playlistPosY },
                            size: [0, initialPlaylistSize]
                        }
                    }
                };

                console.log('Initializing Webamp with options:', webampOptions);
                webampInstance = new Webamp(webampOptions);

                console.log('Rendering Webamp...');
                // Render Webamp directly without timeout wrapper
                await webampInstance.renderWhenReady(document.getElementById('webamp-container'));
                console.log('Webamp rendered successfully');

                // Wait for skin to be loaded without timeout
                if (skinOption) {
                    console.log('Waiting for skin to load...');
                    try {
                        await webampInstance.skinIsLoaded();
                        console.log('Skin loaded successfully');
                    } catch (error) {
                        console.error('Skin loading failed:', error);
                        // Continue anyway
                    }
                } else {
                    console.log('No custom skin, skipping skin load wait');
                }

                // Set up AudioContext for mobile autoplay after Webamp is ready
                try {
                    if (window.globalAudioContext && webampInstance) {
                        // Try to use the resumed AudioContext
                        console.log('Attempting to use resumed AudioContext for Webamp');
                        console.log('Global AudioContext state:', window.globalAudioContext.state);
                        
                        // Check if Webamp has its own audioContext property we can override
                        if (webampInstance.media && webampInstance.media.audio) {
                            console.log('Found Webamp media audio element, attempting AudioContext setup');
                            // The resumed AudioContext should already be available for Web Audio API
                        } else {
                            console.log('Webamp media not yet available, AudioContext will be handled by Webamp internally');
                        }
                        
                        console.log('AudioContext setup completed');
                    } else {
                        console.log('No global AudioContext available or Webamp not initialized');
                    }
                } catch (audioError) {
                    console.error('AudioContext setup failed:', audioError);
                }

                // Intercept Redux store to prevent playlist reordering
                const originalDispatch = webampInstance.store.dispatch;
                webampInstance.store.dispatch = (action) => {
                    if (action.type === 'REMOVE_TRACKS' ||
                        action.type === 'ADD_TRACK_FROM_URL' ||
                        action.type === 'SET_MEDIA' ||
                        action.type === 'PLAYLIST_REORDER') {
                        return;
                    }
                    return originalDispatch(action);
                };


                // Don't show the player yet - wait for unlock sequence
                const container = document.getElementById('webamp-container');
                if (container) {
                    // Keep opacity at 0 until unlock sequence shows everything together
                    console.log('Webamp container ready (keeping hidden until unlock)');
                } else {
                    console.error('Webamp container not found');
                }

                // Initialize viewer system
                try {
                    initBackgroundSystem();
                } catch (error) {
                    console.error('Background system initialization failed:', error);
                }

                // Initialize DVD screensaver system
                try {
                    dvdScreensaverSystem.init();
                    console.log('DVD screensaver system initialized');
                } catch (error) {
                    console.error('DVD screensaver system initialization failed:', error);
                }

                // Hide EQ and playlist windows on mobile using Webamp API
                if (window.innerWidth <= 768) {
                    console.log('Mobile detected - attempting to hide EQ and playlist windows');
                    
                    // Add CSS to immediately hide windows and position viewer on mobile
                    const mobileHideStyle = document.createElement('style');
                    mobileHideStyle.textContent = `
                        @media screen and (max-width: 768px) {
                            /* Hide EQ and playlist windows on mobile */
                            #webamp #equalizer-window,
                            #webamp [id*="equalizer"],
                            #webamp #playlist-window,
                            #webamp [id*="playlist"] {
                                display: none !important;
                            }
                            
                            /* Viewer window positioning handled by CSS media queries above */
                            
                            /* Ensure viewer content scales properly */
                            #viewer-window .viewer-content {
                                width: 100% !important;
                                height: 100% !important;
                            }
                            
                            /* Scale viewer videos to fill */
                            #viewer-window .viewer-loop,
                            #viewer-window .viewer-video {
                                width: 100% !important;
                                height: 100% !important;
                                object-fit: cover !important;
                            }
                            
                        }
                    `;
                    document.head.appendChild(mobileHideStyle);
                    
                    console.log('Mobile CSS applied - windows will be hidden by CSS');
                    // Remove the Redux dispatch calls that could interfere with initialization
                }

                // Set up track change handler
                webampInstance.onTrackDidChange(trackInfo => {
                    try {
                        handleTrackChange(trackInfo);
                    } catch (error) {
                        console.error('Track change handler error:', error);
                    }
                });

                // Set up Media Session API for background playback
                try {
                    setupMediaSession();
                } catch (error) {
                    console.error('Media Session setup failed:', error);
                }

                // Center windows
                try {
                    if (window.innerWidth > 768) {
                        centerWindows();
                    } else {
                        // Mobile Webamp positioning
                        centerWebampForMobile();
                    }
                } catch (error) {
                    console.error('Window centering failed:', error);
                }





                // Set playlist size to the specified number of tracks explicitly (desktop only)
                if (window.innerWidth > 768) {
                    setTimeout(() => {
                        if (webampInstance && webampInstance.store) {
                            const playlistSize = initialPlaylistSize;
                            console.log(`Setting playlist size to ${playlistSize} tracks`);
                            webampInstance.store.dispatch({
                                type: 'SET_PLAYLIST_WINDOW_SIZE',
                                size: [0, playlistSize]
                            });
                        }
                    }, 500);

                    // Focus the playlist window to bring it to the foreground (desktop only)
                    setTimeout(() => {
                        if (webampInstance && webampInstance.store) {
                            webampInstance.store.dispatch({
                                type: 'SET_FOCUSED_WINDOW',
                                window: 'playlist'
                            });

                            // Try multiple approaches to set visualizer to oscilloscope
                            // Approach 1: Try TOGGLE_VISUALIZER_STYLE (might cycle between modes)
                            webampInstance.store.dispatch({
                                type: 'TOGGLE_VISUALIZER_STYLE'
                            });
                        }
                    }, 100);

                    // Try another approach after a short delay (desktop only)
                    setTimeout(() => {
                        if (webampInstance && webampInstance.store) {
                            // Approach 2: Try clicking on the visualizer area programmatically
                            const visualizerElement = document.querySelector('#webamp .visualizer');
                            if (visualizerElement) {
                                visualizerElement.click();
                            }
                        }
                    }, 500);
                }



                // Haunted animation disabled in favor of CSS floating animation

                // Let Webamp handle all playlist interactions with default desktop behavior





                // Set the title using direct skin data modification (desktop only)
                if (window.innerWidth > 768) {
                    try {
                        // Access the skin data in the Redux store
                        const state = webampInstance.store.getState();
                        if (state && state.display && state.display.skinGenLetterWidths) {
                            // Directly dispatch an action to update the skinInfo which controls the title
                            webampInstance.store.dispatch({
                                type: "SET_SKIN_DATA",
                                data: {
                                    skinInfo: {
                                        name: "TEST"
                                    }
                                }
                            });

                            // Also try the window info update as backup
                            webampInstance.store.dispatch({
                                type: "UPDATE_WINDOW_INFO",
                                window: "main",
                                info: {
                                    title: "TEST"
                                }
                            });
                        }
                    } catch (e) {
                        console.error("Error setting title:", e);
                    }
                }

                // Clean up blob URLs when Webamp closes
                webampInstance.onWillClose(() => {
                    tracks.forEach(track => {
                        if (track.url.startsWith('blob:')) {
                            URL.revokeObjectURL(track.url);
                        }
                    });
                    cleanup();
                });

                // Removed complex audio analyzer subscription for mobile compatibility



                console.log('Webamp initialization complete');
                return webampInstance;
            } catch (error) {
                console.error("Error initializing Webamp:", error);

                // Try to show something even if Webamp fails
                const container = document.getElementById('webamp-container');
                if (container) {
                    container.innerHTML = `
                        <div style="color: white; padding: 20px; text-align: center; font-family: monospace;">
                            <div style="margin-bottom: 20px;">Audio player failed to load</div>
                            <div style="margin-bottom: 20px;">
                                <button onclick="location.reload()" style="padding: 10px 20px; background: #333; color: white; border: 1px solid #666; cursor: pointer;">
                                    Refresh Page
                                </button>
                            </div>
                            <div style="font-size: 12px; opacity: 0.7;">
                                If this persists, try a different browser or device
                            </div>
                        </div>
                    `;
                    container.style.opacity = '1';
                }

                throw error; // Re-throw to trigger the timeout handler
            }
        }

        // Function to play first track using Webamp API
        function playFirstTrack() {
            if (!webampInstance) {
                console.error("Webamp not initialized");
                return;
            }

            try {
                // Make sure track is selected first
                webampInstance.store.dispatch({
                    type: "SET_CURRENT_TRACK",
                    id: 0
                });

                // Force the play button to be "unpressed" before pressing it again
                webampInstance.store.dispatch({ type: "STOP" });

                // Short delay to ensure track is loaded
                setTimeout(() => {
                    // Try multiple methods to ensure playback starts
                    webampInstance.play();

                    // Also try the direct Redux action
                    webampInstance.store.dispatch({ type: "PLAY" });

                    // Removed complex audio analyzer for mobile compatibility

                    // Update media session for background playback
                    if (window.updateMediaSessionMetadata && tracksData[0]) {
                        window.updateMediaSessionMetadata(tracksData[0]);
                    }
                }, 200);
            } catch (e) {
                console.error("Error playing track:", e);
            }
        }

        // Function to play a specific track by index
        function playTrackByIndex(index) {
            if (!webampInstance) return;

            try {
                // First select the track
                webampInstance.store.dispatch({
                    type: "SET_CURRENT_TRACK",
                    id: index
                });

                // Then play it
                setTimeout(() => {
                    webampInstance.play();
                }, 100);
            } catch (e) {
                console.error("Error playing track:", e);
            }
        }

        // Set up player controls using official Webamp API
        function setupPlayerControls() {
            // Wait a moment to ensure Webamp is fully initialized
            setTimeout(() => {
                if (!webampInstance) return;

                // Use official Webamp API for track changes only
                webampInstance.onTrackDidChange(trackInfo => {
                    handleTrackChange(trackInfo);
                    // Removed complex audio analyzer for mobile compatibility
                });

                // Set up mobile touch interaction for playlist playback
                setupMobileTouchInteraction();
            }, 1000);
        }

        // Set up mobile touch interaction for playlist clicks
        function setupMobileTouchInteraction() {
            if (!webampInstance) return;

            // Function to handle user gesture events for mobile playback
            async function handleUserGesture(trackIndex = null) {
                try {
                    // Resume AudioContext if suspended (required for mobile autoplay)
                    if (webampInstance.audioContext && webampInstance.audioContext.state === 'suspended') {
                        console.log('Resuming AudioContext for mobile playback');
                        await webampInstance.audioContext.resume();
                    }

                    // If a specific track index was provided, select it first
                    if (trackIndex !== null && trackIndex >= 0) {
                        console.log(`Mobile: selecting track ${trackIndex}`);
                        webampInstance.setCurrentTrack(trackIndex);
                    }

                    // Start playback using official API
                    console.log('Mobile: starting playback');
                    webampInstance.play();

                } catch (error) {
                    console.error('Mobile playback gesture error:', error);
                }
            }

            // Listen for clicks/touches on playlist items
            const playlistElement = document.querySelector('#webamp [class*="playlist"]');
            if (playlistElement) {
                // Delegate event listener for playlist track items
                playlistElement.addEventListener('click', (event) => {
                    // Find the closest track element
                    const trackElement = event.target.closest('[class*="track"]');
                    if (trackElement) {
                        // Try to extract track index from the element
                        const trackIndex = extractTrackIndex(trackElement);
                        if (trackIndex !== null) {
                            handleUserGesture(trackIndex);
                        } else {
                            // If we can't determine the track, just try to resume and play
                            handleUserGesture();
                        }
                    }
                }, { passive: false });

                // Also listen for touch events specifically
                playlistElement.addEventListener('touchend', (event) => {
                    const trackElement = event.target.closest('[class*="track"]');
                    if (trackElement) {
                        const trackIndex = extractTrackIndex(trackElement);
                        if (trackIndex !== null) {
                            handleUserGesture(trackIndex);
                        } else {
                            handleUserGesture();
                        }
                    }
                }, { passive: false });
            }

            // Also listen for clicks on main window play button
            const mainWindow = document.querySelector('#webamp [class*="main"]');
            if (mainWindow) {
                mainWindow.addEventListener('click', (event) => {
                    // Check if it's the play button or similar control
                    const playButton = event.target.closest('[class*="play"], [title*="play"], [title*="Play"]');
                    if (playButton) {
                        handleUserGesture();
                    }
                }, { passive: false });
            }

            console.log('Mobile touch interaction setup complete');
        }


        // Helper function to extract track index from playlist elements
        function extractTrackIndex(trackElement) {
            try {
                // Look for data attributes or class names that might contain the index
                const dataIndex = trackElement.dataset.index;
                if (dataIndex !== undefined) {
                    return parseInt(dataIndex, 10);
                }

                // Try to get index from parent playlist container
                const playlist = trackElement.closest('[class*="playlist"]');
                if (playlist) {
                    const trackElements = playlist.querySelectorAll('[class*="track"]');
                    for (let i = 0; i < trackElements.length; i++) {
                        if (trackElements[i] === trackElement) {
                            return i;
                        }
                    }
                }

                return null;
            } catch (error) {
                console.error('Error extracting track index:', error);
                return null;
            }
        }




        // Add cleanup for background transition timeouts
        function cleanup() {
            if (eqIntervalId) {
                clearInterval(eqIntervalId);
                eqIntervalId = null;
            }

            window.eqInitialized = false;

            // Cleanup starfield
            if (starField) {
                starField.destroy();
                starField = null;
            }

            // Cleanup deity messages
            if (deityMessageSystem) {
                deityMessageSystem.cleanup();
            }
            
            // Cleanup automatic switching system
            if (automaticSwitchingSystem) {
                automaticSwitchingSystem.cleanup();
            }

            // Reset viewer window
            const viewerWindow = document.getElementById('viewer-window');
            if (viewerWindow) {
                viewerWindow.classList.remove('visible', 'tv-appearing', 'tv-disappearing', 'fullscreen-mode');
                const viewerContainer = viewerWindow.querySelector('.viewer-loop-container');
                if (viewerContainer) {
                    viewerContainer.innerHTML = '';
                }
            }

            if (webampInstance) {
                try {
                    webampInstance.close();
                } catch (e) { }
                webampInstance = null;
            }

            document.getElementById('webamp-container').innerHTML = '';
        }

        // Function to restart Webamp with a different skin
        async function restartWithDifferentSkin() {
            cleanup();
            usesCustomSkin = !usesCustomSkin;
            initWebamp();
        }

        // Key unlocking system
        function setupKeyUnlockingSystem() {
            const unlockOverlay = document.getElementById('unlock-overlay');
            const lock = document.getElementById('lock');
            const key = document.getElementById('key');
            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };
            let passwordUnlocked = false;
            let safetyTimeoutId = null;
            
            // Safety timeout for mobile devices - if unlock hasn't happened after 30 seconds, force unlock
            const isMobile = window.innerWidth <= 768;
            if (isMobile) {
                console.log('Mobile device detected - setting up 30-second safety timeout');
                safetyTimeoutId = setTimeout(() => {
                    if (!passwordUnlocked) {
                        console.log('Safety timeout triggered - forcing unlock for mobile compatibility');
                        handleUnlock();
                    }
                }, 30000); // 30 seconds
            }

            // Position key randomly on screen (keeping it in outer 50% of screen)
            function positionKeyRandomly() {
                const margin = 100; // Keep key away from edges
                // Final adjusted key sizes
                const keySize = window.innerWidth <= 480 ? 158 : window.innerWidth <= 768 ? 185 : 302;
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                
                // Define center exclusion zone (inner 50% of screen)
                const centerExclusionWidth = screenWidth * 0.5; // Inner 50% width
                const centerExclusionHeight = screenHeight * 0.5; // Inner 50% height
                const centerExclusionLeft = screenWidth * 0.25; // Start at 25% from left
                const centerExclusionTop = screenHeight * 0.25; // Start at 25% from top
                const centerExclusionRight = centerExclusionLeft + centerExclusionWidth;
                const centerExclusionBottom = centerExclusionTop + centerExclusionHeight;
                
                let x, y;
                let attempts = 0;
                const maxAttempts = 50;
                
                do {
                    // Generate random position anywhere on screen (within margins)
                    const maxX = screenWidth - margin - keySize;
                    const maxY = screenHeight - margin - keySize;
                    x = margin + Math.random() * Math.max(0, maxX);
                    y = margin + Math.random() * Math.max(0, maxY);
                    attempts++;
                    
                    // Check if key center would be in center exclusion zone
                    const keyCenterX = x + keySize / 2;
                    const keyCenterY = y + keySize / 2;
                    
                    const isInCenterZone = (keyCenterX >= centerExclusionLeft && 
                                           keyCenterX <= centerExclusionRight &&
                                           keyCenterY >= centerExclusionTop && 
                                           keyCenterY <= centerExclusionBottom);
                    
                    // Accept position if it's outside center zone or we've tried too many times
                    if (!isInCenterZone || attempts >= maxAttempts) {
                        break;
                    }
                } while (true);
                
                key.style.left = x + 'px';
                key.style.top = y + 'px';
                console.log(`Key positioned at (${x}, ${y}), size: ${keySize}px, avoiding center zone`);
            }

            // Calculate angle from key to lock
            function calculateKeyRotation() {
                const lockRect = lock.getBoundingClientRect();
                const keyRect = key.getBoundingClientRect();
                
                const lockCenterX = lockRect.left + lockRect.width / 2;
                const lockCenterY = lockRect.top + lockRect.height / 2;
                const keyCenterX = keyRect.left + keyRect.width / 2;
                const keyCenterY = keyRect.top + keyRect.height / 2;
                
                const deltaX = lockCenterX - keyCenterX;
                const deltaY = lockCenterY - keyCenterY;
                
                const angleRad = Math.atan2(deltaY, deltaX);
                const angleDeg = angleRad * (180 / Math.PI);
                
                return angleDeg;
            }

            // Update key rotation
            function updateKeyRotation() {
                const rotation = calculateKeyRotation();
                key.style.transform = `rotate(${rotation}deg)`;
            }

            // Check if key overlaps with lock - improved for mobile compatibility
            function checkCollision() {
                try {
                    const lockRect = lock.getBoundingClientRect();
                    const keyRect = key.getBoundingClientRect();
                    
                    // Fallback to CSS positioning if getBoundingClientRect fails
                    let lockCenterX, lockCenterY, keyCenterX, keyCenterY;
                    
                    if (lockRect.width === 0 || keyRect.width === 0) {
                        // Fallback: use CSS positioning
                        const lockSize = window.innerWidth <= 480 ? 120 : window.innerWidth <= 768 ? 150 : 180;
                        const keySize = window.innerWidth <= 480 ? 158 : window.innerWidth <= 768 ? 185 : 302;
                        
                        lockCenterX = window.innerWidth / 2;
                        lockCenterY = window.innerHeight / 2;
                        
                        const keyLeft = parseFloat(key.style.left) || 0;
                        const keyTop = parseFloat(key.style.top) || 0;
                        keyCenterX = keyLeft + keySize / 2;
                        keyCenterY = keyTop + keySize / 2;
                    } else {
                        // Normal case: use getBoundingClientRect
                        lockCenterX = lockRect.left + lockRect.width / 2;
                        lockCenterY = lockRect.top + lockRect.height / 2;
                        keyCenterX = keyRect.left + keyRect.width / 2;
                        keyCenterY = keyRect.top + keyRect.height / 2;
                    }
                    
                    const distance = Math.sqrt(
                        Math.pow(lockCenterX - keyCenterX, 2) + 
                        Math.pow(lockCenterY - keyCenterY, 2)
                    );
                    
                    // Mobile-friendly collision threshold - more generous for touch
                    const isMobile = window.innerWidth <= 768;
                    const threshold = isMobile ? 150 : 120; // Larger threshold for mobile
                    
                    console.log(`Collision check: distance=${Math.round(distance)}, threshold=${threshold}, collision=${distance < threshold}`);
                    return distance < threshold;
                } catch (error) {
                    console.error('Error in checkCollision:', error);
                    // Fallback: always return false to prevent hanging
                    return false;
                }
            }

            // Handle unlock sequence
            function handleUnlock() {
                if (passwordUnlocked) return;
                passwordUnlocked = true;
                
                // Clear safety timeout if it exists
                if (safetyTimeoutId) {
                    clearTimeout(safetyTimeoutId);
                    safetyTimeoutId = null;
                }
                
                console.log('Key unlocking sequence started...');
                
                // CRITICAL: Resume AudioContext immediately during user gesture for mobile autoplay
                if (window.AudioContext || window.webkitAudioContext) {
                    try {
                        // Create and store AudioContext globally for mobile autoplay
                        if (!window.globalAudioContext) {
                            window.globalAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                        }
                        // Resume immediately during user interaction
                        if (window.globalAudioContext.state === 'suspended') {
                            window.globalAudioContext.resume().then(() => {
                                console.log('AudioContext resumed for mobile autoplay');
                            }).catch(err => {
                                console.error('Failed to resume AudioContext:', err);
                            });
                        }
                    } catch (error) {
                        console.error('AudioContext setup failed:', error);
                    }
                }
                
                // Transfer glow from key to lock, then hide key and start lock spinning
                lock.classList.add('glowing'); // Add glow to lock
                key.style.opacity = '0'; // Hide key (glow transfers to lock)
                lock.classList.add('spinning'); // Start spinning (now with glow)
                
                // Track when spinning started to ensure at least one full rotation
                const spinStartTime = Date.now();
                const minSpinDuration = 2000; // 2 seconds = one full rotation (matches CSS animation)
                
                // Start dunes sliding animation
                const dunesBackground = document.getElementById('dunes-background');
                if (dunesBackground) {
                    dunesBackground.classList.add('slide-out');
                }
                
                // Initialize Webamp and wait for both completion AND minimum spin time
                console.log('Starting Webamp initialization...');
                console.log('Mobile device detected:', window.innerWidth <= 768);
                
                const webampPromise = initWebamp().then((instance) => {
                    console.log('Webamp initialized successfully', instance ? 'with instance' : 'without instance');
                    
                    // Start background preloading AFTER the site is shown
                    setTimeout(() => {
                        console.log('Starting background preloading...');
                        preloadRemainingTracks();
                    }, 2000);
                    
                    return instance;
                }).catch((error) => {
                    console.error('Webamp initialization failed:', error);
                    console.error('Error stack:', error.stack);
                    // Continue anyway to prevent hanging
                    return null;
                });
                
                // Create the minimum spin duration promise
                const spinDurationPromise = new Promise(resolve => {
                    const elapsed = Date.now() - spinStartTime;
                    const remaining = Math.max(0, minSpinDuration - elapsed);
                    console.log(`Spin duration: ${elapsed}ms elapsed, ${remaining}ms remaining`);
                    setTimeout(() => {
                        console.log('Minimum spin duration completed');
                        resolve();
                    }, remaining);
                });
                
                // Wait for both Webamp initialization AND minimum spin duration
                console.log('Waiting for both Webamp init and spin duration...');
                Promise.all([webampPromise, spinDurationPromise]).then((results) => {
                    console.log('Both Webamp and minimum spin duration completed - stopping spinner');
                    console.log('Webamp instance result:', results[0] ? 'success' : 'null/failed');
                    continueAfterUnlock();
                }).catch((error) => {
                    console.error('Promise.all failed during unlock:', error);
                    console.log('Attempting to continue anyway...');
                    continueAfterUnlock();
                });

                function continueAfterUnlock() {
                    console.log('continueAfterUnlock() called');

                    // Get current lock rotation before stopping animation to preserve it for TV turn-off
                    const lockStyle = getComputedStyle(lock);
                    const transform = lockStyle.transform;
                    
                    // Stop lock spinning and remove glow, but preserve final rotation
                    lock.classList.remove('spinning');
                    lock.classList.remove('glowing');
                    if (transform && transform !== 'none') {
                        lock.style.transform = transform; // Keep whatever rotation it ended at
                    }
                    
                    console.log('Starting TV turn-off effect...');
                    
                    // Apply TV turn off effect to overlay
                    unlockOverlay.classList.add('tv-turn-off');
                    unlockOverlay.style.pointerEvents = 'none';
                    
                    // Hide dunes background immediately
                    const dunesBackground = document.getElementById('dunes-background');
                    if (dunesBackground) {
                        dunesBackground.style.display = 'none';
                    }
                    
                    // Ensure starfield stays in background
                    const starfieldCanvas = document.getElementById('starfield-canvas');
                    if (starfieldCanvas) {
                        starfieldCanvas.style.zIndex = '-1';
                    }
                    
                    // Debug: Check visibility state right now
                    const webampContainer = document.getElementById('webamp-container');
                    const coverWindow = document.getElementById('cover-window');
                    const viewerWindow = document.getElementById('viewer-window');
                    console.log('TV off start - Element visibility check:');
                    console.log('- webamp-container opacity:', webampContainer?.style.opacity || getComputedStyle(webampContainer)?.opacity);
                    console.log('- cover-window opacity:', coverWindow?.style.opacity || getComputedStyle(coverWindow)?.opacity);
                    console.log('- cover-window classes:', coverWindow?.className);
                    console.log('- viewer-window opacity:', viewerWindow?.style.opacity || getComputedStyle(viewerWindow)?.opacity);
                    console.log('- viewer-window classes:', viewerWindow?.className);

                    // Wait for TV turn-off effect to complete (1.2s), then show everything at once
                    setTimeout(() => {
                        console.log('TV off complete - showing all elements');

                        // Show webamp-container
                        const webampContainer = document.getElementById('webamp-container');
                        if (webampContainer) {
                            webampContainer.style.opacity = '1';
                        }

                        // Show viewer window with TV turn-on effect
                        const viewerWindow = document.getElementById('viewer-window');
                        if (viewerWindow) {
                            // Position first (before TV effect)
                            if (window.innerWidth <= 768) {
                                positionViewerForMobile(viewerWindow);
                            }
                            
                            // Start with TV turn-on effect
                            viewerWindow.classList.add('tv-appearing');
                            
                            // After TV turn-on completes, add visible class and remove tv effect
                            setTimeout(() => {
                                viewerWindow.classList.remove('tv-appearing');
                                viewerWindow.classList.add('visible');
                                
                                // Show logo as easter egg 1 second after viewer powers on
                                setTimeout(() => {
                                    const logoLink = document.getElementById('legendarium-logo-link');
                                    if (logoLink) {
                                        logoLink.classList.add('visible');
                                        if (!window.legendariumLogoAnimStarted) {
                                            window.legendariumLogoAnimStarted = true;
                                            startLegendariumLogoAnimation();
                                        }
                                    }
                                }, 1000); // 1 second after viewer is fully on
                            }, 1200); // Match tvTurnOn duration
                        }

                        // Show cover window/icon (desktop: minimized icon, mobile: hidden)
                        const coverWindow = document.getElementById('cover-window');
                        if (coverWindow) {
                            if (window.innerWidth <= 768) {
                                coverWindow.style.display = 'none'; // Hidden on mobile
                            } else {
                                coverWindow.style.display = 'flex'; // Show as minimized icon on desktop
                                coverWindow.classList.add('visible');
                            }
                        }

                        // Logo will be shown later as easter egg after viewer powers on

                        // Start everything immediately - no more delays
                        try {
                            switchBackground(0);
                            if (webampInstance) {
                                playFirstTrack();
                            }
                        } catch (error) {
                            console.error('Error starting playback:', error);
                        }

                        // Start deity messages after standard delay
                        setTimeout(() => {
                            try {
                                deityMessageSystem.init();
                            } catch (error) {
                                console.error('Error initializing deity messages:', error);
                            }
                        }, 5000);

                        console.log('Post-unlock initialization complete');
                    }, 1200); // Match tvTurnOff animation duration exactly
                }
            }

            // Mouse/touch event handlers
            function handleStart(e) {
                if (passwordUnlocked) return;
                
                isDragging = true;
                const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                const clientY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
                const keyRect = key.getBoundingClientRect();
                
                dragOffset.x = clientX - keyRect.left;
                dragOffset.y = clientY - keyRect.top;
                
                key.style.transition = 'none';
                e.preventDefault();
            }

            function handleMove(e) {
                if (!isDragging || passwordUnlocked) return;
                
                // Ensure we have touch data for mobile
                let clientX, clientY;
                if (e.type.includes('touch')) {
                    if (!e.touches || e.touches.length === 0) {
                        console.log('Touch move event but no touches data');
                        return;
                    }
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                const newX = clientX - dragOffset.x;
                const newY = clientY - dragOffset.y;
                
                // Keep key within bounds (final adjusted sizes)
                const keySize = window.innerWidth <= 480 ? 158 : window.innerWidth <= 768 ? 185 : 302;
                const boundedX = Math.max(0, Math.min(newX, window.innerWidth - keySize));
                const boundedY = Math.max(0, Math.min(newY, window.innerHeight - keySize));
                
                key.style.left = boundedX + 'px';
                key.style.top = boundedY + 'px';
                
                updateKeyRotation();
                
                // Check collision immediately for both desktop and mobile
                if (checkCollision()) {
                    handleUnlock();
                }
                
                e.preventDefault();
            }

            function handleEnd(e) {
                if (!isDragging) return;
                
                isDragging = false;
                key.style.transition = 'transform 0.1s ease';
                e.preventDefault();
            }

            // Set up event listeners
            key.addEventListener('mousedown', handleStart);
            key.addEventListener('touchstart', handleStart, { passive: false });
            
            document.addEventListener('mousemove', handleMove);
            document.addEventListener('touchmove', handleMove, { passive: false });
            
            document.addEventListener('mouseup', handleEnd);
            document.addEventListener('touchend', handleEnd);

            // Initialize system
            positionKeyRandomly();
            updateKeyRotation();
            
            // Update rotation on window resize
            window.addEventListener('resize', () => {
                setTimeout(() => {
                    updateKeyRotation();
                }, 100);
            });
        }

        // Media Session API for background playback
        function setupMediaSession() {
            if (!('mediaSession' in navigator)) {
                console.log('Media Session API not supported');
                return;
            }

            console.log('Setting up Media Session API for background playback');

            // Set up media session metadata
            function updateMediaSessionMetadata(trackInfo) {
                if (!trackInfo) return;

                const metadata = {
                    title: trackInfo.metaData?.title || trackInfo.defaultName || 'Unknown Track',
                    artist: 'GATEKEEPER',
                    album: 'HIBERNAL TORMENT',
                    artwork: [
                        {
                            src: 'https://res.cloudinary.com/dtwix3ubl/image/upload/v1751300090/gkHourglass8_np2lyy.jpg',
                            sizes: '512x512',
                            type: 'image/jpeg'
                        }
                    ]
                };

                navigator.mediaSession.metadata = new MediaMetadata(metadata);
                console.log('Media session metadata updated:', metadata.title);
            }

            // Set up standard action handlers
            navigator.mediaSession.setActionHandler('play', () => {
                console.log('Media session: play');
                if (webampInstance) {
                    webampInstance.play();
                }
            });

            navigator.mediaSession.setActionHandler('pause', () => {
                console.log('Media session: pause');
                if (webampInstance) {
                    webampInstance.pause();
                }
            });

            navigator.mediaSession.setActionHandler('previoustrack', () => {
                console.log('Media session: previous track');
                if (webampInstance) {
                    webampInstance.previousTrack();
                }
            });

            navigator.mediaSession.setActionHandler('nexttrack', () => {
                console.log('Media session: next track');
                if (webampInstance) {
                    webampInstance.nextTrack();
                }
            });


            // Store the update function for use in track changes
            window.updateMediaSessionMetadata = updateMediaSessionMetadata;

            // Set initial metadata if we have track info
            const state = webampInstance?.store?.getState();
            const currentTrack = state?.playlist?.currentTrack;
            if (currentTrack !== null && tracksData[currentTrack]) {
                updateMediaSessionMetadata(tracksData[currentTrack]);
            }
        }

        // Audio analyzer setup
        async function setupAudioAnalyzer() {
            try {
                // Check if we already have an analyzer set up
                if (webampInstance.analyzer) {
                    return;
                }
                
                // Create audio context and analyzer only if they don't exist
                if (!webampInstance.audioContext) {
                    webampInstance.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                if (!webampInstance.analyzer) {
                    webampInstance.analyzer = webampInstance.audioContext.createAnalyser();
                    webampInstance.analyzer.fftSize = 256;
                    webampInstance.audioData = new Uint8Array(webampInstance.analyzer.frequencyBinCount);
                }

                // Function to connect audio
                const connectAudio = () => {
                    return new Promise((resolve, reject) => {
                        // Get Webamp's media element
                        const state = webampInstance.store.getState();
                        const media = state?.media;

                        if (!media) {
                            reject(new Error('No media state available'));
                            return;
                        }

                        // Get the actual audio element from Webamp
                        const audioElement = document.querySelector('#webamp audio');
                        if (!audioElement) {
                            reject(new Error('Audio element not found'));
                            return;
                        }

                        try {
                            // Create and connect the source only if it doesn't exist
                            if (!webampInstance.source) {
                                webampInstance.source = webampInstance.audioContext.createMediaElementSource(audioElement);
                            }

                            // Connect the nodes
                            webampInstance.source.connect(webampInstance.analyzer);
                            webampInstance.analyzer.connect(webampInstance.audioContext.destination);

                            resolve(true);
                        } catch (e) {
                            console.error('Error connecting audio:', e);
                            reject(e);
                        }
                    });
                };

                // Try to connect with standard retry logic
                let retries = 0;
                const maxRetries = 5;
                const tryConnect = async () => {
                    try {
                        await connectAudio();
                    } catch (e) {
                        if (retries < maxRetries) {
                            retries++;
                            const delay = Math.min(1000 * Math.pow(2, retries), 15000);
                            setTimeout(tryConnect, delay);
                        }
                    }
                };

                // Resume audio context if it's suspended
                if (webampInstance.audioContext.state === 'suspended') {
                    console.log('Resuming suspended audio context');
                    await webampInstance.audioContext.resume();
                }

                // Start trying to connect
                tryConnect();

            } catch (e) {
                console.error('Error in setupAudioAnalyzer:', e);
            }
        }

        // Legendarium logo orbiting animation
        function startLegendariumLogoAnimation() {
            const logo = document.getElementById('legendarium-logo');
            if (!logo) return;
            let start = null;
            let isHovered = false;

            // Add hover listeners
            const logoLink = document.getElementById('legendarium-logo-link');
            logoLink.addEventListener('mouseenter', () => isHovered = true);
            logoLink.addEventListener('mouseleave', () => isHovered = false);

            function animate(ts) {
                if (!start) start = ts;
                const t = (ts - start) / 1000;

                if (!isHovered) {
                    // Only orbit and spin when not hovered
                    const orbitRadiusX = 4; // px
                    const orbitRadiusY = 2; // px
                    const orbitSpeed = 0.15; // radians/sec
                    const angle = t * orbitSpeed;
                    const x = Math.cos(angle) * orbitRadiusX;
                    const y = Math.sin(angle) * orbitRadiusY;
                    const spin = Math.sin(t * 0.25) * 90; // -90deg to +90deg
                    logo.style.transform = `translate(${x}px, ${y}px) rotateY(${spin}deg)`;
                }
                requestAnimationFrame(animate);
            }
            requestAnimationFrame(animate);
        }




        // Desktop initialization with full features
        function initializeDesktop() {
            console.log('Desktop optimized initialization');

            // Initialize starfield background
            starField = new StarField();

            // Setup key unlocking system
            setupKeyUnlockingSystem();
            

            // Show unlock overlay
            const unlockOverlay = document.getElementById('unlock-overlay');
            if (unlockOverlay) {
                unlockOverlay.style.opacity = '1';
                unlockOverlay.style.pointerEvents = 'auto';
            }
        }

        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', async () => {
            // Prevent multiple initializations
            if (window.hibernalTormentInitialized) {
                console.log('Already initialized, skipping...');
                return;
            }
            window.hibernalTormentInitialized = true;
            
            // Reset global variables to prevent state persistence across refreshes
            passwordUnlocked = false;
            webampInstance = null;
            starField = null;
            animationId = null;
            eqIntervalId = null;
            lastKnownPositions = null;
            
            console.log('DOM loaded, starting initialization...');

            // Initialize desktop version
            try {
                initializeDesktop();
            } catch (error) {
                console.error('Initialization error:', error);
                // Fallback to basic initialization
                setupKeyUnlockingSystem();
                const unlockOverlay = document.getElementById('unlock-overlay');
                if (unlockOverlay) {
                    unlockOverlay.style.opacity = '1';
                    unlockOverlay.style.pointerEvents = 'auto';
                }
            }

            // Start preloading in background after a short delay
            setTimeout(async () => {
                try {
                    console.log('Starting background preload...');
                    await preloadFirstTrackOnly();
                    console.log('Background preload complete');
                } catch (error) {
                    console.error('Background preload failed:', error);
                    // Continue anyway - the site will still work with original URLs
                }
            }, 1000);

            // Call the animation function if needed
            if (!window.legendariumLogoAnimStarted) {
                window.legendariumLogoAnimStarted = true;
                startLegendariumLogoAnimation();
            }


            // Standard visibility changes to maintain background playback
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    console.log('Page hidden - maintaining audio context for background playback');
                    
                    // Standard handling for all browsers
                    if (webampInstance?.audioContext && webampInstance.audioContext.state === 'suspended') {
                        webampInstance.audioContext.resume().catch(err => {
                            console.log('Could not resume audio context:', err);
                        });
                    }
                } else {
                    console.log('Page visible - resuming normal operation');
                    
                    // Ensure audio context is active when returning to page
                    if (webampInstance?.audioContext && webampInstance.audioContext.state === 'suspended') {
                        webampInstance.audioContext.resume().catch(err => {
                            console.log('Could not resume audio context on page visible:', err);
                        });
                    }
                }
            });

            // Cleanup on page unload
            window.addEventListener('beforeunload', () => {
                if (starField) {
                    starField.destroy();
                }
            });
        });

        // Remove animation toggle related styles
        document.head.insertAdjacentHTML('beforeend', `
            <style>
                @keyframes shake {
                    0%, 100% { transform: translateX(0); }
                    10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
                    20%, 40%, 60%, 80% { transform: translateX(5px); }
                }
                
                .shake {
                    animation: shake 0.5s;
                }
            </style>
        `);





        // Simplified function to get audio level - more reliable
        function getAudioLevel() {
            // Get the current state from Webamp
            const state = webampInstance?.store?.getState();
            const media = state?.media;

            if (!media) return 0;

            // Check if we're actually playing
            const isPlaying = media.status === "PLAYING" && !media.waiting;
            if (!isPlaying) {
                return 0;
            }

            let audioLevel = 0;

            // Try to get data from analyzer if available
            if (webampInstance?.analyzer && webampInstance?.audioData) {
                try {
                    // Get frequency data
                    webampInstance.analyzer.getByteFrequencyData(webampInstance.audioData);

                    // Use a simple average of frequency data for reliability
                    let sum = 0;
                    const count = Math.min(webampInstance.audioData.length, 128); // Use first 128 bins or less

                    for (let i = 0; i < count; i++) {
                        sum += webampInstance.audioData[i];
                    }

                    // Normalize to 0-1 range
                    audioLevel = sum / (count * 255);

                    // Apply a slight curve for better visualization
                    audioLevel = Math.pow(audioLevel, 1.2);

                } catch (e) {
                    console.error('Error getting audio data:', e);
                    // Fall back to volume-based method
                    audioLevel = 0;
                }
            }

            // If analyzer failed or isn't available, fallback to volume
            if (audioLevel === 0) {
                // Get the volume from the state and normalize it
                const volume = state.media.volume || 0;
                const normalizedVolume = volume / 100;
                audioLevel = normalizedVolume * 0.7; // Scale down a bit for fallback
            }

            // Ensure reasonable bounds and add a minimum level to ensure some activity
            return Math.max(0.05, Math.min(1, audioLevel));
        }
    </script>
    <a id="legendarium-logo-link" href="https://legendarium.nyc" target="_blank" rel="noopener">
        <img id="legendarium-logo" src="assets/images/Legendarium-Logo-Trans-1.png" alt="Legendarium Logo">
    </a>
</body>

</html>