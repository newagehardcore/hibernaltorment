<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GATEKEEPER - WRONG PLANET</title>
    
    <!-- Open Graph Meta Tags for Social Media Sharing -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="GATEKEEPER - WRONG PLANET">
    <meta property="og:description" content="Interactive multimedia experience featuring dynamic audio-visual elements and immersive starfield backgrounds.">
    <meta property="og:image" content="https://res.cloudinary.com/dtwix3ubl/image/upload/v1757010129/gkHourglass8_np2lyy.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:alt" content="GATEKEEPER - WRONG PLANET Cover Image">
    <meta property="og:url" content="https://gatekeepermusic.com">
    <meta property="og:site_name" content="GATEKEEPER">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="GATEKEEPER - WRONG PLANET">
    <meta name="twitter:description" content="Interactive multimedia experience featuring dynamic audio-visual elements and immersive starfield backgrounds.">
    <meta name="twitter:image" content="https://res.cloudinary.com/dtwix3ubl/image/upload/v1757010129/gkHourglass8_np2lyy.jpg">
    <meta name="twitter:image:alt" content="GATEKEEPER - WRONG PLANET Cover Image">
    
    <!-- Additional Meta Tags -->
    <meta name="description" content="Interactive multimedia experience featuring dynamic audio-visual elements and immersive starfield backgrounds.">
    <meta name="keywords" content="GATEKEEPER, WRONG PLANET, interactive media, audio-visual, experimental music">
    <meta name="author" content="GATEKEEPER">
    <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><path d='M50 10 L30 50 L50 40 L70 50 Z' fill='%23FFA500'/><path d='M40 50 L50 30 L60 50 L50 70 Z' fill='%23FF8C00'/></svg>">
    <link rel="stylesheet" type="text/css" href="./webamp.css">
    <style>
        :root {
            --webamp-zoom: 1.1;
            /* Deity message font - italic bold Times New Roman with tight kerning */
            --deity-font: 'Times New Roman', serif;
            --deity-font-style: italic;
            --deity-font-weight: bold;
            --deity-letter-spacing: -0.02em;
            /* -20 kerning approximation */

            /* Starfield configuration - easy to modify */
            --starfield-speed: 1.5;
            /* Base speed multiplier */
            --starfield-density: 800;
            /* Number of stars */
            --starfield-brightness: 0.9;
            /* Star brightness (0-1) */
        }

        /* Starfield Canvas - positioned behind everything */
        #starfield-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            /* Behind everything */
            pointer-events: none;
            background: #000;
        }

        /* Mobile starfield optimization */
        @media screen and (max-width: 768px) {
            :root {
                --starfield-speed: 1.2;
                /* Slightly slower on mobile for performance */
                --starfield-density: 600;
                /* Fewer stars on mobile */
                --starfield-brightness: 0.85;
            }
        }

        /* High resolution display optimization */
        @media screen and (min-width: 1921px) {
            :root {
                --starfield-density: 1000;
                /* More stars on high-res displays */
                --starfield-brightness: 0.95;
            }
        }

        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            font-family: Arial, sans-serif;
            cursor: auto !important;
            /* Prevent scrolling */
            position: fixed;
            background-color: #000;
            /* Ensure body background is black */
        }



        #webamp-container {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            /* Simplified transition */
        }

        /* Mobile specific container adjustments */
        @media screen and (max-width: 768px) {
            #webamp-container {
                /* Let Webamp handle its own positioning on mobile */
                pointer-events: auto;
            }
        }


        /* Let Webamp handle its own scaling on mobile */
        @media screen and (min-width: 769px) {
            #webamp {
                zoom: var(--webamp-zoom) !important;
                -moz-transform: scale(var(--webamp-zoom));
                -moz-transform-origin: top left;
            }
        }
        
        @media screen and (max-width: 768px) {
            #webamp {
                /* No custom zoom on mobile - let Webamp handle it */
                zoom: 1 !important;
                transform: none !important;
            }
        }

        /* Desktop zoom settings */
        @media screen and (min-width: 769px) and (max-width: 1024px) {
            :root {
                --webamp-zoom: 1.0;
            }
        }

        @media screen and (min-width: 1025px) and (max-width: 1440px) {
            :root {
                --webamp-zoom: 1.2;
            }
        }

        @media screen and (min-width: 1441px) {
            :root {
                --webamp-zoom: 1.4;
            }
        }
        
        /* Mobile uses no custom zoom */
        @media screen and (max-width: 768px) {
            :root {
                --webamp-zoom: 1;
                /* No zoom on mobile */
            }
        }

        /* Remove any position constraints from windows */
        /* Base styles for all windows */
        #webamp .window {
            position: absolute !important;
            /* Override any other positioning */
            will-change: transform;
            z-index: 2;
            cursor: move !important;
        }
        
        /* Only animate on desktop for performance */
        @media screen and (min-width: 769px) {
            #webamp .window {
                animation: float-main 36s ease-in-out infinite;
            }
        }

        /* Specific animations for each window type - desktop only */
        @media screen and (min-width: 769px) {
            #webamp #main-window {
                animation: float-main 36s ease-in-out infinite;
            }

            #webamp #equalizer-window {
                animation: float-eq 36s ease-in-out infinite;
            }

            #webamp #playlist-window {
                animation: float-playlist 36s ease-in-out infinite;
            }
        }

        /* No floating animations on mobile for better performance */
        @media screen and (max-width: 768px) {
            #webamp .window {
                animation: none !important;
            }
        }

        /* Ensure draggable elements work on touch devices */
        #webamp .title-bar,
        #webamp .dragger,
        #webamp .handle {
            cursor: move !important;
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
        }
        
        /* Additional mobile touch support for Webamp windows */
        @media screen and (max-width: 768px) {
            #webamp .title-bar,
            #webamp .playlist-top,
            #webamp .equalizer-top,
            #webamp .window-header {
                cursor: move !important;
                -webkit-user-select: none !important;
                user-select: none !important;
            }
        }

        /* Additional glow effect for windows */
        #webamp .window::after {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            pointer-events: none;
            z-index: -1;
        }

        /* Remove loading text styles */
        #loading {
            display: none;
        }

        /* Override cursor styles except for buttons */
        * {
            cursor: auto !important;
        }

        /* Allow pointer cursor on buttons */
        button,
        .webamp-region button,
        #webamp button,
        [role="button"] {
            cursor: pointer !important;
        }

        /* Password protection overlay */
        #password-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 2s ease-out;
        }

        /* Mobile password overlay - ensure it shows properly */
        @media (max-width: 768px) {
            #password-overlay {
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                padding: 20px;
                box-sizing: border-box;
            }

            #password-container {
                width: 90%;
                max-width: 300px;
                margin: 0 auto;
                box-sizing: border-box;
                /* Ensure centering */
            }
        }

        #password-container {
            position: relative;
            width: 300px;
        }

        #password-label {
            position: absolute;
            font-family: monospace;
            color: #222;
            font-size: 10px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-transform: uppercase;
            pointer-events: none;
            letter-spacing: 0px;
        }

        #password-input {
            width: 100%;
            padding: 15px;
            background-color: #111;
            border: 1px solid #333;
            color: #9CAF50;
            font-family: monospace;
            font-size: 14px;
            letter-spacing: 0px;
            text-align: center;
            outline: none;
            transition: border 0.3s ease-in-out;
            box-sizing: border-box;
            caret-color: #9CAF50;
        }

        #password-input:focus {
            border-color: #555;
        }

        @keyframes flash-red {
            0% {
                color: #9CAF50;
            }

            50% {
                color: #7A8F3F;
            }

            100% {
                color: #9CAF50;
            }
        }

        .flashing {
            animation: flash-red 0.5s infinite;
        }

        #access-indicator {
            margin-top: 15px;
            height: 2px;
            background-color: #222;
            transform-origin: left;
            transform: scaleX(0);
            transition: transform 0.5s ease-in-out, background-color 0.5s ease-in-out;
        }

        .granted {
            transform: scaleX(1) !important;
            background-color: #9CAF50 !important;
        }

        /* Add styles for viewer videos */
        .viewer-video {
            position: absolute;
            inset: 0;
            margin: auto;
            width: 100%;
            height: 100%;
            opacity: 0;
            object-fit: cover;
            object-position: center;
            will-change: opacity;
        }

        .viewer-video.active {
            opacity: 1;
            /* Full opacity in viewer */
        }

        /* Fullscreen background video styles */
        #fullscreen-background-video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            object-position: center;
            z-index: 6;
            /* Above starfield (-1), above cover window (5), below webamp (10) */
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
        }

        #fullscreen-background-video.active {
            opacity: 1;
            pointer-events: auto;
        }

        /* Hide viewer window when in fullscreen mode */
        #viewer-window.fullscreen-mode {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* Hide Legendarium logo behind fullscreen video */
        #legendarium-logo-link.hidden-behind-fullscreen {
            z-index: 0 !important;
            /* Behind fullscreen video (z-index: 1) */
        }

        /* TV off animation for viewer window */
        /* Using the exact same tvTurnOff animation as deity messages */

        /* Adjust positioning for scaled elements */
        @keyframes rotatingShadow {
            0% {
                /* filter: 
                    drop-shadow(-4px 2px 4px rgba(0, 0, 0, 0.95))
                    drop-shadow(-6px 4px 8px rgba(0, 0, 0, 0.85))
                    drop-shadow(-8px 8px 15px rgba(0, 0, 0, 0.75))
                    drop-shadow(-10px 12px 25px rgba(0, 0, 0, 0.65)); */
            }

            25% {
                /* filter: 
                    drop-shadow(0px 4px 4px rgba(0, 0, 0, 0.95))
                    drop-shadow(0px 6px 8px rgba(0, 0, 0, 0.85))
                    drop-shadow(0px 8px 15px rgba(0, 0, 0, 0.75))
                    drop-shadow(0px 12px 25px rgba(0, 0, 0, 0.65)); */
            }

            50% {
                /* filter: 
                    drop-shadow(4px 2px 4px rgba(0, 0, 0, 0.95))
                    drop-shadow(6px 4px 8px rgba(0, 0, 0, 0.85))
                    drop-shadow(8px 8px 15px rgba(0, 0, 0, 0.75))
                    drop-shadow(10px 12px 25px rgba(0, 0, 0, 0.65)); */
            }

            75% {
                /* filter: 
                    drop-shadow(0px -2px 4px rgba(0, 0, 0, 0.95))
                    drop-shadow(0px -4px 8px rgba(0, 0, 0, 0.85))
                    drop-shadow(0px -6px 15px rgba(0, 0, 0, 0.75))
                    drop-shadow(0px -8px 25px rgba(0, 0, 0, 0.65)); */
            }

            100% {
                /* filter: 
                    drop-shadow(-4px 2px 4px rgba(0, 0, 0, 0.95))
                    drop-shadow(-6px 4px 8px rgba(0, 0, 0, 0.85))
                    drop-shadow(-8px 8px 15px rgba(0, 0, 0, 0.75))
                    drop-shadow(-10px 12px 25px rgba(0, 0, 0, 0.65)); */
            }
        }

        /* Add dynamic shadow class that will be controlled by JS */
        #webamp .window.dynamic-shadow {
            transition: filter 0.1s ease-out;
        }

        /* Remove animation toggle button styles */

        /* Deity Message Windows */
        .deity-message-window {
            position: fixed;
            width: 315px;
            /* Scaled down 10% from 350px */
            min-height: 120px;
            background: #000000;
            border: none;
            border-radius: 0;
            font-family: var(--deity-font);
            font-style: var(--deity-font-style);
            font-weight: var(--deity-font-weight);
            letter-spacing: var(--deity-letter-spacing);
            font-size: 16px;
            color: #ffffff;
            z-index: 1001;
            cursor: move;
            touch-action: none; /* Enable touch dragging */
            user-select: none; /* Prevent text selection during drag */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;


            filter:
                drop-shadow(-4px 2px 4px rgba(0, 0, 0, 0.95)) drop-shadow(-6px 4px 8px rgba(0, 0, 0, 0.85)) drop-shadow(-8px 8px 15px rgba(0, 0, 0, 0.75)) drop-shadow(-10px 12px 25px rgba(0, 0, 0, 0.65));
            will-change: filter, transform;
            animation: float 8s ease-in-out infinite;
            opacity: 0;
            transform: scale(0.1);
            transition: none;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            backdrop-filter: blur(1px);
        }

        /* Mobile deity message scaling */
        @media screen and (max-width: 768px) {
            .deity-message-window {
                width: 280px;
                /* Slightly smaller on mobile */
                font-size: 14px;
                /* Smaller font */
            }
        }

        @media screen and (max-width: 480px) {
            .deity-message-window {
                width: 250px;
                /* Even smaller on small phones */
                font-size: 13px;
            }
        }

        /* Add floating animation to viewer and cover windows */
        /* Viewer animation now handled by .appearing class */

        #cover-window {
            will-change: transform;
            animation: floatCover 8.7s ease-in-out infinite;
        }

        /* Keep viewer and cover animations on mobile - removed restriction */

        .deity-message-window.appearing {
            animation: tvTurnOn 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards, float 8s ease-in-out infinite 1.2s;
        }

        .deity-message-window.disappearing {
            animation: tvTurnOff 0.8s cubic-bezier(0.55, 0.055, 0.675, 0.19) forwards;
        }

        .deity-message-top {
            width: 100%;
            height: 25px;
            background-image: url('./assets/skins/messagetop.png');
            background-repeat: no-repeat;
            background-size: 100% 100%;
            background-position: center;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            cursor: pointer;
            position: relative;
        }

        .deity-message-top:hover {
            filter: brightness(1.1);
        }

        .deity-close-button {
            position: absolute;
            top: 0;
            right: 0;
            width: 25px;
            height: 25px;
            cursor: pointer;
            z-index: 10;
            /* Invisible but clickable area over the X */
            background: transparent;
        }

        .deity-close-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .deity-message-content {
            background: #000000;
            border-left: 2px dotted rgba(255, 255, 255, 0.8);
            border-right: 2px dotted rgba(255, 255, 255, 0.8);
            padding: 20px 25px;
            line-height: 1.5;
            text-align: center;
            position: relative;
            overflow: hidden;
            min-height: 50px;
            max-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .deity-message-bottom {
            width: 100%;
            height: 2px;
            border-bottom: 2px dotted rgba(255, 255, 255, 0.8);
            background: transparent;
            position: relative;
        }

        .deity-message-bottom::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 0;
            right: 0;
            height: 2px;
            border-bottom: 2px dotted rgba(255, 255, 255, 0.8);
        }

        /* Create double dotted line effect for deity message side borders - matching bottom style */
        .deity-message-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 2px;
            right: 2px;
            bottom: 0;
            border-left: 2px dotted rgba(255, 255, 255, 0.8);
            border-right: 2px dotted rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 1;
        }

        .deity-message-content .scanlines::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                repeating-linear-gradient(0deg,
                    transparent,
                    transparent 3px,
                    rgba(0, 0, 0, 0.05) 4px);
            pointer-events: none;
            z-index: 2;
        }

        .deity-message-content .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .deity-message-content::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background:
                radial-gradient(circle, rgba(255, 255, 255, 0.08) 0%, transparent 70%);
            animation: etherealPulse 12s ease-in-out infinite;
            pointer-events: none;
        }

        .deity-message-text {
            position: relative;
            z-index: 2;
            text-shadow:
                0 0 10px rgba(255, 255, 255, 0.8),
                0 0 20px rgba(255, 255, 255, 0.4),
                0 0 30px rgba(255, 255, 255, 0.2);
            font-style: italic;
            letter-spacing: 0.5px;
            width: 100%;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow: hidden;
            opacity: 0;
            line-height: 1.4;
            display: inline-block;
            text-align: center;
            /* Pixelated/broken text effects */
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            font-variant-ligatures: none;
            text-rendering: geometricPrecision;
            /* Subtle broken/distant feeling */
            filter: contrast(1.1) brightness(0.95);
            /* Slightly irregular character spacing for broken feel */
            word-spacing: 0.1em;
            /* Add subtle pixelated text shadow for depth */
            text-shadow:
                0 0 2px rgba(255, 255, 255, 0.9),
                1px 0 0px rgba(255, 255, 255, 0.7),
                0 1px 0px rgba(255, 255, 255, 0.7),
                0 0 10px rgba(255, 255, 255, 0.6),
                0 0 20px rgba(255, 255, 255, 0.3);
        }

        .deity-message-text.typing {
            opacity: 1;
            animation: textGlow 6s ease-in-out infinite alternate var(--typing-duration), subtleFlicker 3s ease-in-out infinite var(--typing-duration);
        }

        .deity-message-text::after {
            content: '';
            opacity: 0;
        }

        .typing-ellipses {
            position: relative;
            display: inline-block;
            width: 30px;
            height: 1em;
            vertical-align: baseline;
            opacity: 0;
            white-space: nowrap;
            flex-shrink: 0;
        }

        /* Prevent ellipses from being alone on a line */
        .typed-text {
            display: inline;
        }

        /* Keep ellipses with last word using non-breaking space */

        .typing-ellipses.show {
            opacity: 1;
        }

        .typing-ellipses::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            animation: none;
        }

        .typing-ellipses.show::before {
            animation: typingEllipsesFlow 0.8s infinite;
        }

        @keyframes typingEllipsesFlow {

            0%,
            16.66% {
                content: '.';
            }

            33.33%,
            49.99% {
                content: '..';
            }

            66.66%,
            83.32% {
                content: '...';
            }

            100% {
                content: '';
            }
        }

        .deity-message-text::after {
            content: '';
            opacity: 0;
        }

        .deity-message-text.typing::after {
            content: '';
            opacity: 0;
        }

        .typing-ellipses::after {
            content: '';
        }

        .deity-message-window.disappearing .deity-message-content {
            background: radial-gradient(circle at center, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.7), rgba(0, 0, 0, 0.1));
            animation: whiteFlashFill 0.8s cubic-bezier(0.55, 0.055, 0.675, 0.19) forwards;
        }

        @keyframes whiteFlashFill {
            0% {
                background: #000000;
            }

            30% {
                background: radial-gradient(circle at center, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1), rgba(0, 0, 0, 0.8));
            }

            70% {
                background: radial-gradient(circle at center, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.6), rgba(255, 255, 255, 0.2));
            }

            100% {
                background: rgba(255, 255, 255, 0.95);
            }
        }



        /* Static noise effect for TV transitions */
        @keyframes staticNoise {

            0%,
            100% {
                background-position: 0% 0%;
                opacity: 0.1;
            }

            25% {
                background-position: 10% 20%;
                opacity: 0.15;
            }

            50% {
                background-position: -5% 10%;
                opacity: 0.08;
            }

            75% {
                background-position: 15% -10%;
                opacity: 0.12;
            }
        }

        @keyframes tvTurnOn {
            0% {
                opacity: 0;
                transform: scaleY(0.01) scaleX(0.8);
                filter: brightness(15) contrast(8) saturate(0);
            }

            15% {
                opacity: 0.8;
                transform: scaleY(0.01) scaleX(0.8);
                filter: brightness(10) contrast(5) saturate(0.3);
            }

            30% {
                transform: scaleY(0.3) scaleX(0.9);
                filter: brightness(6) contrast(3) saturate(0.7);
            }

            50% {
                transform: scaleY(0.9) scaleX(1.02);
                filter: brightness(2) contrast(2) saturate(1.1);
            }

            70% {
                transform: scaleY(1.05) scaleX(1.01);
                filter: brightness(1.3) contrast(1.3) saturate(1.2);
            }

            85% {
                transform: scaleY(0.98) scaleX(1.005);
                filter: brightness(1.1) contrast(1.1) saturate(1.05);
            }

            100% {
                opacity: 1;
                transform: scaleY(1) scaleX(1);
                filter: brightness(1) contrast(1) saturate(1);
            }
        }

        @keyframes tvTurnOff {
            0% {
                opacity: 1;
                transform: scaleY(1) scaleX(1);
                filter: brightness(1) contrast(1) saturate(1);
            }

            15% {
                transform: scaleY(1.02) scaleX(1.01);
                filter: brightness(1.5) contrast(1.5) saturate(0.9);
            }

            35% {
                transform: scaleY(0.9) scaleX(0.95);
                filter: brightness(3) contrast(3) saturate(0.5);
            }

            55% {
                transform: scaleY(0.3) scaleX(0.85);
                filter: brightness(8) contrast(8) saturate(0.1);
            }

            75% {
                transform: scaleY(0.05) scaleX(0.7);
                filter: brightness(15) contrast(15) saturate(0);
            }

            90% {
                opacity: 0.3;
                transform: scaleY(0.01) scaleX(0.5);
                filter: brightness(20) contrast(20) saturate(0);
            }

            100% {
                opacity: 0;
                transform: scaleY(0) scaleX(0);
                filter: brightness(0) contrast(0) saturate(0);
            }
        }

        @keyframes float-main {

            0%,
            100% {
                transform: translate(0, 0) rotate(0deg);
            }

            20% {
                transform: translate(3px, -4px) rotate(0.8deg);
            }

            40% {
                transform: translate(-2px, -6px) rotate(0.2deg);
            }

            60% {
                transform: translate(-4px, 2px) rotate(-0.5deg);
            }

            80% {
                transform: translate(1px, 4px) rotate(-0.2deg);
            }
        }

        @keyframes float-eq {

            0%,
            100% {
                transform: translate(-2px, 2px) rotate(-0.3deg);
            }

            20% {
                transform: translate(-4px, -2px) rotate(0.5deg);
            }

            40% {
                transform: translate(3px, -4px) rotate(-0.2deg);
            }

            60% {
                transform: translate(2px, 3px) rotate(0.4deg);
            }

            80% {
                transform: translate(-3px, 1px) rotate(-0.6deg);
            }
        }

        @keyframes float-playlist {

            0%,
            100% {
                transform: translate(2px, -3px) rotate(0.4deg);
            }

            20% {
                transform: translate(-3px, -1px) rotate(-0.3deg);
            }

            40% {
                transform: translate(1px, 4px) rotate(0.6deg);
            }

            60% {
                transform: translate(-2px, -4px) rotate(-0.2deg);
            }

            80% {
                transform: translate(3px, 2px) rotate(0.5deg);
            }
        }

        @keyframes floatViewer {

            0%,
            100% {
                transform: translate(0, 0) rotate(0deg);
            }

            25% {
                transform: translate(-3px, -2px) rotate(-0.3deg);
            }

            50% {
                transform: translate(2px, -5px) rotate(0.5deg);
            }

            75% {
                transform: translate(4px, 3px) rotate(-0.2deg);
            }
        }

        @keyframes floatCover {

            0%,
            100% {
                transform: translate(0, 0) rotate(0deg);
            }

            20% {
                transform: translate(4px, 2px) rotate(0.4deg);
            }

            45% {
                transform: translate(-3px, -3px) rotate(-0.6deg);
            }

            65% {
                transform: translate(-2px, 4px) rotate(0.3deg);
            }

            85% {
                transform: translate(3px, -2px) rotate(-0.2deg);
            }
        }

        @keyframes float {

            0%,
            100% {
                transform: translate(0, 0) rotate(0deg);
            }

            25% {
                transform: translate(2px, -3px) rotate(0.3deg);
            }

            50% {
                transform: translate(-1px, -2px) rotate(-0.2deg);
            }

            75% {
                transform: translate(-2px, 1px) rotate(0.1deg);
            }
        }

        @keyframes textGlow {
            0% {
                text-shadow:
                    0 0 10px rgba(255, 255, 255, 0.8),
                    0 0 20px rgba(255, 255, 255, 0.4),
                    0 0 30px rgba(255, 255, 255, 0.2);
            }

            100% {
                text-shadow:
                    0 0 15px rgba(255, 255, 255, 1),
                    0 0 30px rgba(255, 255, 255, 0.6),
                    0 0 45px rgba(255, 255, 255, 0.3),
                    0 0 60px rgba(255, 255, 255, 0.1);
            }
        }

        @keyframes subtleFlicker {

            0%,
            90%,
            100% {
                opacity: 1;
            }

            93%,
            97% {
                opacity: 0.92;
            }

            95% {
                opacity: 0.98;
            }
        }

        @keyframes etherealPulse {

            0%,
            100% {
                transform: scale(1) rotate(0deg);
                opacity: 0.03;
            }

            33% {
                transform: scale(1.1) rotate(120deg);
                opacity: 0.08;
            }

            66% {
                transform: scale(0.9) rotate(240deg);
                opacity: 0.05;
            }
        }

        /* Square border overlays for mobile */
        .square-border-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease;
            background-size: 100% 100%;
            background-repeat: no-repeat;
            background-position: center;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        /* Show square overlays only on mobile */
        @media screen and (max-width: 768px) {
            .square-border-overlay {
                opacity: 1;
                z-index: 10;
            }
            
            /* Square-1 for viewer window (left side) */
            #viewer-window .square-border-overlay {
                background-image: url('./assets/images/Square-1.png');
            }
            
            /* Square-2 for cover window (right side) */
            #cover-window .square-border-overlay {
                background-image: url('./assets/images/Square-2.png');
            }
            
            /* Hide ALL dotted borders on mobile when square overlays are active */
            #viewer-window,
            #viewer-window::before,
            #cover-window,
            #cover-window::before {
                border: none !important;
            }
            
            /* Hide all dotted border elements for viewer */
            .viewer-content,
            .viewer-content::before,
            .viewer-bottom,
            .viewer-bottom::after {
                border: none !important;
                display: block !important;
            }
            
            .viewer-content::before {
                display: none !important;
            }
            
            .viewer-bottom::after {
                display: none !important;
            }
            
            /* Hide all dotted border elements for cover */
            .cover-content,
            .cover-content::before,
            .cover-bottom,
            .cover-bottom::after {
                border: none !important;
                display: block !important;
            }
            
            .cover-content::before {
                display: none !important;
            }
            
            .cover-bottom::after {
                display: none !important;
            }
            
            /* Ensure square overlays scale with lightbox and stay on top */
            #viewer-window.lightbox .square-border-overlay,
            #cover-window.lightbox .square-border-overlay {
                transform: scale(1);
                transition: transform 0.3s ease, opacity 0.3s ease;
                z-index: 1001;
            }
        }

        /* Mobile-specific floating animations - more subtle */
        @keyframes float-main-mobile {

            0%,
            100% {
                transform: translate(0, 0) rotate(0deg);
            }

            25% {
                transform: translate(1px, -2px) rotate(0.2deg);
            }

            50% {
                transform: translate(-1px, -1px) rotate(-0.1deg);
            }

            75% {
                transform: translate(-1px, 1px) rotate(0.1deg);
            }
        }

        @keyframes float-eq-mobile {

            0%,
            100% {
                transform: translate(-1px, 1px) rotate(-0.1deg);
            }

            25% {
                transform: translate(-2px, -1px) rotate(0.2deg);
            }

            50% {
                transform: translate(1px, -2px) rotate(-0.1deg);
            }

            75% {
                transform: translate(1px, 1px) rotate(0.1deg);
            }
        }

        @keyframes float-playlist-mobile {

            0%,
            100% {
                transform: translate(1px, -1px) rotate(0.1deg);
            }

            25% {
                transform: translate(-1px, 0px) rotate(-0.1deg);
            }

            50% {
                transform: translate(0px, 2px) rotate(0.2deg);
            }

            75% {
                transform: translate(-1px, -1px) rotate(-0.1deg);
            }
        }

        #legendarium-logo-link {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
            display: block;
            width: 15vw;
            max-width: 180px;
            min-width: 80px;
            height: auto;
            cursor: pointer;
            opacity: 0;
            transition: opacity 3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #legendarium-logo-link.visible {
            opacity: 0.92;
        }

        #legendarium-logo-link:hover {
            opacity: 1;
        }

        #legendarium-logo {
            width: 100%;
            height: auto;
            display: block;
            pointer-events: none;
            will-change: transform;
            filter: drop-shadow(0 2px 8px #000a);
            image-rendering: auto;
            transition: transform 0.3s ease-out;
            /* Add smooth transition */
        }

        /* Add hover state for the link */
        #legendarium-logo-link:hover #legendarium-logo {
            transform: scale(1.15) rotateY(0deg) !important;
            /* Scale up and face forward */
        }

        /* Viewer Window Styles */
        #viewer-window {
            position: fixed;
            top: 5%;
            left: 35%;
            transform: none;
            aspect-ratio: 1/1;
            background: #000000;
            border: none;
            border-radius: 0;
            z-index: 5;
            cursor: move;
            filter: none;
            will-change: transform;
            user-select: none;
            display: flex;
            flex-direction: column;
            max-height: none;
            max-width: none;
            width: 828px;
            height: 828px;
            opacity: 0;
            transition: opacity 0.8s ease-in-out;
            resize: both;
            overflow: hidden;
        }

        #viewer-window.visible {
            opacity: 1;
            animation: floatViewer 9.5s ease-in-out infinite;
        }

        /* TV animations for viewer window - ONLY for fullscreen transitions */
        #viewer-window.tv-appearing {
            animation: tvTurnOn 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        #viewer-window.tv-disappearing {
            animation: tvTurnOff 0.8s cubic-bezier(0.55, 0.055, 0.675, 0.19) forwards;
        }

        /* TV effects for fullscreen background video during transitions */
        #fullscreen-background-video.tv-appearing {
            animation: tvTurnOn 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        #fullscreen-background-video.tv-disappearing {
            animation: tvTurnOff 0.8s cubic-bezier(0.55, 0.055, 0.675, 0.19) forwards;
        }

        /* Add white flash effect for viewer content during TV off (like deity messages) */
        #viewer-window.tv-disappearing .viewer-content {
            background: radial-gradient(circle at center, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.7), rgba(0, 0, 0, 0.1));
            animation: whiteFlashFill 0.8s cubic-bezier(0.55, 0.055, 0.675, 0.19) forwards;
        }

        @media (max-width: 768px) {
            #viewer-window {
                /* Mobile viewer window positioning - default bottom left, but allow dragging */
                position: fixed !important;
                /* Default to bottom-left but allow dragging */
                bottom: 0 !important;
                left: 0 !important;
                width: 50vw !important;
                height: 50vw !important;
                max-height: none !important;
                max-width: none !important;
                min-width: 50vw !important;
                min-height: 50vw !important;
                transform: none !important;
                cursor: move !important; /* Allow dragging */
                resize: none !important;
                opacity: 1 !important;
                top: auto !important;
                right: auto !important;
                z-index: 5 !important;
                display: block !important;
            }
        }

        /* Add resize handle */
        .viewer-resize-handle {
            position: absolute;
            right: 0;
            bottom: 0;
            width: 15px;
            height: 15px;
            cursor: nwse-resize;
            z-index: 7;
            background: transparent;
        }



        .viewer-resize-handle::after {
            content: "◢";
            position: absolute;
            right: 3px;
            bottom: 1px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 10px;
        }

        .viewer-header {
            width: 100%;
            height: 25px;
            background-image: url('./assets/skins/viewerHeader.png');
            background-repeat: no-repeat;
            background-size: 100% 100%;
            background-position: center;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            cursor: move;
            position: relative;
            flex-shrink: 0;
        }

        .viewer-close-button,
        .viewer-fullscreen-button {
            position: absolute;
            top: 0;
            width: 25px;
            height: 25px;
            cursor: pointer;
            z-index: 10;
            background: transparent;
        }

        .viewer-close-button {
            right: 0;
            /* Position at the right edge */
        }

        .viewer-close-button::after {
            content: "×";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 16px;
        }

        .viewer-fullscreen-button {
            right: 0;
        }

        .viewer-fullscreen-button::after {
            content: "▣";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
        }

        .viewer-close-button:hover,
        .viewer-fullscreen-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .viewer-content {
            flex: 1;
            background: #000000;
            border-left: 2px dotted rgba(255, 255, 255, 0.8);
            border-right: 2px dotted rgba(255, 255, 255, 0.8);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .viewer-loop-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        .viewer-loop {
            position: absolute;
            inset: 0;
            margin: auto;
            width: 100%;
            height: 100%;
            opacity: 0;
            object-fit: cover;
            /* Cover instead of contain to avoid black bars */
            object-position: center;
            will-change: opacity;
            transition: opacity 0.5s ease-in-out;
        }



        .viewer-loop.active {
            opacity: 1;
        }

        .viewer-bottom {
            width: 100%;
            height: 2px;
            border-bottom: 2px dotted rgba(255, 255, 255, 0.8);
            background: transparent;
            position: relative;
            flex-shrink: 0;
        }

        .viewer-bottom::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 0;
            right: 0;
            height: 2px;
            border-bottom: 2px dotted rgba(255, 255, 255, 0.8);
        }

        /* Create double dotted line effect for viewer side borders - matching bottom style */
        .viewer-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 2px;
            right: 2px;
            bottom: 0;
            border-left: 2px dotted rgba(255, 255, 255, 0.8);
            border-right: 2px dotted rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 1;
        }

        .hidden {
            display: none !important;
        }

        /* Cover Window Styles - Desktop Hidden */
        #cover-window {
            position: fixed;
            transform: none;
            background: #000000;
            border: none;
            border-radius: 0;
            z-index: 5;
            cursor: move;
            filter: none;
            will-change: transform;
            user-select: none;
            display: flex;
            flex-direction: column;
            width: 300px;
            height: 333px;
            opacity: 0;
            transition: opacity 0.8s ease-in-out;
            resize: both;
            overflow: hidden;
        }

        /* Show cover window on mobile, hide on desktop */
        @media screen and (min-width: 769px) {
            #cover-window {
                display: none !important;
            }
        }

        @media screen and (max-width: 768px) {
            #cover-window {
                display: flex !important;
            }
        }

        #cover-window.visible {
            opacity: 1;
        }

        .cover-header {
            width: 100%;
            height: 25px;
            background-image: url('./assets/skins/coverHeader.png');
            background-repeat: no-repeat;
            background-size: 100% 100%;
            background-position: center;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            cursor: move;
            position: relative;
            flex-shrink: 0;
        }

        .cover-close-button {
            position: absolute;
            top: 0;
            right: 0;
            width: 25px;
            height: 25px;
            cursor: pointer;
            z-index: 10;
            background: transparent;
        }

        .cover-close-button::after {
            content: "×";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 16px;
        }

        .cover-close-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .cover-content {
            flex: 1;
            background: #000000;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        #cover-window::before {
            content: '';
            position: absolute;
            top: 0;
            left: 2px;
            right: 2px;
            bottom: 0;
            border-left: 2px dotted rgba(255, 255, 255, 0.8);
            border-right: 2px dotted rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 1;
        }

        .cover-image-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #cover-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
            image-rendering: auto;
        }

        .cover-bottom {
            width: 100%;
            height: 2px;
            border-bottom: 2px dotted rgba(255, 255, 255, 0.8);
            background: transparent;
            position: relative;
            flex-shrink: 0;
        }

        .cover-bottom::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 0;
            right: 0;
            height: 2px;
            border-bottom: 2px dotted rgba(255, 255, 255, 0.8);
        }

        .cover-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 2px;
            right: 2px;
            bottom: 0;
            border-left: 2px dotted rgba(255, 255, 255, 0.8);
            border-right: 2px dotted rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 1;
        }

        .cover-resize-handle {
            position: absolute;
            right: 0;
            bottom: 0;
            width: 15px;
            height: 15px;
            cursor: nwse-resize;
            z-index: 7;
            background: transparent;
        }

        .cover-resize-handle::after {
            content: "◢";
            position: absolute;
            right: 3px;
            bottom: 1px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 10px;
        }

        /* Mobile Layout Styles */
        @media screen and (max-width: 768px) {

            /* Force fixed body height on mobile */
            html,
            body {
                height: 100vh !important;
                overflow: hidden !important;
                position: fixed !important;
                width: 100% !important;
            }

            /* Position webamp container */
            #webamp-container {
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                z-index: 10 !important;
            }

            /* Hide equalizer window on mobile */
            #webamp #equalizer-window {
                display: none !important;
            }


            /* Mobile viewer window positioning - bottom left */
            #viewer-window {
                position: fixed !important;
                bottom: 0 !important;
                left: 0 !important;
                width: 50vw !important;
                height: 50vw !important;
                max-height: none !important;
                max-width: none !important;
                min-width: 50vw !important;
                min-height: 50vw !important;
                transform: none !important;
                cursor: move !important; /* Allow dragging on mobile */
                resize: none !important;
                opacity: 1 !important;
                top: auto !important;
                right: auto !important;
                z-index: 5 !important;
                display: block !important;
                transition: all 0.3s ease-in-out !important;
            }

            /* Lightbox state for viewer */
            #viewer-window.lightbox {
                position: fixed !important;
                bottom: 0 !important;
                left: 0 !important;
                width: 100vw !important;
                height: 100vw !important;
                max-height: 100vh !important;
                z-index: 1000 !important;
                transform-origin: bottom left !important;
            }

            /* Make viewer content fill entire window */
            #viewer-window .viewer-content {
                position: absolute !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                flex: none !important;
            }

            /* Lightbox content for viewer */
            #viewer-window.lightbox .viewer-content {
                position: absolute !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                flex: none !important;
            }

            /* Hide viewer header on mobile */
            .viewer-header {
                display: none !important;
            }

            /* Hide resize handle on mobile */
            .viewer-resize-handle {
                display: none !important;
            }

            /* Remove conflicting dotted borders - they are handled by square overlay rules */

            /* Mobile cover window positioning - default bottom right, but allow dragging */
            #cover-window {
                position: fixed !important;
                /* Default to bottom-right but allow dragging */
                bottom: 0 !important;
                right: 0 !important;
                width: 50vw !important;
                height: 50vw !important;
                max-height: none !important;
                max-width: none !important;
                min-width: 50vw !important;
                min-height: 50vw !important;
                transform: none !important;
                cursor: move !important; /* Allow dragging on mobile */
                resize: none !important;
                opacity: 1 !important;
                top: auto !important;
                left: auto !important;
                z-index: 5 !important;
                display: block !important;
                transition: all 0.3s ease-in-out !important;
            }

            /* Lightbox state for cover */
            #cover-window.lightbox {
                position: fixed !important;
                bottom: 0 !important;
                right: 0 !important;
                width: 100vw !important;
                height: 100vw !important;
                max-height: 100vh !important;
                z-index: 1000 !important;
                transform-origin: bottom right !important;
            }

            #cover-window .cover-content {
                position: absolute !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                flex: none !important;
            }

            /* Lightbox content for cover */
            #cover-window.lightbox .cover-content {
                position: absolute !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                flex: none !important;
            }

            .cover-header {
                display: none !important;
            }

            .cover-resize-handle {
                display: none !important;
            }

            /* Remove conflicting dotted borders for cover - they are handled by square overlay rules */
        }
    </style>
</head>

<body>
    <!-- Starfield Background Canvas -->
    <canvas id="starfield-canvas"></canvas>

    <!-- Fullscreen background video -->
    <video id="fullscreen-background-video" muted loop playsInline autoplay></video>

    <!-- Viewer window for loops -->
    <div id="viewer-window" class="window-draggable">
        <div class="viewer-header">
            <div class="viewer-close-button"></div>
        </div>
        <div class="viewer-content">
            <div class="viewer-loop-container"></div>
        </div>
        <div class="viewer-bottom"></div>
        <div class="viewer-resize-handle"></div>
        <div class="square-border-overlay"></div>
    </div>

    <!-- Cover window for album art -->
    <div id="cover-window" class="window-draggable">
        <div class="cover-header">
            <div class="cover-close-button"></div>
        </div>
        <div class="cover-content">
            <div class="cover-image-container">
                <img id="cover-image"
                    src="https://res.cloudinary.com/dtwix3ubl/image/upload/v1751300090/gkHourglass8_np2lyy.jpg"
                    alt="Album Cover">
            </div>
        </div>
        <div class="cover-bottom"></div>
        <div class="cover-resize-handle"></div>
        <div class="square-border-overlay"></div>
    </div>

    <!-- Password protection overlay -->
    <div id="password-overlay">
        <div id="password-container">
            <div id="password-label"></div>
            <input type="text" id="password-input" autocomplete="off" spellcheck="false">
            <div id="access-indicator"></div>
        </div>
    </div>



    <div id="webamp-container"></div>

    <!-- Load Webamp from CDN -->
    <script src="https://unpkg.com/webamp@1.4.2/built/webamp.bundle.min.js"></script>

    <script>
        // Remove dynamic viewport scaling - let Webamp handle its own scaling

        // Mobile detection for later use
        // Legacy mobile detection (replaced by getDeviceInfo())
        const isMobileDevice = getDeviceInfo().isMobile;

        // Starfield System
        class StarField {
            constructor() {
                this.canvas = document.getElementById('starfield-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.stars = [];
                this.time = 0;
                this.twinkleSpeedMultiplier = 1.0; // Adjustable twinkle speed
                this.resize();
                this.createStars(800); // 800 stars
                window.addEventListener('resize', () => this.resize());
                requestAnimationFrame((t) => this.animate(t));
            }

            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.centerX = this.width / 2;
                this.centerY = this.height / 2;
            }

            createStars(count) {
                const maxDist = Math.sqrt(Math.pow(this.width / 2, 2) + Math.pow(this.height / 2, 2));

                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const initialDistance = Math.random() * maxDist; // Distribute across screen

                    this.stars.push({
                        angle: angle,
                        size: (Math.random() * 1.5 + 0.375), // 75% of original size
                        speed: Math.random() * 0.5 + 0.1,
                        brightness: Math.random() * 1.8 + 0.6, // Brighter base brightness
                        twinkleSpeed: Math.random() * 2.1 + 0.02, // Individual twinkle speed
                        twinklePhase: Math.random() * Math.PI * 2, // Random starting phase
                        glowPhase: Math.random() < 0.3 ? Math.random() * Math.PI * 2 : undefined, // 30% of stars get random glow
                        x: this.centerX + Math.cos(angle) * initialDistance,
                        y: this.centerY + Math.sin(angle) * initialDistance
                    });
                }
            }

            animate(timestamp) {
                this.time = timestamp * 0.001; // Convert to seconds
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(0, 0, this.width, this.height);

                this.stars.forEach(star => {
                    // Move star
                    star.x += Math.cos(star.angle) * star.speed;
                    star.y += Math.sin(star.angle) * star.speed;

                    // Reset if off screen
                    if (star.x < 0 || star.x > this.width ||
                        star.y < 0 || star.y > this.height) {
                        star.x = this.centerX;
                        star.y = this.centerY;
                        star.angle = Math.random() * Math.PI * 2;
                    }

                    // Draw star
                    let distance = Math.sqrt(
                        Math.pow(star.x - this.centerX, 2) +
                        Math.pow(star.y - this.centerY, 2)
                    );
                    let maxDistance = Math.sqrt(
                        Math.pow(this.width / 2, 2) +
                        Math.pow(this.height / 2, 2)
                    );
                    // Base opacity increases from center to edge
                    let opacity = distance / maxDistance * 1.5; // Increased overall brightness by 50%

                    // Enhanced sparkle effect with much longer dark periods
                    let twinkleBase = Math.sin(this.time * star.twinkleSpeed * this.twinkleSpeedMultiplier * 2 + star.twinklePhase);
                    // Create sparkle effect - stars are mostly dark (0.05) with occasional bright sparkles
                    let twinkle = Math.pow(Math.max(0, twinkleBase * 0.5 + 0.5), 4.5) * 0.95 + 0.05;

                    // Random glow enhancement for some stars
                    let randomGlow = 1.0;
                    if (star.glowPhase !== undefined) {
                        let glowCycle = Math.sin(this.time * 0.3 + star.glowPhase);
                        randomGlow = glowCycle > 0.7 ? 1.0 + (glowCycle - 0.7) * 2.0 : 1.0;
                    }

                    // Combine base opacity with twinkle, brightness, and random glow
                    opacity = Math.min(opacity * star.brightness * twinkle * randomGlow, 1);

                    if (opacity > 0) {
                        // Draw main star with enhanced glow
                        this.ctx.fillStyle = `rgba(255,255,255,${opacity})`;
                        this.ctx.beginPath();
                        this.ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                        this.ctx.fill();

                        // Enhanced glow system with multiple layers
                        if (opacity > 0.3) {
                            // Inner glow
                            this.ctx.globalAlpha = opacity * 0.4;
                            this.ctx.shadowColor = 'rgba(255,255,255,0.8)';
                            this.ctx.shadowBlur = star.size * 3;
                            this.ctx.beginPath();
                            this.ctx.arc(star.x, star.y, star.size * 1.2, 0, Math.PI * 2);
                            this.ctx.fill();

                            // Outer glow for brighter stars
                            if (opacity > 0.6) {
                                this.ctx.globalAlpha = opacity * 0.2;
                                this.ctx.shadowBlur = star.size * 6;
                                this.ctx.beginPath();
                                this.ctx.arc(star.x, star.y, star.size * 2, 0, Math.PI * 2);
                                this.ctx.fill();
                            }

                            // Extra sparkle for very bright stars
                            if (opacity > 0.8 && randomGlow > 1.2) {
                                this.ctx.globalAlpha = (opacity - 0.8) * 0.3;
                                this.ctx.shadowBlur = star.size * 10;
                                this.ctx.shadowColor = 'rgba(200,220,255,0.6)';
                                this.ctx.beginPath();
                                this.ctx.arc(star.x, star.y, star.size * 3, 0, Math.PI * 2);
                                this.ctx.fill();
                            }

                            this.ctx.globalAlpha = 1;
                            this.ctx.shadowBlur = 0;
                        }
                    }
                });

                requestAnimationFrame((t) => this.animate(t));
            }

            destroy() {
                window.removeEventListener('resize', () => this.resize());
            }
        }

        // Initialize starfield
        let starField = null;

        // Global variables
        let webampInstance = null;
        let usesCustomSkin = true;
        let animationId = null;
        let eqIntervalId = null;
        let passwordUnlocked = false;
        let lastKnownPositions = null;

        // Deity sMessages System
        let deityMessageSystem = {
            // Song-specific messages based on track names
            songMessages: {
                "Gross Excelations": [
                    "Welcome",
                    "Stay a while",
                    "You will all be dusted"
                ],
                "Two Travelers": [
                    "The path climbs down to meet you",
                    "Behold the Skeletonized Chiff",
                    "Play Flute, And Die",
                    "Time to go!"
                ],
                "Chambers of the Starwatcher": [
                    "You look unwell",
                    "Gaze into my Glimmerless Ore",
                    "Drink the Light and live forever",
                    "Press Astral Glass to your eye",
                    "Watch your Constalation Drift",
                    "Increase your thirst"
                ],
                "Hibernal Torment": [
                    "Follow me",
                    "I'm right behind you",
                    "I can go no further here",
                    "You have the power",
                    "It's freezing down here",
                    "hearing sirens",
                    "We have to keep going",
                    "It's you in the tower"
                ],
                "Rats": [
                    "Welcome Piper",
                    "Welcome Rat",
                    "Step lightly, traveler",
                    "Dance through the screen",
                    "Rats follow you",
                    "Cheese if you please"
                ],
                "Entrusted to Fools": [
                    "It's just us now",
                    "Everyone else is gone",
                    "They left a long time ago",
                    "Its just us now",
                    "Riding the waves",
                    "On the Wrong Planet"
                ],
                "Spider Wash": [
                    "Keep counting",
                    "Follow the flame",
                    "Wheel grinding sounds",
                    "Did you hear that?",
                    "Keep counting?",
                    "Clean your web"
                ],
                "Crusted Aucklet": [
                    "Aaaaaah-eeee-yeeee!"
                ],
                "Ill Wind": [
                    "An ill wind blows on my spirit",
                    "I feel we will perish like dogs",
                    "Wander into Fultons Deep",
                    "I forgot to sleep"
                ],
                "Rippler": [
                    "Come get your jewel encrusted helmet bashed in",
                    "It'll be fun",
                    "Face the rippler",
                    "Trees on Us"
                ],
                "Sepulchral FLute": [
                    "Trust the crust",
                    "Flour sack lost",
                    "Trapped in a tree, no time to be me"
                ],
                "Taste of my Chime": [
                    "Mmmmm",
                    "Delicious metals",
                    "The Bells of Bodom toll",
                    "The sky lights linger",
                    "Taste the glow"
                ],
                "Bone Window": [
                    "The dust remembers you",
                    "Unfortunately, you're in the wrong place",
                    "The spiral brought you nowhere",
                    "But you can stay"
                ]
            },
            currentSongName: null,
            currentSongMessages: [],
            currentMessageIndex: 0,
            activeWindows: new Set(),
            nextMessageTimeout: null,
            windowCounter: 0,
            trackStartTime: null,
            currentTrackDuration: null,
            messageCount: 0,

            init() {
                // Note: Welcome message will be shown when first song starts
                // Messages will be scheduled when tracks change via onTrackChange()
            },

            onTrackChange(trackDuration, songName) {
                // Reset for new track
                this.trackStartTime = Date.now();
                this.currentTrackDuration = trackDuration || 180; // Default to 3 minutes if unknown
                this.messageCount = 0;
                this.currentMessageIndex = 0;
                
                // Set current song and get its messages
                this.currentSongName = songName;
                this.currentSongMessages = this.songMessages[songName] || [];
                
                console.log(`Track changed to: ${songName}, Messages available: ${this.currentSongMessages.length}`);

                // Clear existing timeout
                if (this.nextMessageTimeout) {
                    clearTimeout(this.nextMessageTimeout);
                }

                // Only schedule messages if we have messages for this song
                if (this.currentSongMessages.length > 0) {
                    // Schedule first message early in the track (within first 30-60 seconds)
                    const earlyMessageDelay = Math.random() * 30000 + 10000; // 10-40 seconds into track
                    setTimeout(() => {
                        this.showSongSpecificMessage();
                    }, earlyMessageDelay);

                    // Schedule remaining messages based on song duration
                    this.scheduleNextMessage();
                } else {
                    console.log(`No messages defined for song: ${songName}`);
                }
            },

            scheduleNextMessage() {
                // Only schedule if we have messages for the current song
                if (!this.currentSongMessages || this.currentSongMessages.length === 0) {
                    return;
                }

                // Calculate timing based on song duration and number of messages
                const totalMessages = this.currentSongMessages.length;
                const songDurationMs = this.currentTrackDuration * 1000;
                
                // Reserve first 40 seconds and last 20 seconds of the song
                const availableTimeMs = songDurationMs - 60000; // 60 seconds reserved
                
                if (availableTimeMs <= 0 || totalMessages <= 1) {
                    // Song too short or only one message, use random timing
                    const interval = Math.random() * 40000 + 20000; // 20-60 seconds
                    this.nextMessageTimeout = setTimeout(() => {
                        this.showSongSpecificMessage();
                        this.scheduleNextMessage();
                    }, interval);
                    return;
                }

                // Calculate time between messages (evenly spaced)
                const baseInterval = availableTimeMs / (totalMessages - 1);
                
                // Add some randomness (±25% of the base interval) to make it feel natural
                const randomVariation = (Math.random() - 0.5) * 0.5 * baseInterval;
                const interval = Math.max(15000, baseInterval + randomVariation); // Minimum 15 seconds between messages
                
                console.log(`Scheduling next message in ${Math.round(interval/1000)}s (${this.messageCount + 1}/${totalMessages})`);

                this.nextMessageTimeout = setTimeout(() => {
                    // Only show message if we haven't shown all messages for this song yet
                    if (this.messageCount < totalMessages) {
                        this.showSongSpecificMessage();
                        this.scheduleNextMessage();
                    } else {
                        console.log('All messages for this song have been shown');
                    }
                }, interval);
            },

            showSongSpecificMessage() {
                // Check if we have messages for the current song
                if (!this.currentSongMessages || this.currentSongMessages.length === 0) {
                    console.log('No messages available for current song');
                    return;
                }

                // Much stricter control over simultaneous messages - only 5% chance if one is already active
                if (this.activeWindows.size >= 1) {
                    // Only 5% chance to show a second message when one is already active
                    if (Math.random() > 0.05) {
                        return;
                    }
                }

                // Never allow more than 2 messages
                if (this.activeWindows.size >= 2) {
                    return;
                }

                // Get the next message in sequence for this song
                const message = this.currentSongMessages[this.currentMessageIndex];
                
                // Advance to next message, cycling back to start if we reach the end
                this.currentMessageIndex = (this.currentMessageIndex + 1) % this.currentSongMessages.length;
                
                console.log(`Showing message: "${message}" (${this.currentMessageIndex}/${this.currentSongMessages.length})`);

                const messageWindow = this.createMessageWindow(message);
                document.body.appendChild(messageWindow);

                // Position randomly on screen
                this.positionRandomly(messageWindow);

                // Add to active windows
                this.activeWindows.add(messageWindow);

                // Show with TV turn-on effect
                requestAnimationFrame(() => {
                    messageWindow.classList.add('appearing');
                });

                // Start typing animation after TV turn-on effect
                setTimeout(() => {
                    this.startTypingAnimation(messageWindow, message);
                }, 1200);

                // Increment message count
                this.messageCount++;

                // Don't schedule dismissal here - it will be scheduled after typing actually completes
            },

            createMessageWindow(message) {
                const window = document.createElement('div');
                window.className = 'deity-message-window';
                window.id = `deity-message-${++this.windowCounter}`;

                window.innerHTML = `
                    <div class="deity-message-top">
                        <div class="deity-close-button"></div>
                    </div>
                    <div class="deity-message-content">
                        <div class="scanlines"></div>
                        <div class="deity-message-text"><span class="typing-ellipses"></span></div>
                    </div>
                    <div class="deity-message-bottom"></div>
                `;

                // Make draggable
                this.makeDraggable(window);

                // Add click handler to close button (X area only)
                const closeButton = window.querySelector('.deity-close-button');
                closeButton.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent drag from triggering
                    this.dismissMessage(window);
                });

                return window;
            },

            calculateTypingDuration(message) {
                // Calculate realistic typing duration with variations
                const baseSpeed = 80; // Base milliseconds per character
                const speedVariation = 40; // Variation in speed
                const pauseChance = 0.15; // 15% chance of pause per character
                const avgPauseDuration = 200; // Average pause duration

                let totalDuration = 0;
                for (let i = 0; i < message.length; i++) {
                    // Random typing speed per character
                    const charSpeed = baseSpeed + (Math.random() * speedVariation - speedVariation / 2);
                    totalDuration += charSpeed;

                    // Random pauses (like real typing)
                    if (Math.random() < pauseChance) {
                        totalDuration += avgPauseDuration + (Math.random() * 300);
                    }

                    // Longer pauses after punctuation
                    if (message[i] === ',' || message[i] === ':') {
                        totalDuration += 150 + (Math.random() * 200);
                    }
                }

                return Math.max(2000, totalDuration); // Minimum 2 seconds
            },

            startTypingAnimation(messageWindow, message) {
                const textElement = messageWindow.querySelector('.deity-message-text');
                const ellipsesElement = messageWindow.querySelector('.typing-ellipses');

                // Clear any existing content and set up the structure
                textElement.innerHTML = '<span class="typed-text"></span>&nbsp;<span class="typing-ellipses show"></span>';
                const typedTextSpan = textElement.querySelector('.typed-text');
                const ellipses = textElement.querySelector('.typing-ellipses');

                // Start typing animation
                textElement.classList.add('typing');

                let currentIndex = 0;
                const characters = message.split('');

                const typeNextCharacter = () => {
                    if (currentIndex < characters.length) {
                        const char = characters[currentIndex];

                        // Create individual character span with subtle variations for broken feel
                        const charSpan = document.createElement('span');
                        charSpan.textContent = char;

                        // Add subtle random variations to make text feel more broken/distant
                        const variation = Math.random();
                        if (variation < 0.05) { // 5% chance for slight character variations
                            charSpan.style.opacity = '0.85';
                        } else if (variation < 0.1) { // Another 5% for slight position shift
                            charSpan.style.transform = `translateY(${Math.random() * 0.5 - 0.25}px)`;
                        } else if (variation < 0.15) { // Another 5% for slight scaling
                            charSpan.style.transform = `scale(${0.95 + Math.random() * 0.1})`;
                        }

                        typedTextSpan.appendChild(charSpan);
                        currentIndex++;

                        // Calculate delay for next character
                        let delay = 60 + Math.random() * 40; // Base delay with variation

                        // Random pauses for more broken/stuttering effect
                        if (Math.random() < 0.18) { // Slightly more frequent pauses
                            delay += 200 + Math.random() * 400; // Longer pauses occasionally
                        }

                        // Longer pauses after punctuation
                        if (characters[currentIndex - 1] === ',' || characters[currentIndex - 1] === ':') {
                            delay += 150 + Math.random() * 200;
                        }

                        setTimeout(typeNextCharacter, delay);
                    } else {
                        // Typing completed - schedule dismissal 2-5 seconds from now
                        const readingTime = 2000 + Math.random() * 3000; // 2-5 seconds after typing completes
                        setTimeout(() => {
                            this.dismissMessage(messageWindow);
                        }, readingTime);

                        // Store reference to ellipses for cleanup in dismissMessage
                        messageWindow.ellipsesElement = ellipses;
                    }
                };

                // Add a longer, randomized pause before typing begins
                // Base delay of 1.2s (current TV turn-on effect) + random delay between 0.8s and 3.2s
                const initialDelay = 1200 + Math.random() * 2400;
                setTimeout(typeNextCharacter, initialDelay);
            },

            positionRandomly(element) {
                const margin = 50;

                // Ensure we have valid dimensions
                const elementWidth = 315; // Updated to match new scaled width
                const elementHeight = 120; // Estimated height

                // Check if we're on mobile
                const isMobileCheck = window.innerWidth <= 768;

                if (isMobileCheck) {
                    // Mobile: Always center the message like a text message
                    const screenWidth = window.innerWidth;
                    const screenHeight = window.innerHeight;

                    // Center horizontally, position in upper half to avoid webamp
                    const x = (screenWidth - elementWidth) / 2;
                    const y = (screenHeight * 0.3); // Position in upper 30% of screen

                    element.style.left = Math.max(10, x) + 'px';
                    element.style.top = Math.max(50, y) + 'px';
                } else {
                    // Desktop: Use the original right-third positioning
                    // Calculate the right third of the screen
                    const screenWidth = window.innerWidth;
                    const rightThirdStart = screenWidth * (2 / 3); // Start at 2/3 of screen width
                    const rightThirdWidth = screenWidth * (1 / 3); // Right third width

                    // Calculate the middle third of the right column (vertically)
                    const screenHeight = window.innerHeight;
                    const middleThirdStart = screenHeight * (1 / 3); // Start at 1/3 of screen height
                    const middleThirdHeight = screenHeight * (1 / 3); // Middle third height

                    // Calculate available area within the restricted zone
                    const availableWidth = rightThirdWidth - elementWidth - margin;
                    const availableHeight = middleThirdHeight - elementHeight - margin;

                    // Ensure we have enough space
                    if (availableWidth < 0 || availableHeight < 0) {
                        // Fallback to center of the restricted area if element is too large
                        const x = rightThirdStart + (rightThirdWidth - elementWidth) / 2;
                        const y = middleThirdStart + (middleThirdHeight - elementHeight) / 2;
                        element.style.left = x + 'px';
                        element.style.top = y + 'px';
                    } else {
                        // Random position within the restricted zone
                        const x = rightThirdStart + margin + Math.random() * availableWidth;
                        const y = middleThirdStart + margin + Math.random() * availableHeight;

                        element.style.left = x + 'px';
                        element.style.top = y + 'px';
                    }
                }
            },

            makeDraggable(element) {
                let isDragging = false;
                let startX = 0;
                let startY = 0;
                let startLeft = 0;
                let startTop = 0;

                // Use the entire window as the drag handle (not just title bar since we removed it)
                element.addEventListener('mousedown', dragStart, { passive: false });
                document.addEventListener('mousemove', drag, { passive: false });
                document.addEventListener('mouseup', dragEnd, { passive: false });
                
                // Add touch support for mobile dragging
                element.addEventListener('touchstart', touchStart, { passive: false });
                document.addEventListener('touchmove', touchDrag, { passive: false });
                document.addEventListener('touchend', touchEnd, { passive: false });

                function dragStart(e) {
                    // Ignore if clicking on close button
                    if (e.target.closest('.deity-close-button')) {
                        return;
                    }

                    e.preventDefault();
                    e.stopPropagation();

                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;

                    // Get current position
                    const rect = element.getBoundingClientRect();
                    startLeft = rect.left;
                    startTop = rect.top;

                    element.style.cursor = 'grabbing';
                    element.style.zIndex = '1002'; // Bring to front while dragging
                }

                function drag(e) {
                    if (!isDragging) return;

                    e.preventDefault();
                    e.stopPropagation();

                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;

                    // Allow unrestricted movement
                    const newLeft = startLeft + deltaX;
                    const newTop = startTop + deltaY;

                    element.style.left = newLeft + 'px';
                    element.style.top = newTop + 'px';
                }

                function dragEnd(e) {
                    if (!isDragging) return;

                    isDragging = false;
                    element.style.cursor = 'move';
                    element.style.zIndex = '1001'; // Reset z-index
                }

                // Touch event functions for mobile support
                function touchStart(e) {
                    // Ignore if touching on close button
                    if (e.target.closest('.deity-close-button')) {
                        return;
                    }

                    e.preventDefault();
                    e.stopPropagation();

                    const touch = e.touches[0];
                    isDragging = true;
                    startX = touch.clientX;
                    startY = touch.clientY;

                    // Get current position
                    const rect = element.getBoundingClientRect();
                    startLeft = rect.left;
                    startTop = rect.top;

                    element.style.zIndex = '1002'; // Bring to front while dragging
                }

                function touchDrag(e) {
                    if (!isDragging) return;

                    e.preventDefault();
                    e.stopPropagation();

                    const touch = e.touches[0];
                    const deltaX = touch.clientX - startX;
                    const deltaY = touch.clientY - startY;

                    // Allow unrestricted movement
                    const newLeft = startLeft + deltaX;
                    const newTop = startTop + deltaY;

                    element.style.left = newLeft + 'px';
                    element.style.top = newTop + 'px';
                }

                function touchEnd(e) {
                    if (!isDragging) return;

                    isDragging = false;
                    element.style.zIndex = '1001'; // Reset z-index
                }

                // Prevent text selection during drag
                element.addEventListener('selectstart', (e) => {
                    if (isDragging) e.preventDefault();
                });
            },

            dismissMessage(messageWindow) {
                if (!this.activeWindows.has(messageWindow)) return;

                // Stop ellipses animation if it's running
                const ellipses = messageWindow.querySelector('.typing-ellipses');
                if (ellipses) {
                    ellipses.classList.remove('show');
                }

                // Remove from active set
                this.activeWindows.delete(messageWindow);

                // Add disappearing animation
                messageWindow.classList.remove('appearing');
                messageWindow.classList.add('disappearing');

                // Remove from DOM after animation
                setTimeout(() => {
                    if (messageWindow.parentNode) {
                        messageWindow.parentNode.removeChild(messageWindow);
                    }
                }, 800); // Match tvTurnOff animation duration
            },

            cleanup() {
                // Clear any pending timeouts
                if (this.nextMessageTimeout) {
                    clearTimeout(this.nextMessageTimeout);
                    this.nextMessageTimeout = null;
                }

                // Remove all active windows
                this.activeWindows.forEach(window => {
                    if (window.parentNode) {
                        window.parentNode.removeChild(window);
                    }
                });
                this.activeWindows.clear();

                // Reset song-specific properties
                this.currentSongName = null;
                this.currentSongMessages = [];
                this.currentMessageIndex = 0;
                this.messageCount = 0;
            }
        };

        // Remove animation toggle state since it's always on
        const MAIN_WINDOW_HEIGHT = 116;
        const EQ_WINDOW_HEIGHT = 116;

        // Function to convert binary data to base64
        async function fetchAndConvertToBase64(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Failed to fetch ${url}: ${response.status} ${response.statusText}`);
                }
                const blob = await response.blob();
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                console.error('Error fetching skin:', error);
                return null;
            }
        }

        // Function to preload an audio file and get its blob URL
        async function preloadAudioFile(url) {
            try {
                console.log('Preloading audio file:', url);
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout

                const response = await fetch(url, {
                    signal: controller.signal,
                    mode: 'cors'
                });
                clearTimeout(timeoutId);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const blob = await response.blob();
                const blobUrl = URL.createObjectURL(blob);
                console.log('Audio file preloaded successfully');
                return blobUrl;
            } catch (error) {
                console.error('Error preloading audio:', error);
                return url; // Fallback to original URL if fetch fails
            }
        }

        // Function to preload only the first track and video for initial load
        async function preloadFirstTrackOnly() {
            console.log('Preloading first track only...');

            try {
                // Preload first audio track
                const firstTrack = tracksData[0];
                let firstTrackBlobUrl;

                try {
                    firstTrackBlobUrl = await preloadAudioFile(firstTrack.url);
                } catch (error) {
                    console.error('Error preloading first audio track:', error);
                    firstTrackBlobUrl = firstTrack.url; // Fallback to original URL
                }

                // Preload first video (skip on mobile for performance)
                if (!isMobile() && trackBackgrounds[0] && !trackBackgrounds[0].preloadedVideo) {
                    try {
                        await preloadVideoOnDemand(0);
                    } catch (error) {
                        console.error('Error preloading first video:', error);
                        // Continue without video
                    }
                }

                // Create tracks array with first track preloaded, others as placeholders
                const tracks = tracksData.map((track, index) => {
                    if (index === 0) {
                        return {
                            ...track,
                            url: firstTrackBlobUrl,
                            blob: firstTrackBlobUrl !== firstTrack.url
                        };
                    } else {
                        return { ...track }; // Keep original URL for now
                    }
                });

                window.preloadedTracks = tracks;
                console.log('First track preloaded successfully');
                return tracks;
            } catch (error) {
                console.error('Error in preloadFirstTrackOnly:', error);
                // Fallback: return tracks with original URLs
                const tracks = tracksData.map(track => ({ ...track }));
                window.preloadedTracks = tracks;
                return tracks;
            }
        }

        // Function to preload remaining tracks in background after password validation
        async function preloadRemainingTracks() {
            console.log('Preloading remaining tracks in background...');

            if (!window.preloadedTracks) return;

            // Preload remaining audio tracks one by one to avoid overwhelming the browser
            const preloadTrack = async (index) => {
                try {
                    const blobUrl = await preloadAudioFile(tracksData[index].url);
                    window.preloadedTracks[index] = {
                        ...tracksData[index],
                        url: blobUrl,
                        blob: true
                    };
                    console.log(`Track ${index + 1} preloaded and ready`);
                } catch (error) {
                    console.error(`Error preloading track ${index + 1}:`, error);
                }
            };

            // Preload tracks in small batches to avoid blocking
            for (let i = 1; i < tracksData.length; i++) {
                setTimeout(() => preloadTrack(i), (i - 1) * 1000); // Stagger by 1 second each
            }

            // Preload remaining videos in batches
            setTimeout(() => {
                console.log('Starting background video preloading...');
                for (let i = 1; i <= 4; i++) {
                    if (trackBackgrounds[i] && !trackBackgrounds[i].preloadedVideo) {
                        preloadVideoOnDemand(i);
                    }
                }
            }, 3000); // Start after 3 seconds

            setTimeout(() => {
                for (let i = 5; i < Object.keys(trackBackgrounds).length; i++) {
                    if (trackBackgrounds[i] && !trackBackgrounds[i].preloadedVideo) {
                        preloadVideoOnDemand(i);
                    }
                }
            }, 8000); // Start after 8 seconds

            console.log('Background preloading initiated');
        }

        // Define the music files with their metadata - exact file names from the directory
        const tracksData = [
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753891932/01_Gross_Excalations_v3.mp3",
                defaultName: "Gross Excelations",
                duration: 68.784,
                metaData: {
                    title: "Gross Excelations"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753891952/02_Two_Travelers_v3.mp3",
                defaultName: "Two Travelers",
                duration: 208.152,
                metaData: {
                    title: "Two Travelers"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753891962/03_Chambers_of_the_Starwatcher_v3.mp3",
                defaultName: "Chambers of the Starwatcher",
                duration: 218.5665,
                metaData: {
                    title: "Chambers of the Starwatcher"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753891972/04_Hibernal_Torment_v3.mp3",
                defaultName: "Hibernal Torment",
                duration: 216,
                metaData: {
                    title: "Hibernal Torment"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753892009/05_Rats_v3.mp3",
                defaultName: "Rats",
                duration: 233.64,
                metaData: {
                    title: "Rats"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753892029/06_Entrusted_to_Fools_v3.mp3",
                defaultName: "Entrusted to Fools",
                duration: 196.008,
                metaData: {
                    title: "Entrusted to Fools"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753892049/07_Heavy_Load_v3.mp3",
                defaultName: "Crusted Aucklet",
                duration: 192,
                metaData: {
                    title: "Crusted Aucklet"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753893189/08_Crusted_Aucklet_v3.mp3",
                defaultName: "Astral Crumb",
                duration: 71.016,
                metaData: {
                    title: "Astral Crumb"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753893209/09_Ill_Wind_v3.mp3",
                defaultName: "Ill Wind",
                duration: 216,
                metaData: {
                    title: "Ill Wind"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753893229/10_Breadmaker_v3.mp3",
                defaultName: "Breadmaker",
                duration: 193.824,
                metaData: {
                    title: "Breadmaker"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753893249/11_Doom_Fruit_v3.mp3",
                defaultName: "Sepulchral Flute",
                duration: 210,
                metaData: {
                    title: "Sepulchral Flute"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753894796/12_Taste_of_my_Chime_v3.mp3",
                defaultName: "Taste of my Chime",
                duration: 138,
                metaData: {
                    title: "Taste of my Chime"
                }
            },
            {
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753894816/13_Bone_Window_v3.mp3",
                defaultName: "Bone Window",
                duration: 141.648,
                metaData: {
                    title: "Bone Window"
                }
            }
        ];

        // Background configuration for each track - videos for both background and viewer
        const trackBackgrounds = {
            0: {  // Track 1 - Gross Excelations
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1749153489/01Loop.mp4",
                preloadedVideo: null,
                fadeIn: 10,    // 2 seconds fade in
                fadeOut: 0     // no fade out
            },
            1: {  // Track 2 - Two Travelers
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1749153493/02Loop.mp4",
                preloadedVideo: null,
                fadeIn: 0,   // 1.5 seconds fade in
                fadeOut: 0   // no fade out
            },
            2: {  // Track 3 - Chambers of the Starwatcher
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1753886697/social_newagehardcore_The_camera_orbits_spinning_fast_and_smooth_to__3de233b4-aab7-4e61-8365-310146edce3c_1_ejgjy2.mp4",
                preloadedVideo: null,
                fadeIn: 2,     // 2 seconds fade in
                fadeOut: 0   // no fade out
            },
            3: {  // Track 4 - Hibernal Torment
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1757004490/StairsUpdate_ei1iud.mp4",
                preloadedVideo: null,
                fadeIn: 0,     // 1 second fade in
                fadeOut: 0   // no fade out
            },
            4: {  // Track 5 - Rats
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1757004481/HandUpdate_xhowck.mp4",
                preloadedVideo: null,
                fadeIn: 1,     // 1 second fade in
                fadeOut: 0     // no fade out
            },
            5: {  // Track 6 - Entrusted to Fools
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1752626056/05Loop_afjott.mp4",
                preloadedVideo: null,
                fadeIn: 4,     // 2 seconds fade in
                fadeOut: 0     // no fade out
            },
            6: {  // Track 7 - Astral Crumb
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1749153521/07Loop.mp4",
                preloadedVideo: null,
                fadeIn: 1.5,     // 1.5 seconds fade in
                fadeOut: 0     // no fade out
            },
            7: {  // Track 8 - Crusted Auklet
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1751073675/08Loop_nmgkgh.mp4",
                preloadedVideo: null,
                fadeIn: 4,     // 4 seconds fade in
                fadeOut: 4     // 4 seconds fade out
            },
            8: {  // Track 9 - Ill Wind
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1749153526/09Loop.mp4",
                preloadedVideo: null,
                fadeIn: .5,     // 1.5 seconds fade in
                fadeOut: 0     // no fade out
            },
            9: {  // Track 10 - Breadmaker
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1749267106/10Loop_jcbrof.mp4",
                preloadedVideo: null,
                fadeIn: 4,     // 1 second fade in
                fadeOut: 0     // no fade out
            },
            10: {  // Track 11 - Sepulchral Flute
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1751074687/12Loop_twje5h.mp4",
                preloadedVideo: null,
                fadeIn: 1.5,     // 1.5 seconds fade in
                fadeOut: 0     // no fade out
            },
            11: {  // Track 12 - Taste of my Chime
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1755467433/Fireflies_pzdsfx.mp4",
                preloadedVideo: null,
                fadeIn: 2,     // 2 seconds fade in
                fadeOut: 0     // no fade out
            },
            12: {  // Track 13 - Bone Window
                url: "https://res.cloudinary.com/dtwix3ubl/video/upload/v1752626043/13Loop_jdubb9.mp4",
                preloadedVideo: null,
                fadeIn: 2,     // 2 seconds fade in
                fadeOut: 0     // no fade out
            }
        };

        // Function to set transition duration for an element
        function setTransitionDuration(element, duration) {
            // Remove transitions for instant changes
            element.style.transition = 'none';
        }

        // Function to initialize viewer system
        function initBackgroundSystem() {
            console.log('Initializing viewer system');

            // Make the viewer window draggable
            makeViewerDraggable();

            // Set up viewer buttons
            setupViewerControls();

            // Set up mobile lightbox functionality
            setupMobileLightbox();

            // Make the cover window draggable
            makeCoverDraggable();

            // Set up cover window controls
            setupCoverControls();
        }

        // Standard browser and device detection
        function getDeviceInfo() {
            const ua = navigator.userAgent;
            const platform = navigator.platform;
            
            // iOS detection using standard method (works for iOS 13+ iPad too)
            const isIOS = /iPad|iPhone|iPod/.test(platform) || 
                         (platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            
            // iPhone specific detection
            const isIPhone = /iPhone/.test(platform) || 
                           (/iPhone/.test(ua) && isIOS);
            
            // Browser detection for iOS devices
            const isIOSSafari = isIOS && /Safari/.test(ua) && !/CriOS|Chrome/.test(ua);
            const isIOSChrome = isIOS && (/CriOS/.test(ua) || /Chrome/.test(ua));
            
            // General mobile detection
            const isMobile = window.innerWidth <= 768 || isIOS || /Android/i.test(ua);
            
            return {
                isIOS,
                isIPhone,
                isIOSSafari,
                isIOSChrome,
                isMobile,
                isAndroid: /Android/i.test(ua),
                isDesktop: !isMobile
            };
        }
        
        // Legacy function for compatibility
        function isMobile() {
            return getDeviceInfo().isMobile;
        }

        // Function to make the viewer window draggable
        function makeViewerDraggable() {
            const viewerWindow = document.getElementById('viewer-window');

            if (!viewerWindow) return; // Allow dragging on all devices including mobile

            let isDragging = false;
            let startX = 0;
            let startY = 0;
            let startLeft = 0;
            let startTop = 0;

            // Use the header as the drag handle
            const dragHandle = viewerWindow.querySelector('.viewer-header');

            if (dragHandle) {
                dragHandle.addEventListener('mousedown', dragStart, { passive: false });
                document.addEventListener('mousemove', drag, { passive: false });
                document.addEventListener('mouseup', dragEnd, { passive: false });
                
                // Add touch support for mobile dragging
                dragHandle.addEventListener('touchstart', touchStart, { passive: false });
                document.addEventListener('touchmove', touchDrag, { passive: false });
                document.addEventListener('touchend', touchEnd, { passive: false });
            }

            function dragStart(e) {
                // Ignore if clicking on buttons
                if (e.target.closest('.viewer-close-button')) {
                    return;
                }

                e.preventDefault();
                e.stopPropagation();

                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;

                // Get current position
                const rect = viewerWindow.getBoundingClientRect();
                startLeft = rect.left;
                startTop = rect.top;

                // Make sure transform is none for proper dragging
                if (viewerWindow.style.transform === 'translate(-50%, -50%)') {
                    viewerWindow.style.transform = 'none';

                    // Center it if first drag after initialization
                    const rect = viewerWindow.getBoundingClientRect();
                    viewerWindow.style.top = `${(window.innerHeight - rect.height) / 2}px`;
                    viewerWindow.style.left = `${(window.innerWidth - rect.width) / 2}px`;
                }

                dragHandle.style.cursor = 'grabbing';
                viewerWindow.style.zIndex = '6'; // Bring to front while dragging
            }

            function drag(e) {
                if (!isDragging) return;

                e.preventDefault();
                e.stopPropagation();

                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;

                let newLeft = startLeft + deltaX;
                let newTop = startTop + deltaY;

                // Constrain to screen bounds with some flexibility
                const rect = viewerWindow.getBoundingClientRect();
                const elementWidth = rect.width;
                const elementHeight = rect.height;

                // Allow more flexibility - only constrain when completely off-screen
                newLeft = Math.max(-elementWidth + 100, Math.min(window.innerWidth - 50, newLeft));
                newTop = Math.max(-50, Math.min(window.innerHeight - 50, newTop));

                viewerWindow.style.left = newLeft + 'px';
                viewerWindow.style.top = newTop + 'px';
            }

            function dragEnd(e) {
                if (!isDragging) return;

                isDragging = false;
                dragHandle.style.cursor = 'move';
                viewerWindow.style.zIndex = '5'; // Reset z-index
            }

            // Touch event functions for mobile support
            function touchStart(e) {
                // Ignore if touching on buttons
                if (e.target.closest('.viewer-close-button')) {
                    return;
                }

                e.preventDefault();
                e.stopPropagation();

                const touch = e.touches[0];
                isDragging = true;
                startX = touch.clientX;
                startY = touch.clientY;

                // Get current position
                const rect = viewerWindow.getBoundingClientRect();
                startLeft = rect.left;
                startTop = rect.top;

                // Make sure transform is none for proper dragging
                if (viewerWindow.style.transform === 'translate(-50%, -50%)') {
                    viewerWindow.style.transform = 'none';

                    // Center it if first drag after initialization
                    const rect = viewerWindow.getBoundingClientRect();
                    viewerWindow.style.top = `${(window.innerHeight - rect.height) / 2}px`;
                    viewerWindow.style.left = `${(window.innerWidth - rect.width) / 2}px`;
                }

                viewerWindow.style.zIndex = '6'; // Bring to front while dragging
            }

            function touchDrag(e) {
                if (!isDragging) return;

                e.preventDefault();
                e.stopPropagation();

                const touch = e.touches[0];
                const deltaX = touch.clientX - startX;
                const deltaY = touch.clientY - startY;

                let newLeft = startLeft + deltaX;
                let newTop = startTop + deltaY;

                // Constrain to screen bounds with some flexibility
                const rect = viewerWindow.getBoundingClientRect();
                const elementWidth = rect.width;
                const elementHeight = rect.height;

                // Allow more flexibility - only constrain when completely off-screen
                newLeft = Math.max(-elementWidth + 100, Math.min(window.innerWidth - 50, newLeft));
                newTop = Math.max(-50, Math.min(window.innerHeight - 50, newTop));

                viewerWindow.style.left = newLeft + 'px';
                viewerWindow.style.top = newTop + 'px';
            }

            function touchEnd(e) {
                if (!isDragging) return;

                isDragging = false;
                viewerWindow.style.zIndex = '5'; // Reset z-index
            }

            // Prevent text selection during drag
            viewerWindow.addEventListener('selectstart', (e) => {
                if (isDragging) e.preventDefault();
            });
        }

        // Optimized lazy loading function - only preload first video initially
        function preloadBackgroundsLazy() {
            const preloadProgress = {
                total: Object.keys(trackBackgrounds).length,
                loaded: 0,
                failed: 0
            };

            const preloadManager = {
                onProgress: null,
                onComplete: null
            };

            // Mobile optimization - load only first video on mobile for performance
            if (isMobile()) {
                console.log('Mobile detected - loading only first video for performance');
                // Still load the first video on mobile, but skip the rest
                async function preloadFirstVideoMobile() {
                    try {
                        const firstBackground = trackBackgrounds[0];
                        if (firstBackground) {
                            const video = document.createElement('video');
                            video.src = firstBackground.url;
                            video.muted = true;
                            video.playsInline = true;
                            video.loop = true;
                            video.preload = 'metadata'; // Use metadata instead of auto for mobile

                            video.onloadeddata = () => {
                                firstBackground.preloadedVideo = video;
                                console.log('First video preloaded on mobile');
                                if (preloadManager.onComplete) {
                                    preloadManager.onComplete({
                                        successCount: 1,
                                        total: 1,
                                        failed: 0
                                    });
                                }
                            };

                            video.onerror = () => {
                                console.log('Mobile video preload failed, continuing anyway');
                                if (preloadManager.onComplete) {
                                    preloadManager.onComplete({
                                        successCount: 0,
                                        total: 1,
                                        failed: 1
                                    });
                                }
                            };

                            video.load();
                        }
                    } catch (error) {
                        console.log('Mobile video preload error, continuing anyway');
                    }
                }

                preloadFirstVideoMobile();
                return preloadManager;
            }

            // Load only the first video immediately on desktop, others on demand
            async function preloadFirstVideo() {
                try {
                    const firstBackground = trackBackgrounds[0];
                    if (firstBackground) {
                        const video = document.createElement('video');
                        video.src = firstBackground.url;
                        video.muted = true;
                        video.playsInline = true;
                        video.loop = true;
                        video.preload = 'auto';

                        video.onloadeddata = () => {
                            firstBackground.preloadedVideo = video;
                            preloadProgress.loaded++;
                            console.log('First video preloaded successfully');

                            if (preloadManager.onComplete) {
                                preloadManager.onComplete({
                                    successCount: 1,
                                    total: 1,
                                    failed: 0
                                });
                            }
                        };

                        video.onerror = () => {
                            preloadProgress.failed++;
                            console.error('Error preloading first video');

                            if (preloadManager.onComplete) {
                                preloadManager.onComplete({
                                    successCount: 0,
                                    total: 1,
                                    failed: 1
                                });
                            }
                        };

                        video.load();
                    }
                } catch (error) {
                    console.error('Failed to preload first video:', error);
                }
            }

            // Start loading first video
            preloadFirstVideo();

            return preloadManager;
        }

        // Function to preload a specific video on demand
        function preloadVideoOnDemand(trackIndex) {
            const background = trackBackgrounds[trackIndex];
            if (!background || background.preloadedVideo) {
                return Promise.resolve(background?.preloadedVideo || null);
            }

            // Skip video preloading on mobile for performance
            if (isMobile()) {
                console.log(`Skipping video preload on mobile for track ${trackIndex}`);
                return Promise.resolve(null);
            }

            return new Promise((resolve) => {
                const video = document.createElement('video');
                video.src = background.url;
                video.muted = true;
                video.playsInline = true;
                video.loop = true;
                video.preload = 'metadata'; // Use metadata instead of auto for faster loading

                const timeout = setTimeout(() => {
                    console.log(`Video preload timeout for track ${trackIndex}`);
                    resolve(null);
                }, 8000); // 8 second timeout

                video.onloadeddata = () => {
                    clearTimeout(timeout);
                    background.preloadedVideo = video;
                    console.log(`On-demand video preloaded: ${trackIndex}`);
                    resolve(video);
                };

                video.onerror = () => {
                    clearTimeout(timeout);
                    console.error(`Error preloading video ${trackIndex}`);
                    resolve(null);
                };

                video.load();
            });
        }

        // Function to preload all background videos (original function for fallback)
        function preloadBackgrounds() {
            const preloadProgress = {
                total: Object.keys(trackBackgrounds).length,
                loaded: 0,
                failed: 0
            };

            // Create a preload manager
            const preloadManager = {
                onProgress: null,
                onComplete: null,
                onError: null
            };

            // Sequential preloading with delay
            async function preloadSequentially() {
                const entries = Object.entries(trackBackgrounds);

                for (const [index, background] of entries) {
                    try {
                        await new Promise((resolve, reject) => {
                            const video = document.createElement('video');
                            video.muted = true;
                            video.playsInline = true;
                            video.loop = true;
                            video.preload = 'auto';

                            // Track loading progress
                            video.addEventListener('progress', () => {
                                if (video.buffered.length > 0) {
                                    const bufferedEnd = video.buffered.end(video.buffered.length - 1);
                                    const duration = video.duration;
                                    if (duration > 0) {
                                        const progress = (bufferedEnd / duration) * 100;
                                        console.log(`Preloading video ${index}: ${progress.toFixed(1)}%`);
                                    }
                                }
                            });

                            video.onloadeddata = () => {
                                background.preloadedVideo = video;
                                preloadProgress.loaded++;
                                console.log(`Successfully preloaded video ${index}: ${background.url}`);

                                if (preloadManager.onProgress) {
                                    preloadManager.onProgress(preloadProgress);
                                }

                                resolve(video);
                            };

                            video.onerror = (error) => {
                                preloadProgress.failed++;
                                console.error(`Error preloading background ${index}:`, error);
                                console.log('Attempted to load:', background.url);

                                if (preloadManager.onProgress) {
                                    preloadManager.onProgress(preloadProgress);
                                }

                                reject(error);
                            };

                            video.src = background.url;
                        });

                        // Add a delay between video loads (1 second)
                        await new Promise(resolve => setTimeout(resolve, 1000));

                    } catch (error) {
                        console.error(`Failed to preload video ${index}:`, error);
                        // Continue with next video even if this one failed
                    }
                }

                // All videos processed
                const successCount = preloadProgress.loaded;
                console.log(`Preload complete. Successfully loaded ${successCount} of ${preloadProgress.total} videos`);

                if (preloadManager.onComplete) {
                    preloadManager.onComplete({
                        successCount,
                        total: preloadProgress.total,
                        failed: preloadProgress.failed
                    });
                }
            }

            // Start sequential preloading
            preloadSequentially();

            return preloadManager;
        }

        // Progressive background loading - load more videos in background (desktop only)
        function startProgressiveLoading() {
            // Skip progressive loading on mobile to save bandwidth and improve performance
            if (isMobile()) {
                console.log('Mobile detected - skipping progressive video loading');
                return;
            }

            // Load videos 2-5 after a short delay
            setTimeout(() => {
                for (let i = 1; i <= 4; i++) {
                    if (trackBackgrounds[i] && !trackBackgrounds[i].preloadedVideo) {
                        preloadVideoOnDemand(i);
                    }
                }
            }, 2000);

            // Load remaining videos after longer delay
            setTimeout(() => {
                for (let i = 5; i < Object.keys(trackBackgrounds).length; i++) {
                    if (trackBackgrounds[i] && !trackBackgrounds[i].preloadedVideo) {
                        preloadVideoOnDemand(i);
                    }
                }
            }, 5000);
        }

        // Remove duplicate DOMContentLoaded listener - handled in main initialization



        // Modified track change handler with detailed logging
        function handleTrackChange(trackInfo) {
            // Immediately handle track change
            requestAnimationFrame(() => {
                if (!trackInfo) return;

                // Update media session metadata for background playback
                if (window.updateMediaSessionMetadata) {
                    window.updateMediaSessionMetadata(trackInfo);
                }

                // Find the track index by matching the title
                let trackIndex = -1;

                // First try to match by URL if available
                if (trackInfo.url) {
                    trackIndex = tracksData.findIndex(track =>
                        track.url === trackInfo.url ||
                        track.url.endsWith(trackInfo.url)
                    );
                }

                // If URL matching failed, try title matching
                if (trackIndex === -1) {
                    trackIndex = tracksData.findIndex(track => {
                        // Try to match by title from metadata
                        if (trackInfo.metaData?.title && track.metaData?.title === trackInfo.metaData.title) {
                            return true;
                        }

                        // Try to match by defaultName
                        if (trackInfo.defaultName && track.defaultName === trackInfo.defaultName) {
                            return true;
                        }

                        // Try to match by filename
                        const trackFileName = track.url.split('/').pop();
                        const incomingFileName = (trackInfo.url || '').split('/').pop();
                        if (trackFileName === incomingFileName) {
                            return true;
                        }

                        return false;
                    });
                }

                // Get track duration and notify deity message system
                if (trackIndex !== -1) {
                    const trackData = tracksData[trackIndex];
                    const trackDuration = trackData?.duration || 180;
                    const songName = trackData?.metaData?.title || trackData?.defaultName || "Unknown";
                    
                    console.log(`Track change detected: ${songName} (index: ${trackIndex}, duration: ${trackDuration}s)`);
                    deityMessageSystem.onTrackChange(trackDuration, songName);

                    // Check if audio track needs to be loaded on demand
                    if (window.preloadedTracks && window.preloadedTracks[trackIndex] && !window.preloadedTracks[trackIndex].blob) {
                        console.log(`Loading audio for track ${trackIndex + 1} on demand...`);
                        preloadAudioFile(tracksData[trackIndex].url).then(blobUrl => {
                            window.preloadedTracks[trackIndex] = {
                                ...tracksData[trackIndex],
                                url: blobUrl,
                                blob: true
                            };
                            console.log(`Track ${trackIndex + 1} audio loaded on demand`);
                        }).catch(error => {
                            console.error(`Error loading track ${trackIndex + 1} on demand:`, error);
                        });
                    }

                    // Preload video on demand if not already loaded
                    if (trackBackgrounds[trackIndex] && !trackBackgrounds[trackIndex].preloadedVideo) {
                        preloadVideoOnDemand(trackIndex).then(() => {
                            console.log(`Video for track ${trackIndex} loaded on demand`);
                        });
                    }

                    if (trackBackgrounds[trackIndex]) {
                        switchBackground(trackIndex);
                    }
                }
            });
        }

        // Set up viewer controls
        function setupViewerControls() {
            const viewerWindow = document.getElementById('viewer-window');
            const closeButton = viewerWindow.querySelector('.viewer-close-button');
            const fullscreenBackgroundVideo = document.getElementById('fullscreen-background-video');

            // Close button - hides the viewer normally
            if (closeButton) {
                closeButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    viewerWindow.classList.remove('visible');
                });
            }

            // Double-click functionality for fullscreen toggle
            let isFullscreenMode = false;
            let clickTimeout = null;
            let clickCount = 0;

            function handleViewerDoubleClick(e) {
                // Don't trigger if clicking on buttons or resize handle
                if (e.target.closest('.viewer-close-button') || e.target.closest('.viewer-resize-handle')) {
                    return;
                }

                clickCount++;
                
                if (clickCount === 1) {
                    // Start timeout for double-click detection
                    clickTimeout = setTimeout(() => {
                        clickCount = 0;
                    }, 300); // 300ms window for double-click
                } else if (clickCount === 2) {
                    // Double-click detected
                    clearTimeout(clickTimeout);
                    clickCount = 0;
                    
                    toggleFullscreenMode();
                }
            }

            function toggleFullscreenMode() {
                if (!isFullscreenMode) {
                    // Enter fullscreen mode
                    enterFullscreenMode();
                } else {
                    // Exit fullscreen mode
                    exitFullscreenMode();
                }
                isFullscreenMode = !isFullscreenMode;
            }

            function enterFullscreenMode() {
                console.log('Entering fullscreen mode');
                
                // Get current video from viewer window
                const viewerVideo = viewerWindow.querySelector('.viewer-video');
                if (viewerVideo && viewerVideo.src) {
                    // Clone the video source to fullscreen background
                    fullscreenBackgroundVideo.src = viewerVideo.src;
                    fullscreenBackgroundVideo.currentTime = viewerVideo.currentTime;
                    
                    // Activate fullscreen background video with TV turn-on effect
                    fullscreenBackgroundVideo.classList.add('active', 'tv-appearing');
                    fullscreenBackgroundVideo.play().catch(err => {
                        console.error('Fullscreen video play failed:', err);
                    });
                    
                    // Remove TV effect after animation completes
                    setTimeout(() => {
                        fullscreenBackgroundVideo.classList.remove('tv-appearing');
                    }, 1200); // Match tvTurnOn duration
                }
                
                // Hide viewer window with TV turn-off effect
                viewerWindow.classList.add('tv-disappearing');
                
                // After TV turn-off completes, hide it completely
                setTimeout(() => {
                    viewerWindow.classList.add('fullscreen-mode');
                    viewerWindow.classList.remove('tv-disappearing');
                }, 800); // Match tvTurnOff duration
                
                // Hide album art window on mobile
                if (isMobile()) {
                    const coverWindow = document.getElementById('cover-window');
                    if (coverWindow) {
                        coverWindow.style.display = 'none';
                    }
                }
                
                // Hide Legendarium logo behind fullscreen video
                const legendariumLogo = document.getElementById('legendarium-logo-link');
                if (legendariumLogo) {
                    legendariumLogo.classList.add('hidden-behind-fullscreen');
                }
            }

            function exitFullscreenMode() {
                console.log('Exiting fullscreen mode');
                
                // Add TV turn-off effect to fullscreen background video
                fullscreenBackgroundVideo.classList.add('tv-disappearing');
                
                // After TV turn-off completes, hide fullscreen background video
                setTimeout(() => {
                    fullscreenBackgroundVideo.classList.remove('active', 'tv-disappearing');
                    fullscreenBackgroundVideo.pause();
                    fullscreenBackgroundVideo.src = '';
                }, 800); // Match tvTurnOff duration
                
                // Show viewer window with TV turn-on effect
                viewerWindow.classList.remove('fullscreen-mode');
                viewerWindow.classList.add('tv-appearing');
                
                // After TV turn-on completes, remove the animation class
                setTimeout(() => {
                    viewerWindow.classList.remove('tv-appearing');
                }, 1200); // Match tvTurnOn duration
                
                // Show album art window again on mobile
                if (isMobile()) {
                    const coverWindow = document.getElementById('cover-window');
                    if (coverWindow) {
                        coverWindow.style.display = 'flex';
                    }
                }
                
                // Show Legendarium logo again
                const legendariumLogo = document.getElementById('legendarium-logo-link');
                if (legendariumLogo) {
                    legendariumLogo.classList.remove('hidden-behind-fullscreen');
                }
            }

            // Add double-click event listener to viewer window
            viewerWindow.addEventListener('click', handleViewerDoubleClick);
            
            // Add double-click event listener to fullscreen background video for exit
            fullscreenBackgroundVideo.addEventListener('click', handleViewerDoubleClick);

            // Mobile touch support for double-tap
            if (isMobile()) {
                let touchTimeout = null;
                let touchCount = 0;
                
                function handleTouchEnd(e) {
                    // Don't trigger if touching buttons
                    if (e.target.closest('.viewer-close-button') || e.target.closest('.viewer-resize-handle')) {
                        return;
                    }
                    
                    touchCount++;
                    
                    if (touchCount === 1) {
                        touchTimeout = setTimeout(() => {
                            touchCount = 0;
                        }, 300);
                    } else if (touchCount === 2) {
                        clearTimeout(touchTimeout);
                        touchCount = 0;
                        e.preventDefault();
                        toggleFullscreenMode();
                    }
                }
                
                viewerWindow.addEventListener('touchend', handleTouchEnd, { passive: false });
                fullscreenBackgroundVideo.addEventListener('touchend', handleTouchEnd, { passive: false });
            }

            // Position the viewer window - mobile vs desktop
            requestAnimationFrame(() => {
                if (isMobile()) {
                    // Mobile: Fixed position at bottom-left, handled by CSS
                    // No need to set positions here, CSS handles it
                } else {
                    // Desktop: Fixed pixel size and position
                    viewerWindow.style.transform = 'none';
                    viewerWindow.style.width = '828px';
                    viewerWindow.style.height = '828px';
                    viewerWindow.style.top = '5%';
                    viewerWindow.style.left = '35%';
                }
            });

            // Make the viewer resizable manually in addition to native resize (skip on mobile)
            const resizeHandle = viewerWindow.querySelector('.viewer-resize-handle');
            if (resizeHandle && !isMobile()) {
                let isResizing = false;
                let startX, startY;
                let startWidth, startHeight;

                resizeHandle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    isResizing = true;
                    startX = e.clientX;
                    startY = e.clientY;

                    // Get the current dimensions
                    const rect = viewerWindow.getBoundingClientRect();
                    startWidth = rect.width;
                    startHeight = rect.height;

                    // When user starts resizing, remove the aspect-ratio constraint
                    viewerWindow.style.aspectRatio = 'unset';

                    // Add event listeners
                    document.addEventListener('mousemove', handleResize);
                    document.addEventListener('mouseup', stopResize);
                });

                function handleResize(e) {
                    if (!isResizing) return;

                    // Calculate new dimensions
                    const newWidth = startWidth + (e.clientX - startX);
                    const newHeight = startHeight + (e.clientY - startY);

                    // Allow any size, but maintain aspect ratio
                    const size = Math.max(newWidth, newHeight);

                    // Apply new dimensions
                    viewerWindow.style.width = `${size}px`;
                    viewerWindow.style.height = `${size}px`;
                }

                function stopResize() {
                    isResizing = false;
                    document.removeEventListener('mousemove', handleResize);
                    document.removeEventListener('mouseup', stopResize);
                }
            }
        }

        // Function to make the cover window draggable
        function makeCoverDraggable() {
            const coverWindow = document.getElementById('cover-window');

            if (!coverWindow) return; // Allow dragging on all devices including mobile

            let isDragging = false;
            let startX = 0;
            let startY = 0;
            let startLeft = 0;
            let startTop = 0;

            // Use the header as the drag handle
            const dragHandle = coverWindow.querySelector('.cover-header');

            if (dragHandle) {
                dragHandle.addEventListener('mousedown', dragStart, { passive: false });
                document.addEventListener('mousemove', drag, { passive: false });
                document.addEventListener('mouseup', dragEnd, { passive: false });
                
                // Add touch support for mobile dragging
                dragHandle.addEventListener('touchstart', touchStart, { passive: false });
                document.addEventListener('touchmove', touchDrag, { passive: false });
                document.addEventListener('touchend', touchEnd, { passive: false });
            }

            function dragStart(e) {
                // Ignore if clicking on buttons
                if (e.target.closest('.cover-close-button')) {
                    return;
                }

                e.preventDefault();
                e.stopPropagation();

                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;

                // Get current position
                const rect = coverWindow.getBoundingClientRect();
                startLeft = rect.left;
                startTop = rect.top;

                dragHandle.style.cursor = 'grabbing';
                coverWindow.style.zIndex = '6'; // Bring to front while dragging
            }

            function drag(e) {
                if (!isDragging) return;

                e.preventDefault();
                e.stopPropagation();

                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;

                let newLeft = startLeft + deltaX;
                let newTop = startTop + deltaY;

                // Constrain to screen bounds with some flexibility
                const rect = coverWindow.getBoundingClientRect();
                const elementWidth = rect.width;
                const elementHeight = rect.height;

                // Allow more flexibility - only constrain when completely off-screen
                newLeft = Math.max(-elementWidth + 100, Math.min(window.innerWidth - 50, newLeft));
                newTop = Math.max(-50, Math.min(window.innerHeight - 50, newTop));

                coverWindow.style.left = newLeft + 'px';
                coverWindow.style.top = newTop + 'px';
            }

            function dragEnd(e) {
                if (!isDragging) return;

                isDragging = false;
                dragHandle.style.cursor = 'move';
                coverWindow.style.zIndex = '5'; // Reset z-index
            }

            // Touch event functions for mobile support
            function touchStart(e) {
                // Ignore if touching on buttons
                if (e.target.closest('.cover-close-button')) {
                    return;
                }

                e.preventDefault();
                e.stopPropagation();

                const touch = e.touches[0];
                isDragging = true;
                startX = touch.clientX;
                startY = touch.clientY;

                // Get current position
                const rect = coverWindow.getBoundingClientRect();
                startLeft = rect.left;
                startTop = rect.top;

                coverWindow.style.zIndex = '6'; // Bring to front while dragging
            }

            function touchDrag(e) {
                if (!isDragging) return;

                e.preventDefault();
                e.stopPropagation();

                const touch = e.touches[0];
                const deltaX = touch.clientX - startX;
                const deltaY = touch.clientY - startY;

                let newLeft = startLeft + deltaX;
                let newTop = startTop + deltaY;

                // Constrain to screen bounds with some flexibility
                const rect = coverWindow.getBoundingClientRect();
                const elementWidth = rect.width;
                const elementHeight = rect.height;

                // Allow more flexibility - only constrain when completely off-screen
                newLeft = Math.max(-elementWidth + 100, Math.min(window.innerWidth - 50, newLeft));
                newTop = Math.max(-50, Math.min(window.innerHeight - 50, newTop));

                coverWindow.style.left = newLeft + 'px';
                coverWindow.style.top = newTop + 'px';
            }

            function touchEnd(e) {
                if (!isDragging) return;

                isDragging = false;
                coverWindow.style.zIndex = '5'; // Reset z-index
            }

            // Prevent text selection during drag
            coverWindow.addEventListener('selectstart', (e) => {
                if (isDragging) e.preventDefault();
            });
        }

        // Function to randomize mobile window positions
        function randomizeMobileWindowPositions() {
            if (!isMobile()) return;

            const viewerWindow = document.getElementById('viewer-window');
            const coverWindow = document.getElementById('cover-window');

            if (viewerWindow) {
                // Random position for viewer window
                const maxX = window.innerWidth - 220; // Account for window width + padding
                const maxY = window.innerHeight - 220; // Account for window height + padding
                const randomX = Math.random() * Math.max(0, maxX - 20) + 20; // 20px minimum from edge
                const randomY = Math.random() * Math.max(0, maxY - 20) + 20;

                viewerWindow.style.left = randomX + 'px';
                viewerWindow.style.top = randomY + 'px';
            }

            if (coverWindow) {
                // Random position for cover window (avoid overlap with viewer)
                const maxX = window.innerWidth - 200;
                const maxY = window.innerHeight - 220;
                const randomX = Math.random() * Math.max(0, maxX - 20) + 20;
                const randomY = Math.random() * Math.max(0, maxY - 20) + 20;

                coverWindow.style.left = randomX + 'px';
                coverWindow.style.top = randomY + 'px';
            }
        }

        // Set up mobile lightbox functionality
        function setupMobileLightbox() {
            if (!isMobile()) return;

            const viewerWindow = document.getElementById('viewer-window');
            const coverWindow = document.getElementById('cover-window');

            // Viewer lightbox
            if (viewerWindow) {
                viewerWindow.addEventListener('click', (e) => {
                    // Don't trigger if clicking on close button or resize handle
                    if (e.target.closest('.viewer-close-button') || e.target.closest('.viewer-resize-handle')) {
                        return;
                    }

                    if (viewerWindow.classList.contains('lightbox')) {
                        // Exit lightbox
                        viewerWindow.classList.remove('lightbox');
                    } else {
                        // Enter lightbox
                        viewerWindow.classList.add('lightbox');
                    }
                });
            }

            // Cover lightbox
            if (coverWindow) {
                coverWindow.addEventListener('click', (e) => {
                    // Don't trigger if clicking on close button or resize handle
                    if (e.target.closest('.cover-close-button') || e.target.closest('.cover-resize-handle')) {
                        return;
                    }

                    if (coverWindow.classList.contains('lightbox')) {
                        // Exit lightbox
                        coverWindow.classList.remove('lightbox');
                    } else {
                        // Enter lightbox
                        coverWindow.classList.add('lightbox');
                    }
                });
            }
        }

        // Set up cover window controls
        function setupCoverControls() {
            const coverWindow = document.getElementById('cover-window');
            const closeButton = coverWindow.querySelector('.cover-close-button');
            
            // Close button - hides the cover window
            if (closeButton) {
                closeButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    coverWindow.classList.remove('visible');
                });
            }
            
            // Position the cover window - mobile vs desktop
            requestAnimationFrame(() => {
                if (isMobile()) {
                    // Mobile: Fixed position at bottom-right, handled by CSS
                    // No need to set positions here, CSS handles it
                } else {
                    // Desktop: Position it near the equalizer window
                    const initialWidth = 300;
                    const initialHeight = 333; // Slightly rectangular for square image area
                    
                    // Convert vh to pixels for fixed positioning
                    const bottomPixels = Math.round(window.innerHeight * 0.15); // 15vh in pixels
                    
                    // Calculate position relative to window width
                    const rightOffset = Math.round(window.innerWidth * 0.15); // 15% from right
                    
                    // Set absolute pixel positions
                    coverWindow.style.position = 'fixed';
                    coverWindow.style.bottom = `${bottomPixels}px`;
                    coverWindow.style.width = `${initialWidth}px`;
                    coverWindow.style.height = `${initialHeight}px`;
                    coverWindow.style.top = 'auto';
                    coverWindow.style.left = 'auto';
                    
                    // Store initial position in data attributes for reference
                    coverWindow.dataset.initialBottom = bottomPixels;
                    coverWindow.dataset.initialRight = rightOffset;
                }
            });
            
            // Make the cover window resizable (skip on mobile)
            const resizeHandle = coverWindow.querySelector('.cover-resize-handle');
            if (resizeHandle && !isMobile()) {
                let isResizing = false;
                let startX, startY;
                let startWidth, startHeight;
                
                resizeHandle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    isResizing = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    
                    // Get the current dimensions
                    const rect = coverWindow.getBoundingClientRect();
                    startWidth = rect.width;
                    startHeight = rect.height;
                    
                    // When user starts resizing, remove the aspect-ratio constraint
                    coverWindow.style.aspectRatio = 'unset';
                    
                    // Add event listeners
                    document.addEventListener('mousemove', handleResize);
                    document.addEventListener('mouseup', stopResize);
                });
                
                function handleResize(e) {
                    if (!isResizing) return;
                    
                    // Calculate new dimensions
                    const newWidth = startWidth + (e.clientX - startX);
                    const newHeight = startHeight + (e.clientY - startY);
                    
                    // Maintain rectangular aspect ratio for cover window (width + 33px = height)
                    // Use the larger dimension to determine the size
                    const size = Math.max(newWidth, newHeight - 33);
                    
                    // Apply minimum size constraints
                    const finalWidth = Math.max(150, size);
                    const finalHeight = finalWidth + 33; // Keep rectangular ratio
                    
                    // Apply new dimensions
                    coverWindow.style.width = `${finalWidth}px`;
                    coverWindow.style.height = `${finalHeight}px`;
                }
                
                function stopResize() {
                    isResizing = false;
                    document.removeEventListener('mousemove', handleResize);
                    document.removeEventListener('mouseup', stopResize);
                }
            }
        }



        // Function to handle background transitions (now only handles viewer window videos)
        function switchBackground(trackIndex) {
            const viewerContainer = document.querySelector('.viewer-loop-container');
            const backgroundConfig = trackBackgrounds[trackIndex];

            if (!backgroundConfig) {
                console.warn('No background configuration for track index:', trackIndex);
                return;
            }

            console.log(`Switching viewer video for track ${trackIndex}: ${backgroundConfig.url}`);

            // Clear any existing content and timeouts
            if (window.bgTransitionTimeout) {
                clearTimeout(window.bgTransitionTimeout);
            }

            // Handle viewer video (clear version in viewer window)
            if (viewerContainer) {
                // Create new video or use preloaded one
                const newViewerVideo = backgroundConfig.preloadedVideo ?
                    backgroundConfig.preloadedVideo.cloneNode(true) :
                    document.createElement('video');

                if (!backgroundConfig.preloadedVideo) {
                    newViewerVideo.loop = true;
                    newViewerVideo.muted = true;
                    newViewerVideo.playsInline = true;
                    newViewerVideo.autoplay = true;
                    newViewerVideo.src = backgroundConfig.url;
                } else {
                    // Ensure loop property is set even for preloaded videos
                    newViewerVideo.loop = true;
                }

                newViewerVideo.className = 'viewer-video';
                newViewerVideo.style.objectFit = 'cover'; // Ensure cover is applied

                // Set initial state
                newViewerVideo.style.transition = 'none';
                newViewerVideo.style.opacity = '0';

                // Add error handling for video playback
                newViewerVideo.addEventListener('error', (e) => {
                    console.error('Viewer video playback error:', e);
                });

                const handleViewerVideoReady = () => {
                    // Replace viewer content first
                    viewerContainer.innerHTML = '';
                    viewerContainer.appendChild(newViewerVideo);

                    // Force reflow
                    void newViewerVideo.offsetHeight;

                    // Start playing after the video is in the DOM
                    requestAnimationFrame(() => {
                        newViewerVideo.play().catch(err => console.error("Viewer video play failed:", err));

                        // Fade in viewer video
                        newViewerVideo.style.transition = `opacity ${backgroundConfig.fadeIn}s ease-in`;
                        newViewerVideo.style.opacity = '1';

                        // Sync with fullscreen background video if active
                        const fullscreenBackgroundVideo = document.getElementById('fullscreen-background-video');
                        if (fullscreenBackgroundVideo && fullscreenBackgroundVideo.classList.contains('active')) {
                            console.log('Syncing fullscreen background video with new track');
                            fullscreenBackgroundVideo.src = backgroundConfig.url;
                            fullscreenBackgroundVideo.currentTime = newViewerVideo.currentTime;
                            fullscreenBackgroundVideo.play().catch(err => {
                                console.error('Fullscreen background video sync failed:', err);
                            });
                        }
                    });
                };

                // Handle video loading
                if (backgroundConfig.preloadedVideo) {
                    // If we have a preloaded video, use it immediately
                    handleViewerVideoReady();
                } else {
                    // Otherwise wait for the video to load
                    newViewerVideo.onloadeddata = handleViewerVideoReady;
                    newViewerVideo.onerror = (error) => {
                        console.error('Error loading viewer video:', error);
                        console.log('Attempted to load:', backgroundConfig.url);
                    };
                }
            }
        }

        // Function to center windows
        function centerWindows() {
            if (!webampInstance || !webampInstance.store) return;

            const zoomFactor = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--webamp-zoom'));
            const isMobile = window.innerWidth <= 768;

            // Position windows based on device type
            let posX, posY, eqY, playlistY;

            if (isMobile) {
                // Mobile: Simple positioning in starfield area
                const mainWindowWidth = 275;

                posX = Math.floor((window.innerWidth / zoomFactor - mainWindowWidth) / 2); // Center horizontally

                // Position at a fixed percentage of the available starfield space
                // Bottom squares take up 50vw, so starfield is roughly the top 50-70% of screen
                posY = Math.floor((window.innerHeight * 0.08) / zoomFactor); // Start at 8% from top

                eqY = posY + 116; // EQ window starts right after main window (but hidden)
                playlistY = posY + 116; // Playlist starts right after main window (skip EQ space)
            } else {
                // Desktop: Stack windows on the left side
                posX = Math.floor((window.innerWidth * 0.08) / zoomFactor); // 8% from left edge
                posY = Math.floor((window.innerHeight * 0.12) / zoomFactor); // 12% from top
                eqY = posY + 116; // EQ window starts right after main window
                playlistY = eqY + 116; // Playlist starts right after EQ window
            }

            // Store these positions for animation reference
            window.lastKnownPositions = isMobile ? {
                main: { x: posX, y: posY },
                equalizer: { x: posX, y: posY }, // Position EQ at same location as main (since it's hidden)
                playlist: { x: posX, y: playlistY }
            } : {
                main: { x: posX, y: posY },
                equalizer: { x: posX, y: eqY },
                playlist: { x: posX, y: playlistY }
            };

            // Update window positions
            webampInstance.store.dispatch({
                type: 'UPDATE_WINDOW_POSITIONS',
                positions: window.lastKnownPositions,
                absolute: true
            });
        }

        // Function to get current window positions
        function getCurrentWindowPositions() {
            const state = webampInstance.store.getState();
            const genWindows = state?.windows?.genWindows;

            if (!genWindows) return null;

            // Extract positions from the nested position objects
            const positions = {};
            Object.entries(genWindows).forEach(([windowId, window]) => {
                if (window?.position?.x != null && window?.position?.y != null) {
                    positions[windowId] = {
                        x: Math.round(window.position.x),
                        y: Math.round(window.position.y)
                    };
                }
            });

            return positions;
        }

        // Modified animation function to handle mouse interactions
        function startHauntedAnimation() {
            // Skip animation entirely on mobile
            if (isMobile()) {
                console.log('Skipping haunted animation on mobile');
                return;
            }

            // Clean up any existing animation
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            // Get initial positions
            const currentPositions = getCurrentWindowPositions();

            if (!currentPositions || Object.keys(currentPositions).length === 0) {
                console.error('Could not get window positions for animation');
                return;
            }

            // Use current positions as base positions
            let basePositions = { ...currentPositions };

            let time = 0;
            // Increase frame rate by increasing animation speed
            const ANIMATION_SPEED = 0.8;  // Slightly faster for more noticeable motion
            // Base radius that will be modified by audio
            const BASE_RADIUS = 4;    // Increased base radius for more noticeable movement
            const MAX_RADIUS = 60;    // Larger maximum radius for more dramatic swirls
            // Adjust the movement speed
            const OSCILLATION_FREQUENCY_MODIFIER = 0.001;  // Slightly faster oscillation

            // Add noise parameters for unpredictability
            const NOISE_AMPLITUDE = 0.15;  // Increased noise for more organic movement
            const NOISE_FREQUENCY = 0.002;  // Much slower noise for smoother transitions

            // Volume response curve parameters
            const VOLUME_THRESHOLD = 0.02;  // Lower threshold to be more responsive
            const VOLUME_POWER = 1.8;      // Gentler power curve for smoother response

            // Add secondary motion parameters
            const SECONDARY_FREQUENCY = 0.0012; // Secondary motion frequency
            const TERTIARY_FREQUENCY = 0.0015;  // Tertiary motion frequency

            // Track mouse interaction state
            let isInteracting = false;
            let lastVolume = 0;
            let volumeSmoothing = 0;
            const SMOOTHING_FACTOR = 0.03; // Even smoother transitions
            const VOLUME_SMOOTHING_FACTOR = 0.08; // Smoother volume changes

            // Add transition tracking
            let currentVolumeLevel = 0;
            let targetVolumeLevel = 0;
            let transitionStartPositions = null;
            let transitionStartTime = 0;
            let lastAnimationOffsets = { x: 0, y: 0 };
            const TRANSITION_DURATION = 800;

            function updateBasePositions() {
                const currentPositions = getCurrentWindowPositions();
                if (currentPositions) {
                    // Subtract current animation offsets to get true base positions
                    Object.entries(currentPositions).forEach(([windowId, pos]) => {
                        if (!basePositions[windowId]) basePositions[windowId] = { x: 0, y: 0 };
                        basePositions[windowId] = {
                            x: pos.x - lastAnimationOffsets.x,
                            y: pos.y - lastAnimationOffsets.y
                        };
                    });
                }
            }

            // Add mouse interaction handlers specifically for Webamp windows
            function setupMouseHandlers() {
                const webampElement = document.getElementById('webamp');
                if (!webampElement) return;

                // Function to check if the event target is a Webamp window or control
                const isWebampWindow = (element) => {
                    if (!element) return false;
                    return element.closest('.window') ||
                        element.closest('.title-bar') ||
                        element.closest('.dragger') ||
                        element.closest('.handle');
                };

                // Handle mousedown only on Webamp windows
                webampElement.addEventListener('mousedown', (e) => {
                    if (isWebampWindow(e.target)) {
                        isInteracting = true;
                        transitionStartPositions = null;
                        updateBasePositions();
                    }
                });

                // Handle mouseup globally to ensure we catch the release
                document.addEventListener('mouseup', () => {
                    if (isInteracting) {
                        isInteracting = false;
                        transitionStartPositions = getCurrentWindowPositions();
                        transitionStartTime = Date.now();
                        updateBasePositions();
                    }
                });

                // Handle mouseleave on the document
                document.addEventListener('mouseleave', () => {
                    if (isInteracting) {
                        isInteracting = false;
                        transitionStartPositions = getCurrentWindowPositions();
                        transitionStartTime = Date.now();
                        updateBasePositions();
                    }
                });
            }

            // Call setup after Webamp is initialized
            setupMouseHandlers();

            function getAudioLevel() {
                // Get the current state from Webamp
                const state = webampInstance.store.getState();
                const media = state?.media;

                if (!media) return 0;

                // Check if we're actually playing
                const isPlaying = media.status === "PLAYING" && !media.waiting;
                if (!isPlaying) {
                    targetVolumeLevel = 0;
                } else {
                    // Get the volume from the state and normalize it
                    const volume = state.media.volume || 0;
                    const normalizedVolume = volume / 100;

                    // Smoothly transition the target volume
                    targetVolumeLevel = normalizedVolume;
                }

                // Smoothly interpolate current volume towards target
                currentVolumeLevel += (targetVolumeLevel - currentVolumeLevel) * VOLUME_SMOOTHING_FACTOR;

                // Apply volume threshold
                let scaledVolume = 0;
                if (currentVolumeLevel > VOLUME_THRESHOLD) {
                    // Scale the volume to the range above threshold, with smooth interpolation
                    const volumeAboveThreshold = (currentVolumeLevel - VOLUME_THRESHOLD) / (1 - VOLUME_THRESHOLD);
                    // Apply gentler power curve with smoothing
                    scaledVolume = Math.pow(volumeAboveThreshold, 2); // Use a gentler power curve
                }

                // Apply very gentle cosine modulation for organic movement
                const baseMovement = Math.abs(Math.cos(time * 0.05)); // Slowed down cosine
                const targetVolume = Math.max(0.1, scaledVolume * (0.8 + 0.2 * baseMovement)); // Ensure minimum movement

                // Apply final smoothing
                volumeSmoothing = volumeSmoothing + (targetVolume - volumeSmoothing) * SMOOTHING_FACTOR;

                // Log values periodically
                if (Math.random() < 0.01) {
                    const baseMovement = Math.abs(Math.cos(time * 0.05)); // Slowed down cosine
                    const targetVolume = Math.max(0.1, scaledVolume * (0.8 + 0.2 * baseMovement)); // Ensure minimum movement

                    // Apply final smoothing
                    volumeSmoothing = volumeSmoothing + (targetVolume - volumeSmoothing) * SMOOTHING_FACTOR;
                }

                return Math.max(0.1, volumeSmoothing); // Ensure minimum return value for base movement
            }

            // Easing function for smooth transitions
            function easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }

            // Function to update shadow based on volume
            function updateShadowEffect(audioLevel) {
                if (!webampInstance) return;

                const windows = document.querySelectorAll('#webamp .window');
                if (!windows.length) return;

                // Remove shadow from Webamp windows
                windows.forEach(window => {
                    window.classList.add('dynamic-shadow');
                    window.style.filter = 'none'; // Remove shadow filter
                });

                // Keep shadow only for deity message windows
                const deityWindows = document.querySelectorAll('.deity-message-window');
                deityWindows.forEach(window => {
                    // Calculate dynamic values for deity windows only
                    const time = Date.now() * 0.001;
                    const rotationSpeed = 0.5 + (audioLevel * 2);
                    const angle = time * rotationSpeed;

                    const baseOffset = 4;
                    const baseBlur = 4;
                    const baseSpread = 8;

                    const intensityMultiplier = 1 + (audioLevel * 3);
                    const spreadMultiplier = 1 + (audioLevel * 4);

                    const xOffset = Math.cos(angle) * baseOffset * intensityMultiplier;
                    const yOffset = Math.sin(angle) * baseOffset * intensityMultiplier;

                    const blur1 = baseBlur * (1 + audioLevel);
                    const blur2 = baseBlur * 2 * (1 + audioLevel);
                    const spread1 = baseSpread * (1 + audioLevel * 2);
                    const spread2 = baseSpread * 2 * (1 + audioLevel * 2);

                    const pulseIntensity = audioLevel * 0.3;
                    const pulse = 1 + Math.sin(time * 4) * pulseIntensity;

                    const shadowFilter = `
                        drop-shadow(${xOffset * pulse}px ${yOffset * pulse}px ${blur1}px rgba(0, 0, 0, 0.95))
                        drop-shadow(${xOffset * 1.5 * pulse}px ${yOffset * 1.5 * pulse}px ${blur2}px rgba(0, 0, 0, 0.85))
                        drop-shadow(${xOffset * 2 * pulse}px ${yOffset * 2 * pulse}px ${spread1}px rgba(0, 0, 0, 0.75))
                        drop-shadow(${xOffset * 2.5 * pulse}px ${yOffset * 2.5 * pulse}px ${spread2}px rgba(0, 0, 0, 0.65))
                    `;

                    window.style.filter = shadowFilter;
                });
            }

            function animate() {
                // Exit immediately if on mobile
                if (isMobile()) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                    return;
                }

                if (!webampInstance?.store) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                    return;
                }

                // Handle animation and transitions
                if (!isInteracting) {
                    time += ANIMATION_SPEED;

                    // Get current audio level and calculate radius with smooth interpolation
                    const audioLevel = getAudioLevel();

                    // Update the shadow effect
                    updateShadowEffect(audioLevel);

                    // Get current audio level and calculate radius with smooth interpolation
                    const targetRadius = BASE_RADIUS + (audioLevel * MAX_RADIUS);

                    // Create multiple layers of motion
                    const primaryMotion = {
                        x: Math.sin(time * OSCILLATION_FREQUENCY_MODIFIER),
                        y: Math.cos(time * OSCILLATION_FREQUENCY_MODIFIER * 0.9)
                    };

                    const secondaryMotion = {
                        x: Math.sin(time * SECONDARY_FREQUENCY * 1.1) * 0.3,
                        y: Math.cos(time * SECONDARY_FREQUENCY * 0.8) * 0.3
                    };

                    const tertiaryMotion = {
                        x: Math.sin(time * TERTIARY_FREQUENCY * 1.2) * 0.2,
                        y: Math.cos(time * TERTIARY_FREQUENCY * 1.3) * 0.2
                    };

                    // Combine motions with different weights based on audio level
                    const combinedMotion = {
                        x: primaryMotion.x + (secondaryMotion.x + tertiaryMotion.x) * (1 + audioLevel),
                        y: primaryMotion.y + (secondaryMotion.y + tertiaryMotion.y) * (1 + audioLevel)
                    };

                    // Add smooth noise variation
                    const timeScale = 1 + (audioLevel * 0.5);
                    const noiseX = Math.sin(time * NOISE_FREQUENCY * 1.1) * NOISE_AMPLITUDE * (1 + audioLevel * 2);
                    const noiseY = Math.cos(time * NOISE_FREQUENCY * 0.9) * NOISE_AMPLITUDE * (1 + audioLevel * 2);

                    // Calculate final position with smooth easing
                    const easeInOut = (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                    const ease = easeInOut(Math.abs(Math.sin(time * 0.0005)));

                    // Calculate animation offsets
                    const xOffset = (combinedMotion.x * targetRadius * ease + noiseX) * timeScale;
                    const yOffset = (combinedMotion.y * targetRadius * ease + noiseY) * timeScale;

                    // Store last animation offsets
                    lastAnimationOffsets = { x: xOffset, y: yOffset };

                    // Handle transition if we just released the window
                    let transitionProgress = 1;
                    if (transitionStartPositions && Date.now() - transitionStartTime < TRANSITION_DURATION) {
                        transitionProgress = easeOutCubic((Date.now() - transitionStartTime) / TRANSITION_DURATION);
                    } else {
                        transitionStartPositions = null;
                    }

                    // Create new positions object with transition handling
                    const newPositions = {};
                    Object.entries(basePositions).forEach(([windowId, basePos]) => {
                        if (transitionStartPositions && transitionStartPositions[windowId]) {
                            // Interpolate between release position and animated position
                            const startPos = transitionStartPositions[windowId];
                            const animatedPos = {
                                x: basePos.x + xOffset,
                                y: basePos.y + yOffset
                            };
                            newPositions[windowId] = {
                                x: startPos.x + (animatedPos.x - startPos.x) * transitionProgress,
                                y: startPos.y + (animatedPos.y - startPos.y) * transitionProgress
                            };
                        } else {
                            newPositions[windowId] = {
                                x: basePos.x + xOffset,
                                y: basePos.y + yOffset
                            };
                        }
                    });

                    // Update all windows at once
                    webampInstance.store.dispatch({
                        type: 'UPDATE_WINDOW_POSITIONS',
                        positions: newPositions,
                        absolute: true
                    });
                }

                animationId = requestAnimationFrame(animate);
            }

            animationId = requestAnimationFrame(animate);
        }

        // Main function to initialize Webamp
        async function initWebamp() {
            try {
                console.log('Starting Webamp initialization...');

                // Clean up any previous instances
                cleanup();

                // Remove animation toggle button initialization
                window.basePositions = null;

                // Add transition styles
                const styleSheet = document.createElement('style');
                styleSheet.textContent = `
                    #webamp-container {
                        opacity: 0;
                        transition: opacity 1s ease-in-out;
                    }
                    #webamp {
                        zoom: var(--webamp-zoom) !important;
                        -moz-transform: scale(var(--webamp-zoom));
                        -moz-transform-origin: top left;
                    }
                    .webamp-region {
                        transition: all 0.3s ease-out;
                    }
                `;
                document.head.appendChild(styleSheet);

                // Get the custom skin if needed
                let skinOption = undefined;

                if (usesCustomSkin) {
                    try {
                        const skinUrl = "./assets/skins/GKSkin.wsz";
                        const skinBase64 = await fetchAndConvertToBase64(skinUrl);

                        if (skinBase64) {
                            skinOption = {
                                url: `data:application/zip;base64,${skinBase64}`
                            };
                        }
                    } catch (error) {
                        console.error('Error loading custom skin:', error);
                        // Continue without custom skin
                    }
                }

                // Use preloaded tracks if available, otherwise create placeholder tracks
                let tracks;
                if (window.preloadedTracks) {
                    tracks = window.preloadedTracks;
                } else {
                    // Fallback: create tracks with original URLs
                    tracks = tracksData.map(track => ({ ...track }));
                    console.log('Using fallback tracks (preloaded tracks not available)');
                }

                console.log('Tracks prepared:', tracks.length);



                // Set consistent playlist size for both mobile and desktop
                const initialPlaylistSize = 4.4; // Show 12 tracks

                // Set initial position (can be dragged anywhere later)
                const zoomFactor = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--webamp-zoom'));

                // Window dimensions
                const mainWindowWidth = 275;
                const mainWindowHeight = 116;
                const equalizerHeight = 116;
                const playlistHeaderHeight = 30;
                const trackHeight = 14;
                const playlistHeight = playlistHeaderHeight + (initialPlaylistSize * trackHeight);

                // Position windows based on device type
                let leftPosX, mainPosY, eqPosY, playlistPosY;
                const deviceInfo = getDeviceInfo();

                if (deviceInfo.isMobile) {
                    // Simplified mobile positioning - let Webamp handle most of it
                    leftPosX = Math.floor((window.innerWidth - mainWindowWidth) / 2);
                    mainPosY = 50; // Fixed position from top
                    eqPosY = mainPosY;
                    playlistPosY = mainPosY + mainWindowHeight;
                } else {
                    // Desktop: Stack windows on the left side
                    leftPosX = Math.floor((window.innerWidth * 0.08) / zoomFactor);
                    mainPosY = Math.floor((window.innerHeight * 0.12) / zoomFactor);
                    eqPosY = mainPosY + mainWindowHeight;
                    playlistPosY = eqPosY + equalizerHeight;
                }

                // Initialize Webamp with preloaded tracks
                const webampOptions = {
                    initialTracks: tracks,
                    initialSkin: skinOption,
                    zIndex: 100,
                    enableHotkeys: false,
                    __initialWindowLayout: {
                        main: { position: { x: leftPosX, y: mainPosY } },
                        equalizer: { position: { x: leftPosX, y: eqPosY } },
                        playlist: {
                            position: { x: leftPosX, y: playlistPosY },
                            size: [0, initialPlaylistSize]
                        }
                    }
                };

                console.log('Initializing Webamp with options:', webampOptions);
                webampInstance = new Webamp(webampOptions);

                console.log('Rendering Webamp...');
                // Render Webamp and set up the player with timeout
                const renderPromise = webampInstance.renderWhenReady(document.getElementById('webamp-container'));

                // Add timeout for render
                const renderTimeout = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Webamp render timeout')), isMobile() ? 15000 : 10000);
                });

                await Promise.race([renderPromise, renderTimeout]);
                console.log('Webamp rendered successfully');

                // Wait for skin to be loaded with timeout
                if (skinOption) {
                    console.log('Waiting for skin to load...');
                    const skinPromise = webampInstance.skinIsLoaded();
                    const skinTimeout = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('Skin load timeout')), 8000);
                    });

                    try {
                        await Promise.race([skinPromise, skinTimeout]);
                        console.log('Skin loaded successfully');
                    } catch (error) {
                        console.error('Skin loading failed or timed out:', error);
                        // Continue anyway
                    }
                } else {
                    console.log('No custom skin, skipping skin load wait');
                }

                // Set up audio analyzer
                try {
                    await setupAudioAnalyzer();
                } catch (error) {
                    console.error('Audio analyzer setup failed:', error);
                    // Continue without analyzer
                }

                // Intercept Redux store to prevent playlist reordering
                const originalDispatch = webampInstance.store.dispatch;
                webampInstance.store.dispatch = (action) => {
                    if (action.type === 'REMOVE_TRACKS' ||
                        action.type === 'ADD_TRACK_FROM_URL' ||
                        action.type === 'SET_MEDIA' ||
                        action.type === 'PLAYLIST_REORDER') {
                        return;
                    }
                    return originalDispatch(action);
                };

                // Mobile: Let Webamp handle its own touch events
                if (isMobile()) {
                    console.log('Using native Webamp mobile support');
                    // Webamp 1.4.2 has built-in mobile support
                    // Don't override its touch handling
                }

                // Show the player
                const container = document.getElementById('webamp-container');
                if (container) {
                    container.style.opacity = '1';
                    console.log('Webamp container made visible');
                } else {
                    console.error('Webamp container not found');
                }

                // Initialize viewer system (skip heavy parts on mobile)
                try {
                    initBackgroundSystem();
                } catch (error) {
                    console.error('Background system initialization failed:', error);
                }

                // Set up track change handler
                webampInstance.onTrackDidChange(trackInfo => {
                    try {
                        handleTrackChange(trackInfo);
                        // Try to set up audio analyzer again for new track
                        setupAudioAnalyzer();
                    } catch (error) {
                        console.error('Track change handler error:', error);
                    }
                });

                // Set up Media Session API for background playback
                try {
                    setupMediaSession();
                } catch (error) {
                    console.error('Media Session setup failed:', error);
                }

                // Center windows
                try {
                    centerWindows();
                } catch (error) {
                    console.error('Window centering failed:', error);
                }





                // Set playlist size to the specified number of tracks explicitly
                setTimeout(() => {
                    if (webampInstance && webampInstance.store) {
                        const playlistSize = isMobile() ? 4 : initialPlaylistSize; // Mobile playlist size
                        console.log(`Setting playlist size to ${playlistSize} tracks (mobile: ${isMobile()})`);
                        webampInstance.store.dispatch({
                            type: 'SET_PLAYLIST_WINDOW_SIZE',
                            size: [0, playlistSize]
                        });


                    }
                }, 500);

                // Focus the playlist window to bring it to the foreground
                setTimeout(() => {
                    if (webampInstance && webampInstance.store) {
                        webampInstance.store.dispatch({
                            type: 'SET_FOCUSED_WINDOW',
                            window: 'playlist'
                        });

                        // Try multiple approaches to set visualizer to oscilloscope
                        // Approach 1: Try TOGGLE_VISUALIZER_STYLE (might cycle between modes)
                        webampInstance.store.dispatch({
                            type: 'TOGGLE_VISUALIZER_STYLE'
                        });
                    }
                }, 100);

                // Try another approach after a short delay
                setTimeout(() => {
                    if (webampInstance && webampInstance.store) {
                        // Approach 2: Try clicking on the visualizer area programmatically
                        const visualizerElement = document.querySelector('#webamp .visualizer');
                        if (visualizerElement) {
                            visualizerElement.click();
                        }
                    }
                }, 500);



                // Haunted animation disabled in favor of CSS floating animation

                // Let Webamp handle all playlist interactions with default desktop behavior





                // Set the title using direct skin data modification
                try {
                    // Access the skin data in the Redux store
                    const state = webampInstance.store.getState();
                    if (state && state.display && state.display.skinGenLetterWidths) {
                        // Directly dispatch an action to update the skinInfo which controls the title
                        webampInstance.store.dispatch({
                            type: "SET_SKIN_DATA",
                            data: {
                                skinInfo: {
                                    name: "TEST"
                                }
                            }
                        });

                        // Also try the window info update as backup
                        webampInstance.store.dispatch({
                            type: "UPDATE_WINDOW_INFO",
                            window: "main",
                            info: {
                                title: "TEST"
                            }
                        });
                    }
                } catch (e) {
                    console.error("Error setting title:", e);
                }

                // Clean up blob URLs when Webamp closes
                webampInstance.onWillClose(() => {
                    tracks.forEach(track => {
                        if (track.url.startsWith('blob:')) {
                            URL.revokeObjectURL(track.url);
                        }
                    });
                    cleanup();
                });

                // In initWebamp, after setting up the store
                webampInstance.store.subscribe(() => {
                    const state = webampInstance.store.getState();
                    const media = state?.media;

                    // If media starts playing and we don't have an analyzer yet
                    if (media?.status === "PLAYING" && !webampInstance.analyzer) {
                        setupAudioAnalyzer();
                    }
                });



                console.log('Webamp initialization complete');
                return webampInstance;
            } catch (error) {
                console.error("Error initializing Webamp:", error);

                // Try to show something even if Webamp fails
                const container = document.getElementById('webamp-container');
                if (container) {
                    container.innerHTML = `
                        <div style="color: white; padding: 20px; text-align: center; font-family: monospace;">
                            <div style="margin-bottom: 20px;">Audio player failed to load</div>
                            <div style="margin-bottom: 20px;">
                                <button onclick="location.reload()" style="padding: 10px 20px; background: #333; color: white; border: 1px solid #666; cursor: pointer;">
                                    Refresh Page
                                </button>
                            </div>
                            <div style="font-size: 12px; opacity: 0.7;">
                                If this persists, try a different browser or device
                            </div>
                        </div>
                    `;
                    container.style.opacity = '1';
                }

                throw error; // Re-throw to trigger the timeout handler
            }
        }

        // Function to play first track using Webamp API
        function playFirstTrack() {
            if (!webampInstance) {
                console.error("Webamp not initialized");
                return;
            }

            try {
                // Make sure track is selected first
                webampInstance.store.dispatch({
                    type: "SET_CURRENT_TRACK",
                    id: 0
                });

                // Force the play button to be "unpressed" before pressing it again
                webampInstance.store.dispatch({ type: "STOP" });

                // Short delay to ensure track is loaded
                setTimeout(() => {
                    // Try multiple methods to ensure playback starts
                    webampInstance.play();

                    // Also try the direct Redux action
                    webampInstance.store.dispatch({ type: "PLAY" });

                    // Set up audio analyzer after playback starts
                    setTimeout(setupAudioAnalyzer, 1000);

                    // Update media session for background playback
                    if (window.updateMediaSessionMetadata && tracksData[0]) {
                        window.updateMediaSessionMetadata(tracksData[0]);
                    }
                }, 200);
            } catch (e) {
                console.error("Error playing track:", e);
            }
        }

        // Function to play a specific track by index
        function playTrackByIndex(index) {
            if (!webampInstance) return;

            try {
                // First select the track
                webampInstance.store.dispatch({
                    type: "SET_CURRENT_TRACK",
                    id: index
                });

                // Then play it
                setTimeout(() => {
                    webampInstance.play();
                }, 100);
            } catch (e) {
                console.error("Error playing track:", e);
            }
        }

        // Set up player controls using official Webamp API
        function setupPlayerControls() {
            // Wait a moment to ensure Webamp is fully initialized
            setTimeout(() => {
                if (!webampInstance) return;

                // Use official Webamp API for track changes only
                webampInstance.onTrackDidChange(trackInfo => {
                    handleTrackChange(trackInfo);
                    // Try to set up audio analyzer again for new track
                    setupAudioAnalyzer();
                });
            }, 1000);
        }

        // Enhanced mobile touch fix for Webamp playlist
        function setupMobileTouchFix() {
            if (!isMobile() || !webampInstance) return;

            console.log('Setting up mobile touch fix for playlist');

            // Wait a bit for Webamp to fully initialize
            setTimeout(() => {
                // Find all track elements in the playlist
                const tracks = document.querySelectorAll('#webamp .playlist-tracks .track');
                
                if (tracks.length === 0) {
                    console.log('No tracks found, retrying...');
                    setTimeout(setupMobileTouchFix, 500);
                    return;
                }

                // Add click handler to each track
                tracks.forEach((track, index) => {
                    track.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        console.log(`Playing track ${index}`);
                        
                        // Use Webamp's API to play the track
                        if (webampInstance) {
                            webampInstance.store.dispatch({
                                type: "SET_CURRENT_TRACK",
                                id: index
                            });
                            
                            setTimeout(() => {
                                webampInstance.play();
                            }, 100);
                        }
                    });
                });
                
                console.log(`Mobile touch fix applied to ${tracks.length} tracks`);
            }, 500);
        }

        // Let Webamp handle its own touch events
        function ensureWebampTouchDragging() {
            if (!isMobile() || !webampInstance) return;
            
            console.log('Webamp native touch support enabled');
            // Webamp has built-in touch support - we don't need to override it
        }



        // Add cleanup for background transition timeouts
        function cleanup() {
            if (eqIntervalId) {
                clearInterval(eqIntervalId);
                eqIntervalId = null;
            }

            window.eqInitialized = false;

            // Cleanup starfield
            if (starField) {
                starField.destroy();
                starField = null;
            }

            // Cleanup deity messages
            if (deityMessageSystem) {
                deityMessageSystem.cleanup();
            }

            // Reset viewer window
            const viewerWindow = document.getElementById('viewer-window');
            if (viewerWindow) {
                viewerWindow.classList.remove('visible', 'tv-appearing', 'tv-disappearing', 'fullscreen-mode');
                const viewerContainer = viewerWindow.querySelector('.viewer-loop-container');
                if (viewerContainer) {
                    viewerContainer.innerHTML = '';
                }
            }

            if (webampInstance) {
                try {
                    webampInstance.close();
                } catch (e) { }
                webampInstance = null;
            }

            document.getElementById('webamp-container').innerHTML = '';
        }

        // Function to restart Webamp with a different skin
        async function restartWithDifferentSkin() {
            cleanup();
            usesCustomSkin = !usesCustomSkin;
            initWebamp();
        }

        // Password validation function
        function setupPasswordValidation() {
            const passwordInput = document.getElementById('password-input');
            const accessIndicator = document.getElementById('access-indicator');
            const passwordOverlay = document.getElementById('password-overlay');
            const correctPassword = 'vomitorium';

            // Show/hide the password label based on input
            passwordInput.addEventListener('input', function () {
                const label = document.getElementById('password-label');
                if (this.value) {
                    label.style.opacity = '0';
                } else {
                    label.style.opacity = '1';
                }

                // Add flashing effect when typing
                this.classList.add('flashing');
                setTimeout(() => {
                    this.classList.remove('flashing');
                }, 500);
            });

            // Check password on enter key
            passwordInput.addEventListener('keypress', function (e) {
                if (e.key === 'Enter') {
                    checkPassword();
                }
            });

            // Password validation
            function checkPassword() {
                if (passwordInput.value.toLowerCase() === correctPassword) {
                    // Show success indicator
                    accessIndicator.classList.add('granted');

                    // Initialize Webamp with timeout protection
                    const initTimeout = setTimeout(() => {
                        console.error('Webamp initialization timeout - forcing continue');
                        continueAfterPassword();
                    }, 20000); // 20 second timeout

                    // Initialize Webamp here before showing it
                    initWebamp().then((instance) => {
                        clearTimeout(initTimeout);
                        console.log('Webamp initialized successfully');
                        continueAfterPassword();

                        // Start background preloading AFTER the site is shown
                        setTimeout(() => {
                            console.log('Starting background preloading...');
                            preloadRemainingTracks();
                        }, 2000);
                    }).catch((error) => {
                        clearTimeout(initTimeout);
                        console.error('Webamp initialization failed:', error);
                        // Continue anyway to prevent hanging
                        continueAfterPassword();
                    });

                    function continueAfterPassword() {
                        console.log('Continuing after password validation...');

                        // Wait a moment, then fade out the overlay
                        setTimeout(() => {
                            console.log('Fading out password overlay...');
                            passwordOverlay.style.opacity = '0';
                            passwordOverlay.style.pointerEvents = 'none';
                            passwordUnlocked = true;

                            // Show the viewer window normally
                            const viewerWindow = document.getElementById('viewer-window');
                            if (viewerWindow) {
                                viewerWindow.classList.add('visible');
                                console.log('Viewer window made visible');
                            }

                            // Show the cover window (always show on mobile, hide on desktop)
                            const coverWindow = document.getElementById('cover-window');
                            if (coverWindow) {
                                if (isMobile()) {
                                    coverWindow.classList.add('visible');
                                    console.log('Mobile layout: viewer and cover windows positioned by CSS');
                                } else {
                                    coverWindow.style.display = 'none';
                                    console.log('Desktop: cover window hidden');
                                }
                            }

                            // After password overlay fades out, start playback
                            setTimeout(() => {
                                console.log('Starting post-password initialization...');

                                try {
                                    // Initialize the first track's video in viewer window
                                    console.log('Switching to first track background...');
                                    switchBackground(0);

                                    if (webampInstance) {
                                        console.log('Starting first track playback...');
                                        playFirstTrack();
                                    } else {
                                        console.warn('Webamp instance not available for playback');
                                    }
                                } catch (error) {
                                    console.error('Error starting playback:', error);
                                }

                                // Fade in the logo and start animation
                                const logoLink = document.getElementById('legendarium-logo-link');
                                if (logoLink) {
                                    logoLink.classList.add('visible');
                                    console.log('Logo made visible');
                                    if (!window.legendariumLogoAnimStarted) {
                                        window.legendariumLogoAnimStarted = true;
                                        startLegendariumLogoAnimation();
                                    }
                                }

                                // Delay deity messages more on mobile
                                setTimeout(() => {
                                    try {
                                        console.log('Initializing deity message system...');
                                        deityMessageSystem.init();
                                    } catch (error) {
                                        console.error('Error initializing deity messages:', error);
                                    }
                                }, isMobile() ? 8000 : 5000);

                                console.log('Post-password initialization complete');
                            }, isMobile() ? 1000 : 2000); // Shorter delay on mobile
                        }, 700);
                    }
                } else {
                    // Show failure indication (shake the input)
                    passwordInput.style.animation = 'none';
                    void passwordInput.offsetWidth; // Trigger reflow
                    passwordInput.style.animation = 'shake 0.5s';
                }
            }
        }

        // Enhanced Media Session API for background playback with iPhone Chrome fixes
        function setupMediaSession() {
            if (!('mediaSession' in navigator)) {
                console.log('Media Session API not supported');
                return;
            }

            const deviceInfo = getDeviceInfo();
            console.log('Setting up Media Session API for background playback', deviceInfo);

            // Set up media session metadata
            function updateMediaSessionMetadata(trackInfo) {
                if (!trackInfo) return;

                const metadata = {
                    title: trackInfo.metaData?.title || trackInfo.defaultName || 'Unknown Track',
                    artist: 'GATEKEEPER',
                    album: 'HIBERNAL TORMENT',
                    artwork: [
                        {
                            src: 'https://res.cloudinary.com/dtwix3ubl/image/upload/v1751300090/gkHourglass8_np2lyy.jpg',
                            sizes: '512x512',
                            type: 'image/jpeg'
                        }
                    ]
                };

                navigator.mediaSession.metadata = new MediaMetadata(metadata);
                console.log('Media session metadata updated:', metadata.title);
            }

            // Enhanced action handlers with iPhone Chrome specific handling
            navigator.mediaSession.setActionHandler('play', () => {
                console.log('Media session: play');
                if (webampInstance) {
                    // iPhone Chrome sometimes needs audio context resume
                    if (deviceInfo.isIOSChrome && webampInstance.audioContext?.state === 'suspended') {
                        webampInstance.audioContext.resume().then(() => {
                            webampInstance.play();
                        }).catch(err => {
                            console.log('Audio context resume failed:', err);
                            webampInstance.play(); // Try anyway
                        });
                    } else {
                        webampInstance.play();
                    }
                }
            });

            navigator.mediaSession.setActionHandler('pause', () => {
                console.log('Media session: pause');
                if (webampInstance) {
                    webampInstance.pause();
                }
            });

            navigator.mediaSession.setActionHandler('previoustrack', () => {
                console.log('Media session: previous track');
                if (webampInstance) {
                    webampInstance.previousTrack();
                }
            });

            navigator.mediaSession.setActionHandler('nexttrack', () => {
                console.log('Media session: next track');
                if (webampInstance) {
                    webampInstance.nextTrack();
                }
            });

            // iPhone Chrome specific: Set additional action handlers for better control
            if (deviceInfo.isIOSChrome) {
                try {
                    navigator.mediaSession.setActionHandler('stop', () => {
                        console.log('Media session: stop (iPhone Chrome)');
                        if (webampInstance) {
                            webampInstance.pause();
                        }
                    });
                    
                    // Enhanced seek support for iPhone Chrome
                    navigator.mediaSession.setActionHandler('seekto', (details) => {
                        console.log('Media session: seek to', details.seekTime);
                        if (webampInstance && details.seekTime != null) {
                            webampInstance.seekToTime(details.seekTime);
                        }
                    });
                } catch (error) {
                    console.log('Optional media session handlers not supported:', error);
                }
            }

            // Store the update function for use in track changes
            window.updateMediaSessionMetadata = updateMediaSessionMetadata;

            // Set initial metadata if we have track info
            const state = webampInstance?.store?.getState();
            const currentTrack = state?.playlist?.currentTrack;
            if (currentTrack !== null && tracksData[currentTrack]) {
                updateMediaSessionMetadata(tracksData[currentTrack]);
            }
        }

        // Enhanced audio analyzer setup with iPhone Chrome support
        async function setupAudioAnalyzer() {
            try {
                // Check if we already have an analyzer set up
                if (webampInstance.analyzer) {
                    return;
                }

                const deviceInfo = getDeviceInfo();
                
                // Create audio context and analyzer only if they don't exist
                if (!webampInstance.audioContext) {
                    // iPhone Chrome specific audio context handling
                    if (deviceInfo.isIOSChrome) {
                        console.log('Setting up audio context for iPhone Chrome');
                        webampInstance.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                            latencyHint: 'playback',
                            sampleRate: 44100 // Explicit sample rate for iPhone Chrome
                        });
                    } else {
                        webampInstance.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                }

                if (!webampInstance.analyzer) {
                    webampInstance.analyzer = webampInstance.audioContext.createAnalyser();
                    webampInstance.analyzer.fftSize = 256;
                    webampInstance.audioData = new Uint8Array(webampInstance.analyzer.frequencyBinCount);
                }

                // Function to connect audio
                const connectAudio = () => {
                    return new Promise((resolve, reject) => {
                        // Get Webamp's media element
                        const state = webampInstance.store.getState();
                        const media = state?.media;

                        if (!media) {
                            reject(new Error('No media state available'));
                            return;
                        }

                        // Get the actual audio element from Webamp
                        const audioElement = document.querySelector('#webamp audio');
                        if (!audioElement) {
                            reject(new Error('Audio element not found'));
                            return;
                        }

                        try {
                            // Create and connect the source only if it doesn't exist
                            if (!webampInstance.source) {
                                webampInstance.source = webampInstance.audioContext.createMediaElementSource(audioElement);
                            }

                            // Connect the nodes
                            webampInstance.source.connect(webampInstance.analyzer);
                            webampInstance.analyzer.connect(webampInstance.audioContext.destination);

                            resolve(true);
                        } catch (e) {
                            console.error('Error connecting audio:', e);
                            reject(e);
                        }
                    });
                };

                // Try to connect with increasing delays, longer for iPhone Chrome
                let retries = 0;
                const maxRetries = deviceInfo.isIOSChrome ? 8 : 5; // More retries for iPhone Chrome
                const tryConnect = async () => {
                    try {
                        await connectAudio();
                    } catch (e) {
                        if (retries < maxRetries) {
                            retries++;
                            // Wait longer between each retry, especially for iPhone Chrome
                            const baseDelay = deviceInfo.isIOSChrome ? 1500 : 1000;
                            const delay = Math.min(baseDelay * Math.pow(2, retries), 15000);
                            setTimeout(tryConnect, delay);
                        }
                    }
                };

                // Resume audio context if it's suspended (critical for iPhone Chrome)
                if (webampInstance.audioContext.state === 'suspended') {
                    console.log('Resuming suspended audio context');
                    await webampInstance.audioContext.resume();
                    
                    // iPhone Chrome often needs additional time after resume
                    if (deviceInfo.isIOSChrome) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }

                // Start trying to connect
                tryConnect();

            } catch (e) {
                console.error('Error in setupAudioAnalyzer:', e);
            }
        }

        // Legendarium logo orbiting animation
        function startLegendariumLogoAnimation() {
            const logo = document.getElementById('legendarium-logo');
            if (!logo) return;
            let start = null;
            let isHovered = false;

            // Add hover listeners
            const logoLink = document.getElementById('legendarium-logo-link');
            logoLink.addEventListener('mouseenter', () => isHovered = true);
            logoLink.addEventListener('mouseleave', () => isHovered = false);

            function animate(ts) {
                if (!start) start = ts;
                const t = (ts - start) / 1000;

                if (!isHovered) {
                    // Only orbit and spin when not hovered
                    const orbitRadiusX = 4; // px
                    const orbitRadiusY = 2; // px
                    const orbitSpeed = 0.15; // radians/sec
                    const angle = t * orbitSpeed;
                    const x = Math.cos(angle) * orbitRadiusX;
                    const y = Math.sin(angle) * orbitRadiusY;
                    const spin = Math.sin(t * 0.25) * 90; // -90deg to +90deg
                    logo.style.transform = `translate(${x}px, ${y}px) rotateY(${spin}deg)`;
                }
                requestAnimationFrame(animate);
            }
            requestAnimationFrame(animate);
        }

        // Handle window resize for mobile layout adjustments
        function handleResize() {
            // Windows should maintain their positions after initial placement
            // Only handle other resize-related adjustments if needed
        }

        // Mobile-first loading optimization with iPhone Chrome fixes
        function initializeMobile() {
            const deviceInfo = getDeviceInfo();
            console.log('Mobile optimized initialization', deviceInfo);

            // iPhone Chrome specific viewport fix
            if (deviceInfo.isIOSChrome) {
                console.log('Applying iPhone Chrome specific fixes');
                
                // Fix viewport handling for iPhone Chrome
                const viewport = document.querySelector('meta[name="viewport"]');
                if (viewport) {
                    viewport.setAttribute('content', 
                        'width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover');
                }
                
                // Add iPhone Chrome specific CSS fixes
                const style = document.createElement('style');
                style.textContent = `
                    /* iPhone Chrome specific fixes */
                    @supports (-webkit-touch-callout: none) {
                        body {
                            -webkit-text-size-adjust: 100%;
                            -webkit-font-smoothing: antialiased;
                        }
                        
                        #webamp-container {
                            -webkit-transform: translateZ(0);
                            transform: translateZ(0);
                        }
                    }
                `;
                document.head.appendChild(style);
            }

            // Initialize starfield background
            starField = new StarField();

            // Setup password validation
            setupPasswordValidation();

            // Show password overlay
            const passwordOverlay = document.getElementById('password-overlay');
            if (passwordOverlay) {
                passwordOverlay.style.opacity = '1';
                passwordOverlay.style.pointerEvents = 'auto';
            }

            // Focus on password input with longer delay for iPhone Chrome
            const focusDelay = deviceInfo.isIOSChrome ? 300 : 100;
            setTimeout(() => {
                const passwordInput = document.getElementById('password-input');
                if (passwordInput) {
                    passwordInput.focus();
                }
            }, focusDelay);
        }

        // Desktop initialization with full features
        function initializeDesktop() {
            console.log('Desktop optimized initialization');

            // Initialize starfield background
            starField = new StarField();

            // Setup password validation
            setupPasswordValidation();

            // Show password overlay
            const passwordOverlay = document.getElementById('password-overlay');
            if (passwordOverlay) {
                passwordOverlay.style.opacity = '1';
                passwordOverlay.style.pointerEvents = 'auto';
            }

            // Focus on password input
            setTimeout(() => {
                const passwordInput = document.getElementById('password-input');
                if (passwordInput) {
                    passwordInput.focus();
                }
            }, 500);
        }

        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('DOM loaded, starting initialization...');
            const deviceInfo = getDeviceInfo();
            console.log('Device detected:', deviceInfo);

            // Show password screen immediately on all devices
            try {
                if (deviceInfo.isMobile) {
                    initializeMobile();
                } else {
                    initializeDesktop();
                }
            } catch (error) {
                console.error('Initialization error:', error);
                // Fallback to basic initialization
                setupPasswordValidation();
                const passwordOverlay = document.getElementById('password-overlay');
                if (passwordOverlay) {
                    passwordOverlay.style.opacity = '1';
                    passwordOverlay.style.pointerEvents = 'auto';
                }
            }

            // Start preloading in background after a short delay
            setTimeout(async () => {
                try {
                    console.log('Starting background preload...');
                    await preloadFirstTrackOnly();
                    console.log('Background preload complete');
                } catch (error) {
                    console.error('Background preload failed:', error);
                    // Continue anyway - the site will still work with original URLs
                }
            }, 1000);

            // Call the animation function if needed
            if (!window.legendariumLogoAnimStarted) {
                window.legendariumLogoAnimStarted = true;
                startLegendariumLogoAnimation();
            }

            // Add resize listener for mobile layout adjustments
            window.addEventListener('resize', handleResize);

            // Enhanced visibility changes to maintain background playback (iPhone Chrome fixes)
            document.addEventListener('visibilitychange', () => {
                const deviceInfo = getDeviceInfo();
                
                if (document.hidden) {
                    console.log('Page hidden - maintaining audio context for background playback');
                    
                    // iPhone Chrome specific handling
                    if (deviceInfo.isIOSChrome) {
                        // Keep audio context active more aggressively on iPhone Chrome
                        if (webampInstance?.audioContext) {
                            // Prevent audio context suspension
                            const resumeAudio = () => {
                                if (webampInstance.audioContext.state === 'suspended') {
                                    webampInstance.audioContext.resume().catch(err => {
                                        console.log('Background audio context resume failed:', err);
                                    });
                                }
                            };
                            
                            // Try to resume immediately and set up periodic resume attempts
                            resumeAudio();
                            
                            // Set up periodic resume for iPhone Chrome
                            if (!window.iPhoneChromeResumeInterval) {
                                window.iPhoneChromeResumeInterval = setInterval(resumeAudio, 1000);
                            }
                        }
                        
                        // Update media session playback state
                        if (navigator.mediaSession) {
                            navigator.mediaSession.playbackState = 'playing';
                        }
                    } else {
                        // Standard handling for other browsers
                        if (webampInstance?.audioContext && webampInstance.audioContext.state === 'suspended') {
                            webampInstance.audioContext.resume().catch(err => {
                                console.log('Could not resume audio context:', err);
                            });
                        }
                    }
                } else {
                    console.log('Page visible - resuming normal operation');
                    
                    // Clear iPhone Chrome specific intervals
                    if (deviceInfo.isIOSChrome && window.iPhoneChromeResumeInterval) {
                        clearInterval(window.iPhoneChromeResumeInterval);
                        window.iPhoneChromeResumeInterval = null;
                    }
                    
                    // Ensure audio context is active when returning to page
                    if (webampInstance?.audioContext && webampInstance.audioContext.state === 'suspended') {
                        webampInstance.audioContext.resume().catch(err => {
                            console.log('Could not resume audio context on page visible:', err);
                        });
                    }
                }
            });

            // Cleanup on page unload
            window.addEventListener('beforeunload', () => {
                if (starField) {
                    starField.destroy();
                }
            });
        });

        // Remove animation toggle related styles
        document.head.insertAdjacentHTML('beforeend', `
            <style>
                @keyframes shake {
                    0%, 100% { transform: translateX(0); }
                    10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
                    20%, 40%, 60%, 80% { transform: translateX(5px); }
                }
                
                .shake {
                    animation: shake 0.5s;
                }
            </style>
        `);





        // Simplified function to get audio level - more reliable
        function getAudioLevel() {
            // Get the current state from Webamp
            const state = webampInstance?.store?.getState();
            const media = state?.media;

            if (!media) return 0;

            // Check if we're actually playing
            const isPlaying = media.status === "PLAYING" && !media.waiting;
            if (!isPlaying) {
                return 0;
            }

            let audioLevel = 0;

            // Try to get data from analyzer if available
            if (webampInstance?.analyzer && webampInstance?.audioData) {
                try {
                    // Get frequency data
                    webampInstance.analyzer.getByteFrequencyData(webampInstance.audioData);

                    // Use a simple average of frequency data for reliability
                    let sum = 0;
                    const count = Math.min(webampInstance.audioData.length, 128); // Use first 128 bins or less

                    for (let i = 0; i < count; i++) {
                        sum += webampInstance.audioData[i];
                    }

                    // Normalize to 0-1 range
                    audioLevel = sum / (count * 255);

                    // Apply a slight curve for better visualization
                    audioLevel = Math.pow(audioLevel, 1.2);

                } catch (e) {
                    console.error('Error getting audio data:', e);
                    // Fall back to volume-based method
                    audioLevel = 0;
                }
            }

            // If analyzer failed or isn't available, fallback to volume
            if (audioLevel === 0) {
                // Get the volume from the state and normalize it
                const volume = state.media.volume || 0;
                const normalizedVolume = volume / 100;
                audioLevel = normalizedVolume * 0.7; // Scale down a bit for fallback
            }

            // Ensure reasonable bounds and add a minimum level to ensure some activity
            return Math.max(0.05, Math.min(1, audioLevel));
        }
    </script>
    <a id="legendarium-logo-link" href="https://legendarium.nyc" target="_blank" rel="noopener">
        <img id="legendarium-logo" src="assets/images/Legendarium-Logo-Trans-1.png" alt="Legendarium Logo">
    </a>
</body>

</html>